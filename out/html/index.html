<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSJ User&#39;s Guide.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SSJ User's Guide. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="REF_0_sec_01"></a>
Introduction and overview</h1>
<p>Simulation models can be implemented in many ways <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>&thinsp;. One can use general-purpose programming languages such as FORTRAN, C, C++, Java, or specialized simulation languages such as <em>GPSS</em>, <em>SIMAN</em>, and <em>SIMSCRIPT</em>. The general-purpose languages may be more familiar to the programmer, but usually do not have the necessary built-in tools to perform simulation. Implementing a model can become complex and tedious. Specialized simulation languages must be learned before models can be implemented, and they are not as widely available and supported as the most popular general-purpose languages.</p>
<p>Over the past few decades, commercial simulation tools with point-and-click graphical user interfaces such as <em>Arena</em>, <em>Automod</em>, <em>Witness</em>, and many others, have become by far the most widely used tools to develop simulation models. Among their main advantages, these tools do not require knowledge of a programming language, provide graphical animation, have automatic facilities to collect statistics and perform experiments, and can sometimes perform optimization to a certain extent. On the other hand, these specialized simulation tools, especially the point-and-click tools, are often too restrictive, because they are usually targeted at a limited class of models. With these tools, simulating a system whose logic is complicated or unconventional may become quite difficult. All the graphical and automatic devices also tend to slow down the simulation significantly. Fast execution times are important for example in a context of optimization, where thousands of variants of a base system may have to be simulated, or for on-line applications where a fast response time is required.</p>
<p>SSJ is an organized set of packages whose purpose is to facilitate simulation programming in the Java language. A first description was given in <a class="el" href="citelist.html#CITEREF_sLEC02a">[132]</a>&thinsp;. Some of the tools can also be used for modeling (e.g., selecting and fitting distributions). A simulation library, such as SSJ, extends the Java programming language to equip it with the necessary tools for implementing complex models. One can use a familiar programming language, such as Java, with high-level tools for simulation. A simulation project can be divided in several tasks, from modeling to implementation <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>&thinsp;. SSJ provides tools for model implementation and validation. As these lines are being written, SSJ is still growing. Several new packages, classes, and methods will certainly be added in forthcoming years and others will be refined.</p>
<p>The facilities offered are grouped into different packages, each one having its own userâ€™s guide, in the form of a PDF file. There is also a set of commented examples of simulation programs in a separate directory with its own guide. Programs are given for some of the examples used in the books of Law and Kelton <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>&thinsp; and Glasserman <a class="el" href="citelist.html#CITEREF_fGLA04a">[67]</a>&thinsp;, for instance. The best way to learn about SSJ, at the beginning, is probably to study these examples and refer to the user guides of the different packages when needed. The PDF files are the official documentation. There is also a simplified on-line documentation in HTML format, produced via <code>javadoc</code>.</p>
<p>The packages currently offered are the following:</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1util.html">umontreal::ssj::util</a> contains utility classes used in the implementation of SSJ, and which are often useful elsewhere. For example, there are timers (for CPU usage), utilities to read or format numbers and arrays from/to text, operations on binary vectors and matrices, some mathematical functions and constants, root-finding tools, facilities for SQL database interface, and so on.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1util_1_1sort.html">umontreal::ssj::util::sort</a> contains utility classes to sort multi-dimensional points.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, and inverse distribution functions for many discrete and continuous probability distributions, as well as estimating the parameters of these distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1probdistmulti.html">umontreal::ssj::probdistmulti</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, for some multi-dimensionnal discrete and continuous probability distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> provides facilities for generating uniform random numbers over the interval \((0,1)\), or over a given range of integer values, and other types of simple random objects such as random permutations.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> provides classes implementing highly uniform point sets and sequences (HUPS), also called low-discrepancy sets and sequences, and tools for their randomization.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> provides a collection of classes for non-uniform random variate generation, primarily from standard distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1randvarmulti.html">umontreal::ssj::randvarmulti</a> provides a collection of classes for random number generators for some multi-dimensional distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1gof.html">umontreal::ssj::gof</a> contains tools for performing univariate goodness-of-fit (GOF) statistical tests.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> provides elementary tools for collecting statistics and computing confidence intervals.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1matrix.html">umontreal::ssj::stat::matrix</a> this subpackage of <code>stat</code> provides facilities to create and manage rectangular two-dimensional arrays of statistical collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1list.html">umontreal::ssj::stat::list</a> this subpackage of <code>stat</code> provides support to manage lists of statistical collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1list_1_1lincv.html">umontreal::ssj::stat::list::lincv</a> this subpackage of <code>stat.list</code> provides classes that help implement control variables on lists of collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simevents.html">umontreal::ssj::simevents</a> provides and manages the event-driven simulation facilities as well as the simulation clock. Can manage several simulations in parallel, in the same program.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simevents_1_1eventlist.html">umontreal::ssj::simevents::eventlist</a> this subpackage of <code>simevents</code> offers several kinds of event list implementations.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1functions.html">umontreal::ssj::functions</a> contains classes that allow one to pass an arbitrary function of one variable as argument to a method and to apply elementary mathematical operations on generic functions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1functionfit.html">umontreal::ssj::functionfit</a> provides basic facilities for curve fitting and interpolation with polynomials.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simexp.html">umontreal::ssj::simexp</a> provides facilities for performing simulation experiments using independent replications as well as simulations using batch means.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1charts.html">umontreal::ssj::charts</a> provides tools for easy construction, visualization, and customization of \(xy\) plots, histograms, and empirical styled charts from a Java program.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1markovchainrqmc.html">umontreal::ssj::markovchainrqmc</a> contains classes related to Markov chains simulation using randomized quasi-Monte Carlo.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stochprocess.html">umontreal::ssj::stochprocess</a> implements different kinds of stochastic processes.</p>
<h1><a class="anchor" id="REF_0_sec_02"></a>
Dependence on other libraries</h1>
<p>SSJ uses some classes from other free Java libraries.</p>
<p>The <a href="http://acs.lbl.gov/software/colt/">Colt library</a> , developed at the Centre EuropÃ©en de Recherche NuclÃ©aire (CERN) in Geneva <a class="el" href="citelist.html#CITEREF_iHOS04a">[89]</a>&thinsp;, is a large library that provides a wide range of facilities for high performance scientific and technical computing in Java. SSJ uses the class DoubleArrayList from Colt in a few of its classes, namely in packages <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> and <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a>. The reason is that this class provides a very efficient and convenient implementation of an (automatically) extensible array of <code>double</code>, together with several methods for computing statistics for the observations stored in the array (see, e.g., <code>Descriptive</code>). The Colt library is distributed with the SSJ package as <b>colt.jar</b>. It must be added in the CLASSPATH environment variable.</p>
<p>The <b>linear_algebra</b> library is based on public domain LINPACK routines. They were translated from Fortran to Java by Steve Verrill at the USDA Forest Products Laboratory Madison, Wisconsin, USA. The optimization package of Steve Verrill includes Java translations of the <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Minpack_f77.html">MINPACK</a> routines <a class="el" href="citelist.html#CITEREF_iMOR80a">[94]</a>&thinsp; for nonlinear least squares problems as well as <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Uncmin_f77.html">UNCMIN</a> routines <a class="el" href="citelist.html#CITEREF_iSCHa">[201]</a>&thinsp; for unconstrained optimization. They were translated from Fortran to Java by Steve Verrill and are in the public domain. They are included in the SSJ distribution as the <b>optimization.jar</b> archive. It is used only in the <code>probdist</code> package to compute maximum likelihood estimators.</p>
<p><a href="http://www.jfree.org/jfreechart/index.html">JFreeChart</a> is a free Java library that can generate a wide variety of charts and plots for use in applications, applets and servlets. <b>JFreeChart</b> currently supports, amongst others, bar charts, pie charts, line charts, XY-plots, histograms, scatter plots and time series plots. It is distributed with SSJ as <b>jfreechart-*.jar</b>. <a href="http://www.jfree.org/jcommon/index.php">JCommon</a> is a free general purpose Java library containing many useful classes used by JFreeChart and other Java packages. It is distributed with SSJ as <b>jcommon-*.jar</b>. JFreeChart (and JCommon) are used in the SSJ package <b>charts</b> to create different kinds of charts.</p>
<p>SSJ also provides an interface to the <a href="http://statistik.wu-wien.ac.at/unuran/">UNURAN</a> library for nonuniform random number generation <a class="el" href="citelist.html#CITEREF_iLEY02a">[158]</a>&thinsp;, in the <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> package. UNURAN does not have to be installed to be used with SSJ, because it is linked statically with the appropriate SSJ native library. However, the UNURAN documentation will be required to take full advantage of the library.</p>
<h1><a class="anchor" id="REF_0_sec_03"></a>
Random Number Generation</h1>
<p>Random numbers feed simulation models and allow one to compute statistics. To generate random numbers from any probability distribution, uniform random numbers are required. Such numbers are uniformly distributed in the \([0,1)\) interval, i.e., the probability of getting a given number \(x\) in that interval is the same for all values of \(x\in[0,1)\). Any generated number \(x\) is also independent from any previous or future generated numbers. Although the generated uniforms are not truly independent since one uniform is obtained from the previous uniforms by a mathematical formula, one can consider them independent for simulation purposes. Selection of a random number generator is based on several criteria such as uniformity, performance, and portability <a class="el" href="citelist.html#CITEREF_rLEC01d">[146]</a>&thinsp;. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> contains the needed tools to generate such numbers. It defines an interface called <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> implemented by any random number generator supported by SSJ. This interface allows one to easily interchange random number generators since they are accessed through the same set of methods specified by the interface. Only the random number generator setup depends on the type of generator that was chosen.</p>
<p>If one wants to replace uniform random numbers with low-discrepancy point sets for variance reduction, the package <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> contains all the necessary facilities. Such highly uniform point sets all inherit from the <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> which provides a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> extending <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a>. The replacement can be easily done without modifying the model implementation, except the setup-time code.</p>
<p>To generate non-uniform random numbers, one must select a probability distribution based on the empirical data <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>&thinsp;. SSJ does not provide probability distribution estimation tools, but goodness of fit tests are included to help in model validation. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> contains several standard, commonly-used, probability distributions. It supports discrete and continuous distributions through two different abstract base classes: <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">umontreal.ssj.probdist.ContinuousDistribution</a> and <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1DiscreteDistribution.html">umontreal.ssj.probdist.DiscreteDistribution</a>, respectively. Again, since the distributions inherit from a common class, their access can be independent from the selected distribution, except for the setup case. One can compute the density/mass, distribution, complementary, and inverse distribution functions. These facilities are also accessible through static methods implemented in each distribution class if one does not want to create objects or needs distributions whose parameters vary in time. However, setup-time operations must be performed for each operation, which can be inefficient for certain distributions.</p>
<p>To generate non-uniform random numbers, the packages <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> (or <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> ) and <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> must be used together. The simplest generation method is to generate a uniform random number using a generator implementing <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> (or get a coordinate using a point set iterator) and to apply inversion by using the selected <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> distributionâ€™s <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html#a47dfe73ca7d2e4a8bf34bc96af34530a" title="Returns the inverse distribution function . ">umontreal.ssj.probdist.ContinuousDistribution.inverseF</a> method. However, inversion is not the only generation method and sometimes not the most efficient. For some distributions, closed-form inverse functions or fast inversion algorithms exist. For others, inversion is performed using binary or even linear search. In such cases, the performance and precision depends on the complexity of the distribution function which is calculated several times for one inverse. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> acts as glue between uniform random number generators and probability distributions. Continuous or discrete random number generators also inherits from common base classes, namely <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGen.html">umontreal.ssj.randvar.RandomVariateGen</a> and <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGenInt.html">umontreal.ssj.randvar.RandomVariateGenInt</a>. All generators use a random stream and a probability distribution for their construction. As opposed to <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a>, one can directly instantiate <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGen.html">umontreal.ssj.randvar.RandomVariateGen</a> or <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGenInt.html">umontreal.ssj.randvar.RandomVariateGenInt</a>. However, in such cases, only inversion generation method will be available. To use an alternate generation method, one must instantiate a specialized generator class and switch to the given generation algorithm using an object method. Each specialized class also provides static method which perform the same action. Although they allow one to avoid object creation, their signatures are specific to the used distribution and they have to perform setup-time operations on each variate generation, which can become inefficient.</p>
<h1><a class="anchor" id="REF_0_sec_04"></a>
Performing simulation</h1>
<p>SSJ supports discrete-event, process-driven, continuous or mixed simulation. The discrete-event and continuous simulation are managed by the package <a class="el" href="namespaceumontreal_1_1ssj_1_1simevents.html">umontreal::ssj::simevents</a>. This package manages the simulation clock and the event list, two essential components for all discrete-event simulations. The simulation clock tracks the simulation time whereas the event list stores the scheduled events to execute them in the right order. Events are user-defined subclasses of <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html">umontreal.ssj.simevents.Event</a>. When an event occurs, any type of actions can then be taken. The package provides a class called umontreal.ssj.simevents.LinkedListStat&lt;E&gt; which implements a linked list supporting statistical collection. Continuous simulation can be performed using the class <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html">umontreal.ssj.simevents.Continuous</a>. It uses the event framework to resolve differential equations numerically at fixed steps in the simulation time.</p>
<h1><a class="anchor" id="REF_0_sec_05"></a>
Other tools</h1>
<p>The package <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> provides basic tools for statistical collection. Statistics are collected using statistical probes, i.e, objects implementing the abstract class <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">umontreal.ssj.stat.StatProbe</a>. Two types of probes are supported. The <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">umontreal.ssj.stat.Tally</a> allows to collect observations of the form \(X_1,â€¦,X_n\) whereas <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Accumulate.html">umontreal.ssj.simevents.Accumulate</a> collects statistics for a continuous variable evolving in simulation time. During the simulation, one can add observations to such probes. After the simulation, measures can be obtained, such as sample average, sample standard deviation or confidence interval. A statistical report can be obtained for all probes. The package also provides a way to detach statistical collection from the model implementation by using bound properties.</p>
<p>To test a proposed model against empirical data, goodness of fit tests are provided in the package <a class="el" href="namespaceumontreal_1_1ssj_1_1gof.html">umontreal::ssj::gof</a>. Such tests, e.g. Kolmogorov-Smirnov or Anderson-Darling, compute a statistic using the empirical observations and the proposed distribution. The empirical observations are given as an array whereas the distribution is given as a <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> object. From the computed statistic, it is possible to compute the \(p\)-value which is useful to evaluate the significance of the test.</p>
<h1><a class="anchor" id="REF_0_sec_06"></a>
Related documentation</h1>
<p>The <code>example.pdf</code> file, in the <code>doc/pdf</code> subdirectory of the SSJ distribution, explains simulation examples implemented using SSJ. This may be the best starting point to learn SSJ. O ne can find additional information and references in the PDF version of this documentation, available in the <code>doc/pdf</code> subdirectory of the SSJ distribution.</p>
<p>very package introduced here contains its own reference documentation as a PDF file, in the <code>doc/pdf</code> subdirectory. This documentation describes in more details how to use the package and provides a description of each class and method.</p>
<h1><a class="anchor" id="ssj_acknowledgments"></a>
Acknowledgments</h1>
<p>SSJ was designed and implemented under the supervision of Pierre Lâ€™Ecuyer, with the contribution of the following persons</p>
<p>Mathieu Bague, Sylvain Bonnet, Ã‰ric Buist, Maxime Dion, Yves Edel, Regina H. S. Hong, Alexander Keller, Pierre Lâ€™Ecuyer, Ã‰tienne Marcotte, Lakhdar Meliani, FranÃ§ois Panneton, Jean-Sebastien Parent-Chartier, Richard Simard, ClÃ©ment Teule, Pierre-Alexandre Tremblay, Jean Vaucher.</p>
<p>Its development has been supported by NSERC-Canada grant No. ODGP0110050, NATEQ-QuÃ©bec grant No. 02ER3218, a Killam fellowship, and a Canada Research Chair to the author. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
