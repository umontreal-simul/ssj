<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BatchMeansSim Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1simexp.html">simexp</a></li><li class="navelem"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html">BatchMeansSim</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BatchMeansSim Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Performs a simulation experiment on an infinite horizon, for estimating steady-state performance measures, using batch means.  
 <a href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for BatchMeansSim:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim__inherit__graph.svg" width="130" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BatchMeansSim:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim__coll__graph.svg" width="295" height="368"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13dbbb91fb87628d2f5934c1696ffa95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a13dbbb91fb87628d2f5934c1696ffa95">BatchMeansSim</a> (int minBatches, double batchSize, double warmupTime)</td></tr>
<tr class="memdesc:a13dbbb91fb87628d2f5934c1696ffa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new batch means simulator using at least <code>minBatches</code> batches with size <code>batchSize</code>, with a warmup period of duration <code>warmupTime</code>.  <a href="#a13dbbb91fb87628d2f5934c1696ffa95">More...</a><br /></td></tr>
<tr class="separator:a13dbbb91fb87628d2f5934c1696ffa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1917d0d3dc025a9e48fce1573129916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa1917d0d3dc025a9e48fce1573129916">BatchMeansSim</a> (int minBatches, int maxBatches, double batchSize, double warmupTime)</td></tr>
<tr class="memdesc:aa1917d0d3dc025a9e48fce1573129916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a batch means simulator with a maximum of <code>maxBatches</code> batches to avoid excessive memory usage and too long simulations when using sequential sampling.  <a href="#aa1917d0d3dc025a9e48fce1573129916">More...</a><br /></td></tr>
<tr class="separator:aa1917d0d3dc025a9e48fce1573129916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dee2486588125a2be15993f0ed48c54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0dee2486588125a2be15993f0ed48c54">BatchMeansSim</a> (<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a> sim, int minBatches, double batchSize, double warmupTime)</td></tr>
<tr class="memdesc:a0dee2486588125a2be15993f0ed48c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the first constructor, with a user-defined simulator <code>sim</code>.  <a href="#a0dee2486588125a2be15993f0ed48c54">More...</a><br /></td></tr>
<tr class="separator:a0dee2486588125a2be15993f0ed48c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5397b5aa8789680c58b2733f4d113263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a5397b5aa8789680c58b2733f4d113263">BatchMeansSim</a> (<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a> sim, int minBatches, int maxBatches, double batchSize, double warmupTime)</td></tr>
<tr class="memdesc:a5397b5aa8789680c58b2733f4d113263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the second constructor, with a user-defined simulator <code>sim</code>.  <a href="#a5397b5aa8789680c58b2733f4d113263">More...</a><br /></td></tr>
<tr class="separator:a5397b5aa8789680c58b2733f4d113263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5435458fd47402535d7748509a75f367"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a5435458fd47402535d7748509a75f367">getBatchAggregation</a> ()</td></tr>
<tr class="memdesc:a5435458fd47402535d7748509a75f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the aggregation of batches is turned ON.  <a href="#a5435458fd47402535d7748509a75f367">More...</a><br /></td></tr>
<tr class="separator:a5435458fd47402535d7748509a75f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21ab10c53d00d832f156afcf4b738f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ae21ab10c53d00d832f156afcf4b738f0">setBatchAggregation</a> (boolean a)</td></tr>
<tr class="memdesc:ae21ab10c53d00d832f156afcf4b738f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the batch aggregation indicator to <code>a</code>.  <a href="#ae21ab10c53d00d832f156afcf4b738f0">More...</a><br /></td></tr>
<tr class="separator:ae21ab10c53d00d832f156afcf4b738f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c048e823db19b5efa54d6798c49ab3"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad1c048e823db19b5efa54d6798c49ab3">getBatchLengthsKeeping</a> ()</td></tr>
<tr class="memdesc:ad1c048e823db19b5efa54d6798c49ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the length, in simulation time units, of each real batch has to be kept.  <a href="#ad1c048e823db19b5efa54d6798c49ab3">More...</a><br /></td></tr>
<tr class="separator:ad1c048e823db19b5efa54d6798c49ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2c8c676da02955f54b8d48409803f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a62e2c8c676da02955f54b8d48409803f">setBatchLengthsKeeping</a> (boolean b)</td></tr>
<tr class="memdesc:a62e2c8c676da02955f54b8d48409803f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the batch lengths keeping indicator to <code>b</code>.  <a href="#a62e2c8c676da02955f54b8d48409803f">More...</a><br /></td></tr>
<tr class="separator:a62e2c8c676da02955f54b8d48409803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87397860afd295bde86eb8a130c47eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ab87397860afd295bde86eb8a130c47eb">getMinBatches</a> ()</td></tr>
<tr class="memdesc:ab87397860afd295bde86eb8a130c47eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal number of batches required for estimating the steady-state performance measures of interest.  <a href="#ab87397860afd295bde86eb8a130c47eb">More...</a><br /></td></tr>
<tr class="separator:ab87397860afd295bde86eb8a130c47eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9747a25d301fe6d548aa997b0d2743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a5d9747a25d301fe6d548aa997b0d2743">setMinBatches</a> (int minBatches)</td></tr>
<tr class="memdesc:a5d9747a25d301fe6d548aa997b0d2743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimal number of batches to <code>minBatches</code>.  <a href="#a5d9747a25d301fe6d548aa997b0d2743">More...</a><br /></td></tr>
<tr class="separator:a5d9747a25d301fe6d548aa997b0d2743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaae6df6d841ad510e8f1e1d1c8ce61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#acbaae6df6d841ad510e8f1e1d1c8ce61">getMaxBatches</a> ()</td></tr>
<tr class="memdesc:acbaae6df6d841ad510e8f1e1d1c8ce61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(M\), the maximal number of batches to be used for estimating the steady-state performance measures of interest.  <a href="#acbaae6df6d841ad510e8f1e1d1c8ce61">More...</a><br /></td></tr>
<tr class="separator:acbaae6df6d841ad510e8f1e1d1c8ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5264bed93b78e8b0e933393a19455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a84f5264bed93b78e8b0e933393a19455">setMaxBatches</a> (int maxBatches)</td></tr>
<tr class="memdesc:a84f5264bed93b78e8b0e933393a19455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximal number of batches to <code>maxBatches</code>.  <a href="#a84f5264bed93b78e8b0e933393a19455">More...</a><br /></td></tr>
<tr class="separator:a84f5264bed93b78e8b0e933393a19455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363889276e14b29042c858598008fc1e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a363889276e14b29042c858598008fc1e">getBatchSize</a> ()</td></tr>
<tr class="memdesc:a363889276e14b29042c858598008fc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current batch size as defined for this simulator.  <a href="#a363889276e14b29042c858598008fc1e">More...</a><br /></td></tr>
<tr class="separator:a363889276e14b29042c858598008fc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e65b36451c83711407381ecb1d2fc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a6e65b36451c83711407381ecb1d2fc2f">setBatchSize</a> (double batchSize)</td></tr>
<tr class="memdesc:a6e65b36451c83711407381ecb1d2fc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the batch size to <code>batchSize</code>.  <a href="#a6e65b36451c83711407381ecb1d2fc2f">More...</a><br /></td></tr>
<tr class="separator:a6e65b36451c83711407381ecb1d2fc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fab66cb7896afc7d759c23a71e1d00"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad2fab66cb7896afc7d759c23a71e1d00">getWarmupTime</a> ()</td></tr>
<tr class="memdesc:ad2fab66cb7896afc7d759c23a71e1d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the duration of the warmup period for the simulation.  <a href="#ad2fab66cb7896afc7d759c23a71e1d00">More...</a><br /></td></tr>
<tr class="separator:ad2fab66cb7896afc7d759c23a71e1d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d77bfbc5fb9105bed002a843effd75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a1d77bfbc5fb9105bed002a843effd75d">setWarmupTime</a> (double warmupTime)</td></tr>
<tr class="memdesc:a1d77bfbc5fb9105bed002a843effd75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the warmup time to <code>warmupTime</code>.  <a href="#a1d77bfbc5fb9105bed002a843effd75d">More...</a><br /></td></tr>
<tr class="separator:a1d77bfbc5fb9105bed002a843effd75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84d4bb7e5ad71d88d8949098730b183"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad84d4bb7e5ad71d88d8949098730b183">getBatchFraction</a> ()</td></tr>
<tr class="memdesc:ad84d4bb7e5ad71d88d8949098730b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remaining fraction of batch to be simulated.  <a href="#ad84d4bb7e5ad71d88d8949098730b183">More...</a><br /></td></tr>
<tr class="separator:ad84d4bb7e5ad71d88d8949098730b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2cf9f5abdde261c01bd1f1efd368ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aba2cf9f5abdde261c01bd1f1efd368ca">getBatchSizeMultiplier</a> ()</td></tr>
<tr class="memdesc:aba2cf9f5abdde261c01bd1f1efd368ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the batch size multiplier after the simulation of a new batch.  <a href="#aba2cf9f5abdde261c01bd1f1efd368ca">More...</a><br /></td></tr>
<tr class="separator:aba2cf9f5abdde261c01bd1f1efd368ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed23232dfc6ff9cbeed2be646b8a2e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aeed23232dfc6ff9cbeed2be646b8a2e2">getTargetBatches</a> ()</td></tr>
<tr class="memdesc:aeed23232dfc6ff9cbeed2be646b8a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target number of simulated real batches at the next time the stopping condition is checked.  <a href="#aeed23232dfc6ff9cbeed2be646b8a2e2">More...</a><br /></td></tr>
<tr class="separator:aeed23232dfc6ff9cbeed2be646b8a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e079dcd25269f75a8ae8a90721d63b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a60e079dcd25269f75a8ae8a90721d63b">setTargetBatches</a> (int targetBatches)</td></tr>
<tr class="memdesc:a60e079dcd25269f75a8ae8a90721d63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target number of simulated batches before an error check or the end of the simulation to <code>targetBatches</code>.  <a href="#a60e079dcd25269f75a8ae8a90721d63b">More...</a><br /></td></tr>
<tr class="separator:a60e079dcd25269f75a8ae8a90721d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c88ff2d5d1c950f26529ffdaabb896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a15c88ff2d5d1c950f26529ffdaabb896">getCompletedRealBatches</a> ()</td></tr>
<tr class="memdesc:a15c88ff2d5d1c950f26529ffdaabb896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of completed real batches since the beginning of the run.  <a href="#a15c88ff2d5d1c950f26529ffdaabb896">More...</a><br /></td></tr>
<tr class="separator:a15c88ff2d5d1c950f26529ffdaabb896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb47c2fa081e9eada5e0441726235fd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#adb47c2fa081e9eada5e0441726235fd0">getDroppedRealBatches</a> ()</td></tr>
<tr class="memdesc:adb47c2fa081e9eada5e0441726235fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of real batches dropped.  <a href="#adb47c2fa081e9eada5e0441726235fd0">More...</a><br /></td></tr>
<tr class="separator:adb47c2fa081e9eada5e0441726235fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21cd7bacd0e04da32417b729f51f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aae21cd7bacd0e04da32417b729f51f8a">dropFirstRealBatches</a> (int n)</td></tr>
<tr class="memdesc:aae21cd7bacd0e04da32417b729f51f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the <code>n</code> first real batches to save memory.  <a href="#aae21cd7bacd0e04da32417b729f51f8a">More...</a><br /></td></tr>
<tr class="separator:aae21cd7bacd0e04da32417b729f51f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f430995e3782e7f76456a38e976983"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a36f430995e3782e7f76456a38e976983">getBatch</a> (double time)</td></tr>
<tr class="memdesc:a36f430995e3782e7f76456a38e976983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real batch corresponding to simulation time <code>time</code> when batch lengths are kept.  <a href="#a36f430995e3782e7f76456a38e976983">More...</a><br /></td></tr>
<tr class="separator:a36f430995e3782e7f76456a38e976983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b78fcb9baa60ee562f2ce143c050c7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ab0b78fcb9baa60ee562f2ce143c050c7">isWarmupDone</a> ()</td></tr>
<tr class="memdesc:ab0b78fcb9baa60ee562f2ce143c050c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the warmup period for the simulation is over.  <a href="#ab0b78fcb9baa60ee562f2ce143c050c7">More...</a><br /></td></tr>
<tr class="separator:ab0b78fcb9baa60ee562f2ce143c050c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a844710506e6649c63de998cab3fcbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0a844710506e6649c63de998cab3fcbb">getNumAggregates</a> ()</td></tr>
<tr class="memdesc:a0a844710506e6649c63de998cab3fcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(h\), the number of real batches contained into an effective batch.  <a href="#a0a844710506e6649c63de998cab3fcbb">More...</a><br /></td></tr>
<tr class="separator:a0a844710506e6649c63de998cab3fcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81049c79c88edf35834a0aebe7d6cd1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a81049c79c88edf35834a0aebe7d6cd1c">getRealBatchLength</a> (int batch)</td></tr>
<tr class="memdesc:a81049c79c88edf35834a0aebe7d6cd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length, in simulation time units, of the real batch <code>batch</code>.  <a href="#a81049c79c88edf35834a0aebe7d6cd1c">More...</a><br /></td></tr>
<tr class="separator:a81049c79c88edf35834a0aebe7d6cd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b238fd6b48d30a8a4e9a4473534005"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a87b238fd6b48d30a8a4e9a4473534005">getRealBatchStartingTime</a> (int batch)</td></tr>
<tr class="memdesc:a87b238fd6b48d30a8a4e9a4473534005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting simulation time of batch <code>batch</code>.  <a href="#a87b238fd6b48d30a8a4e9a4473534005">More...</a><br /></td></tr>
<tr class="separator:a87b238fd6b48d30a8a4e9a4473534005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceeddff4fad32a9250915d412e0b3e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aaceeddff4fad32a9250915d412e0b3e5">getRealBatchEndingTime</a> (int batch)</td></tr>
<tr class="memdesc:aaceeddff4fad32a9250915d412e0b3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ending simulation time of batch <code>batch</code>.  <a href="#aaceeddff4fad32a9250915d412e0b3e5">More...</a><br /></td></tr>
<tr class="separator:aaceeddff4fad32a9250915d412e0b3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e2a20f8e69eca5f8189e8ccf5ffc40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa7e2a20f8e69eca5f8189e8ccf5ffc40">allocateCapacity</a> (int capacity)</td></tr>
<tr class="memdesc:aa7e2a20f8e69eca5f8189e8ccf5ffc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the necessary memory for storing <code>capacity</code> real batches.  <a href="#aa7e2a20f8e69eca5f8189e8ccf5ffc40">More...</a><br /></td></tr>
<tr class="separator:aa7e2a20f8e69eca5f8189e8ccf5ffc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70998c7df9a6d31ee33c17e66421bf0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b">regroupRealBatches</a> (int x)</td></tr>
<tr class="memdesc:a70998c7df9a6d31ee33c17e66421bf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regroups real batches <code>x</code> by <code>x</code>.  <a href="#a70998c7df9a6d31ee33c17e66421bf0b">More...</a><br /></td></tr>
<tr class="separator:a70998c7df9a6d31ee33c17e66421bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e62dd2ef8965d2a6d44076d9cd041c"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a76e62dd2ef8965d2a6d44076d9cd041c">initSimulation</a> ()</td></tr>
<tr class="memdesc:a76e62dd2ef8965d2a6d44076d9cd041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the simulator for a new run.  <a href="#a76e62dd2ef8965d2a6d44076d9cd041c">More...</a><br /></td></tr>
<tr class="separator:a76e62dd2ef8965d2a6d44076d9cd041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1683dda525d4b417022cd5852c9571"><td class="memItemLeft" align="right" valign="top"><a id="a9a1683dda525d4b417022cd5852c9571"></a>
abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9a1683dda525d4b417022cd5852c9571">initBatchStat</a> ()</td></tr>
<tr class="memdesc:a9a1683dda525d4b417022cd5852c9571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the counters used for computing observations during the simulation at the beginning of a new batch. <br /></td></tr>
<tr class="separator:a9a1683dda525d4b417022cd5852c9571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9614ccd1eb8c65c521b4f8565ba0d761"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9614ccd1eb8c65c521b4f8565ba0d761">initRealBatchProbes</a> ()</td></tr>
<tr class="memdesc:a9614ccd1eb8c65c521b4f8565ba0d761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes any statistical collector for real batches.  <a href="#a9614ccd1eb8c65c521b4f8565ba0d761">More...</a><br /></td></tr>
<tr class="separator:a9614ccd1eb8c65c521b4f8565ba0d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3843064274dc3a525fc23ff623a0c3"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0b3843064274dc3a525fc23ff623a0c3">initEffectiveBatchProbes</a> ()</td></tr>
<tr class="memdesc:a0b3843064274dc3a525fc23ff623a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes any statistical collector for effective batches.  <a href="#a0b3843064274dc3a525fc23ff623a0c3">More...</a><br /></td></tr>
<tr class="separator:a0b3843064274dc3a525fc23ff623a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d5a31527ab24aba6c6c5ff9acb4771"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa5d5a31527ab24aba6c6c5ff9acb4771">addRealBatchObs</a> ()</td></tr>
<tr class="memdesc:aa5d5a31527ab24aba6c6c5ff9acb4771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects values of a \(\mathbf{V}_j\) vector concerning the last simulated real batch.  <a href="#aa5d5a31527ab24aba6c6c5ff9acb4771">More...</a><br /></td></tr>
<tr class="separator:aa5d5a31527ab24aba6c6c5ff9acb4771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2e52c400d0e3a5289a2a26f982c26d"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d">addEffectiveBatchObs</a> (int s, int h, double l)</td></tr>
<tr class="memdesc:a2d2e52c400d0e3a5289a2a26f982c26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an observation to each statistical collector corresponding to an effective batch.  <a href="#a2d2e52c400d0e3a5289a2a26f982c26d">More...</a><br /></td></tr>
<tr class="separator:a2d2e52c400d0e3a5289a2a26f982c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aa162984f84cd54d9e3583806cb0a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a90aa162984f84cd54d9e3583806cb0a0">getRequiredNewBatches</a> ()</td></tr>
<tr class="memdesc:a90aa162984f84cd54d9e3583806cb0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the approximate number of required real batches to be simulated before the simulation can be stopped.  <a href="#a90aa162984f84cd54d9e3583806cb0a0">More...</a><br /></td></tr>
<tr class="separator:a90aa162984f84cd54d9e3583806cb0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the simulator for a new experiment.  <a href="#a02fd73d861ef2e4aabb38c0c9ff82947">More...</a><br /></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224163518f6e04b749954f2939adcbc3"><td class="memItemLeft" align="right" valign="top"><a id="a224163518f6e04b749954f2939adcbc3"></a>
<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html">Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a224163518f6e04b749954f2939adcbc3">getEndSimEvent</a> ()</td></tr>
<tr class="memdesc:a224163518f6e04b749954f2939adcbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the event used to stop the simulation at the end of the warmup or batches. <br /></td></tr>
<tr class="separator:a224163518f6e04b749954f2939adcbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101bbfc4b8397b53f3b2709c529c8e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a101bbfc4b8397b53f3b2709c529c8e56">warmup</a> ()</td></tr>
<tr class="memdesc:a101bbfc4b8397b53f3b2709c529c8e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a warmup by calling <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a" title="Performs a warmup of fixed duration warmupTime. ">warmup(double)</a>.  <a href="#a101bbfc4b8397b53f3b2709c529c8e56">More...</a><br /></td></tr>
<tr class="separator:a101bbfc4b8397b53f3b2709c529c8e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3566e6a144f79b6980f82efb0452bb8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a">warmup</a> (double warmupTime)</td></tr>
<tr class="memdesc:a3566e6a144f79b6980f82efb0452bb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a warmup of fixed duration <code>warmupTime</code>.  <a href="#a3566e6a144f79b6980f82efb0452bb8a">More...</a><br /></td></tr>
<tr class="separator:a3566e6a144f79b6980f82efb0452bb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e7007c56dfc77e16efba953d9422a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af02e7007c56dfc77e16efba953d9422a">simulateBatch</a> ()</td></tr>
<tr class="memdesc:af02e7007c56dfc77e16efba953d9422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate a new batch with default length.  <a href="#af02e7007c56dfc77e16efba953d9422a">More...</a><br /></td></tr>
<tr class="separator:af02e7007c56dfc77e16efba953d9422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af661c09717d11da5af2bd829e09878c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af661c09717d11da5af2bd829e09878c1">simulateBatch</a> (double batchLength)</td></tr>
<tr class="memdesc:af661c09717d11da5af2bd829e09878c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a batch with length <code>batchLength</code>.  <a href="#af661c09717d11da5af2bd829e09878c1">More...</a><br /></td></tr>
<tr class="separator:af661c09717d11da5af2bd829e09878c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec9d986ecf4ef3aa6631842df712132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9ec9d986ecf4ef3aa6631842df712132">adjustTargetBatches</a> (int numNewBatches)</td></tr>
<tr class="memdesc:a9ec9d986ecf4ef3aa6631842df712132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the target number of real batches to simulate <code>numNewBatches</code> additionnal real batches.  <a href="#a9ec9d986ecf4ef3aa6631842df712132">More...</a><br /></td></tr>
<tr class="separator:a9ec9d986ecf4ef3aa6631842df712132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7311be0dc09066e277a34d3f353d4d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a7311be0dc09066e277a34d3f353d4d63">simulateBatches</a> ()</td></tr>
<tr class="memdesc:a7311be0dc09066e277a34d3f353d4d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates batches until the number of completed real batches corresponds to the target number of batches.  <a href="#a7311be0dc09066e277a34d3f353d4d63">More...</a><br /></td></tr>
<tr class="separator:a7311be0dc09066e277a34d3f353d4d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f451daf160cbacfab1e7b495789750e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a1f451daf160cbacfab1e7b495789750e">simulate</a> ()</td></tr>
<tr class="memdesc:a1f451daf160cbacfab1e7b495789750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a batch means simulation.  <a href="#a1f451daf160cbacfab1e7b495789750e">More...</a><br /></td></tr>
<tr class="separator:a1f451daf160cbacfab1e7b495789750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad146fa8579a5f8a876c4688cc5a68520"><td class="memItemLeft" align="right" valign="top"><a id="ad146fa8579a5f8a876c4688cc5a68520"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> ()</td></tr>
<tr class="separator:ad146fa8579a5f8a876c4688cc5a68520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html">SimExp</a></td></tr>
<tr class="memitem:a19f81ca8edffc892efcfaa00ee1ca1f7 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">final <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7">simulator</a> ()</td></tr>
<tr class="memdesc:a19f81ca8edffc892efcfaa00ee1ca1f7 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the simulator linked to this experiment object.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7">More...</a><br /></td></tr>
<tr class="separator:a19f81ca8edffc892efcfaa00ee1ca1f7 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756e79c8e16904d69486cbcc435e2204 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">final void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a756e79c8e16904d69486cbcc435e2204">setSimulator</a> (<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a> sim)</td></tr>
<tr class="memdesc:a756e79c8e16904d69486cbcc435e2204 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the simulator associated with this experiment to <code>sim</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a756e79c8e16904d69486cbcc435e2204">More...</a><br /></td></tr>
<tr class="separator:a756e79c8e16904d69486cbcc435e2204 inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3ca8d0cac1e9271c959d5bf3be74a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#afbc3ca8d0cac1e9271c959d5bf3be74a">isSimulating</a> ()</td></tr>
<tr class="memdesc:afbc3ca8d0cac1e9271c959d5bf3be74a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the simulation is in progress.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#afbc3ca8d0cac1e9271c959d5bf3be74a">More...</a><br /></td></tr>
<tr class="separator:afbc3ca8d0cac1e9271c959d5bf3be74a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c96b2dcd16fa80db7ddb583ff67b8a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a31c96b2dcd16fa80db7ddb583ff67b8a">simulate</a> ()</td></tr>
<tr class="memdesc:a31c96b2dcd16fa80db7ddb583ff67b8a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an experiment whose logic depends on the used subclass.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a31c96b2dcd16fa80db7ddb583ff67b8a">More...</a><br /></td></tr>
<tr class="separator:a31c96b2dcd16fa80db7ddb583ff67b8a inherit pub_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a12d5ecfe28b2ae6a52f34b350c50cc74"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a12d5ecfe28b2ae6a52f34b350c50cc74">getSum</a> (double[] a, int start, int length)</td></tr>
<tr class="memdesc:a12d5ecfe28b2ae6a52f34b350c50cc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the array <code>a</code>.  <a href="#a12d5ecfe28b2ae6a52f34b350c50cc74">More...</a><br /></td></tr>
<tr class="separator:a12d5ecfe28b2ae6a52f34b350c50cc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951f079ad09b1efb63620678d73c98c5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a951f079ad09b1efb63620678d73c98c5">getSum</a> (DoubleArrayList l, int start, int length)</td></tr>
<tr class="memdesc:a951f079ad09b1efb63620678d73c98c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the array list <code>l</code>.  <a href="#a951f079ad09b1efb63620678d73c98c5">More...</a><br /></td></tr>
<tr class="separator:a951f079ad09b1efb63620678d73c98c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ca3fa66b4b029c96831b5a4d1145e6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa4ca3fa66b4b029c96831b5a4d1145e6">getSum</a> (DoubleMatrix1D m, int start, int length)</td></tr>
<tr class="memdesc:aa4ca3fa66b4b029c96831b5a4d1145e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the 1D matrix <code>m</code>.  <a href="#aa4ca3fa66b4b029c96831b5a4d1145e6">More...</a><br /></td></tr>
<tr class="separator:aa4ca3fa66b4b029c96831b5a4d1145e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214bae033f54d441185f0ecb43da1969"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a214bae033f54d441185f0ecb43da1969">getSum</a> (double[][] a, int startColumn, int numColumns)</td></tr>
<tr class="memdesc:a214bae033f54d441185f0ecb43da1969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array containing the sum of columns <code>startColumn</code>, …, <code>startColumn + numColumns - 1</code>, in the 2D matrix represented by the 2D array <code>a</code>.  <a href="#a214bae033f54d441185f0ecb43da1969">More...</a><br /></td></tr>
<tr class="separator:a214bae033f54d441185f0ecb43da1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad894c2cd577a1bc907327e278d61d445"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad894c2cd577a1bc907327e278d61d445">getSum</a> (DoubleMatrix2D m, int startColumn, int numColumns)</td></tr>
<tr class="memdesc:ad894c2cd577a1bc907327e278d61d445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array containing the sum of columns <code>startColumn</code>, …, <code>startColumn + numColumns - 1</code>, in the 2D matrix <code>m</code>.  <a href="#ad894c2cd577a1bc907327e278d61d445">More...</a><br /></td></tr>
<tr class="separator:ad894c2cd577a1bc907327e278d61d445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6271b96a244ad5ca6df80a445c1ed279"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a6271b96a244ad5ca6df80a445c1ed279">regroupElements</a> (double[] a, int x)</td></tr>
<tr class="memdesc:a6271b96a244ad5ca6df80a445c1ed279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regroups the elements in array <code>a</code> by summing each successive <code>x</code> values.  <a href="#a6271b96a244ad5ca6df80a445c1ed279">More...</a><br /></td></tr>
<tr class="separator:a6271b96a244ad5ca6df80a445c1ed279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94934c943435ba6bf46b977eb9404366"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a94934c943435ba6bf46b977eb9404366">regroupElements</a> (DoubleArrayList l, int x)</td></tr>
<tr class="memdesc:a94934c943435ba6bf46b977eb9404366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as #regroupElements(double[],int) for an array list.  <a href="#a94934c943435ba6bf46b977eb9404366">More...</a><br /></td></tr>
<tr class="separator:a94934c943435ba6bf46b977eb9404366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b21e697d197819e5f656978552389e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa0b21e697d197819e5f656978552389e">regroupElements</a> (DoubleMatrix1D mat, int x)</td></tr>
<tr class="memdesc:aa0b21e697d197819e5f656978552389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as #regroupElements(double[],int) for a 1D matrix.  <a href="#aa0b21e697d197819e5f656978552389e">More...</a><br /></td></tr>
<tr class="separator:aa0b21e697d197819e5f656978552389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6ec3388a2eaf02af18ad5f66ba6ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a6df6ec3388a2eaf02af18ad5f66ba6ff">regroupElements</a> (DoubleMatrix2D mat, int x)</td></tr>
<tr class="memdesc:a6df6ec3388a2eaf02af18ad5f66ba6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as #regroupElements(double[],int) for a 2D matrix.  <a href="#a6df6ec3388a2eaf02af18ad5f66ba6ff">More...</a><br /></td></tr>
<tr class="separator:a6df6ec3388a2eaf02af18ad5f66ba6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html">SimExp</a></td></tr>
<tr class="memitem:a2f22d0a2a636dae6fb827604ac1595c5 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a2f22d0a2a636dae6fb827604ac1595c5">getRequiredNewObservations</a> (<a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">StatProbe</a>[] a, double targetError, double level)</td></tr>
<tr class="memdesc:a2f22d0a2a636dae6fb827604ac1595c5 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate number of additional observations required to reach a relative error smaller than or equal to <code>targetError</code> for each tally in the array <code>a</code> when confidence intervals are computed with confidence level <code>level</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a2f22d0a2a636dae6fb827604ac1595c5">More...</a><br /></td></tr>
<tr class="separator:a2f22d0a2a636dae6fb827604ac1595c5 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f4c79df121202e5d0f2b0241577f46 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a00f4c79df121202e5d0f2b0241577f46">getRequiredNewObservations</a> (Iterable&lt;? extends <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">StatProbe</a> &gt; it, double targetError, double level)</td></tr>
<tr class="memdesc:a00f4c79df121202e5d0f2b0241577f46 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate number of additional observations required to reach a relative error smaller than or equal to <code>targetError</code> for each tally enumerated by <code>it</code> when confidence intervals are computed with confidence level <code>level</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a00f4c79df121202e5d0f2b0241577f46">More...</a><br /></td></tr>
<tr class="separator:a00f4c79df121202e5d0f2b0241577f46 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1550b2c10c15fecd0812021842ee78b inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#ae1550b2c10c15fecd0812021842ee78b">getRequiredNewObservations</a> (<a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">StatProbe</a> probe, double targetError, double level)</td></tr>
<tr class="memdesc:ae1550b2c10c15fecd0812021842ee78b inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a0864fc5bc415a4de5e9a919a617afae2" title="Returns the approximate number of additional observations needed for the point estimator &#160;center...">getRequiredNewObservations(double,double,int,double)</a> with the average, confidence interval radius, and number of observations given by the statistical probe <code>probe</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#ae1550b2c10c15fecd0812021842ee78b">More...</a><br /></td></tr>
<tr class="separator:ae1550b2c10c15fecd0812021842ee78b inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6d1c8376dc726381cb1a8dc3a86713 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#ada6d1c8376dc726381cb1a8dc3a86713">getRequiredNewObservationsTally</a> (<a class="el" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a> ta, double targetError, double level)</td></tr>
<tr class="memdesc:ada6d1c8376dc726381cb1a8dc3a86713 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a0864fc5bc415a4de5e9a919a617afae2" title="Returns the approximate number of additional observations needed for the point estimator &#160;center...">getRequiredNewObservations(double,double,int,double)</a> with the average, confidence interval radius, and number of observations given by the tally <code>ta</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#ada6d1c8376dc726381cb1a8dc3a86713">More...</a><br /></td></tr>
<tr class="separator:ada6d1c8376dc726381cb1a8dc3a86713 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27415e9ebb1592178c107f3c01ac4225 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a27415e9ebb1592178c107f3c01ac4225">getRequiredNewObservationsTally</a> (<a class="el" href="classumontreal_1_1ssj_1_1stat_1_1FunctionOfMultipleMeansTally.html">FunctionOfMultipleMeansTally</a> fmmt, double targetError, double level)</td></tr>
<tr class="memdesc:a27415e9ebb1592178c107f3c01ac4225 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a0864fc5bc415a4de5e9a919a617afae2" title="Returns the approximate number of additional observations needed for the point estimator &#160;center...">getRequiredNewObservations(double,double,int,double)</a> with the average, confidence interval radius, and number of observations given by the function of multiple means <code>fmmt</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a27415e9ebb1592178c107f3c01ac4225">More...</a><br /></td></tr>
<tr class="separator:a27415e9ebb1592178c107f3c01ac4225 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864fc5bc415a4de5e9a919a617afae2 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a0864fc5bc415a4de5e9a919a617afae2">getRequiredNewObservations</a> (double center, double radius, int numberObs, double targetError)</td></tr>
<tr class="memdesc:a0864fc5bc415a4de5e9a919a617afae2 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate number of additional observations needed for the point estimator \(\bar{X}_n=\)&#160;<code>center</code>, computed using \(n=\)&#160;<code>numberObs</code> observations and with a confidence interval having radius \(\delta_n/\sqrt{n}=\)&#160;<code>radius</code>, to have a relative error less than or equal to \(\epsilon=\)&#160;<code>targetError</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a0864fc5bc415a4de5e9a919a617afae2">More...</a><br /></td></tr>
<tr class="separator:a0864fc5bc415a4de5e9a919a617afae2 inherit pub_static_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html">SimExp</a></td></tr>
<tr class="memitem:afe41ca744e9f3b3faf3bad9f83c53c47 inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top"><a id="afe41ca744e9f3b3faf3bad9f83c53c47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#afe41ca744e9f3b3faf3bad9f83c53c47">SimExp</a> ()</td></tr>
<tr class="memdesc:afe41ca744e9f3b3faf3bad9f83c53c47 inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new object for performing experiments using the default simulator returned by <code><a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html#abf16d2e0d67ec11895169b66f17b71d8" title="Returns the default simulator instance used by the deprecated class Sim. ">Simulator.getDefaultSimulator()</a></code>. <br /></td></tr>
<tr class="separator:afe41ca744e9f3b3faf3bad9f83c53c47 inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e22b6bbd5827f14bae58fc06faf81c inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a51e22b6bbd5827f14bae58fc06faf81c">SimExp</a> (<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a> sim)</td></tr>
<tr class="memdesc:a51e22b6bbd5827f14bae58fc06faf81c inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new object performing experiments using the given simulator <code>sim</code>.  <a href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a51e22b6bbd5827f14bae58fc06faf81c">More...</a><br /></td></tr>
<tr class="separator:a51e22b6bbd5827f14bae58fc06faf81c inherit pro_methods_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html">SimExp</a></td></tr>
<tr class="memitem:a5ba7b96391aa0fa02fd2895b66bf309d inherit pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top"><a id="a5ba7b96391aa0fa02fd2895b66bf309d"></a>
<a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sim</b></td></tr>
<tr class="separator:a5ba7b96391aa0fa02fd2895b66bf309d inherit pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9196adf8cc3219993f7f39462f6e9238 inherit pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memItemLeft" align="right" valign="top"><a id="a9196adf8cc3219993f7f39462f6e9238"></a>
boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a9196adf8cc3219993f7f39462f6e9238">simulating</a> = false</td></tr>
<tr class="memdesc:a9196adf8cc3219993f7f39462f6e9238 inherit pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the simulation is in progress. <br /></td></tr>
<tr class="separator:a9196adf8cc3219993f7f39462f6e9238 inherit pro_attribs_classumontreal_1_1ssj_1_1simexp_1_1SimExp"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Performs a simulation experiment on an infinite horizon, for estimating steady-state performance measures, using batch means. </p>
<p>Batches are delimited using a user-specified condition such as a fixed duration in simulation time units (the default), the number of occurrences of an event such as the arrival of a customer, a regenerative cycle, etc. After the condition for batch termination is defined, the <em>batch size</em> can be set. This size can be, depending on how batches are delimited, a time duration, a number of events, or 1 for regenerative cycles. The <em>batch length</em> is defined to be the duration of a batch, in simulation time units, independently of how batches are defined. By default, the batch size and the batch length are equivalent (and constant), but they may differ if the condition for batch termination is changed.</p>
<p>A warmup period is usually simulated to reduce the bias induced by the initial state of the system. During the warmup, the system runs without any observation being collected. By default, this period has a duration fixed in simulation time units, but this can also be changed.</p>
<p>After the warmup is over, events are counted as follows. The simulation model defines some counters being updated when events occur and reset at the beginning of each batch. At the end of a batch, the value of these counters are used to generate a random vector \(\mathbf{V}_j\) before the counters are reset. Alternatively, a simulation may compute and update the \(\mathbf{V}_j\)’s directly, without using intermediate counters. A set of data structures is needed to collect and store these \(\mathbf{V}_j\)’s, the simplest option being a set of <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1TallyStore.html">umontreal.ssj.stat.TallyStore</a> instances. This generates values for \(m\) <em>real batches</em>. The sample \((\mathbf{X}_0,…,\mathbf{X}_{n-1})\) is then obtained from \((\mathbf{V}_0,…,\mathbf{V}_{m-1})\), so a second set of data structures is needed to collect the \(\mathbf{X}_r\)’s, the simplest being a set of <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">umontreal.ssj.stat.Tally</a> instances. The most straightforward way to estimate covariances on components of \(\mathbf{X}_r\) is by considering the vectors \(\mathbf{X}_r\) i.i.d., which is not true in general. However, by choosing a sufficiently large simulation time and batch lengths, the correlation between batches can be reduced, and the \(\mathbf{X}_r\)’s are approximately i.i.d. and normally distributed. If batches correspond to regenerative cycles, the \(\mathbf{X}_r\) are then truly i.i.d., but only approximately normally distributed. Confidence intervals on functions of \(\boldsymbol{\mu}\) can be approximated using the central limit theorem, as with independent replications, or using the delta theorem for functions of multiple means or when batches have different lengths.</p>
<p>The sample size corresponding to the number of simulated batches is always fixed when sequential sampling is not used; we have \(n=m\) and \(\mathbf{X}_r=\mathbf{V}_r\) for \(r=0,…,n-1\). However, when sequential sampling is used, the sample size can be random or fixed. If the sample size is random, we still have \(\mathbf{X}_r=\mathbf{V}_r\). When using this mode, the batch size must be chosen carefully to reduce correlation between batches.</p>
<p>On the other hand, if the sample size \(n\) is required to be fixed while sequential sampling is used, <em>batch aggregation</em> must be activated to have <em>effective batches</em> with random lengths. When aggregation is enabled, real batches are simulated as usual, but the obtained values \(\mathbf{V}_j\) are regrouped (or aggregated) to form effective batches. The number of real batches must be \(m=h*n\) to get a sample of size \(n\), and \(h\) can be any integer greater than or equal to 1. In this case, </p><p class="formulaDsp">
\[ \mathbf{X}_r=\sum_{k=0}^{h-1} \mathbf{V}_{hr+k}. \]
</p>
<p> The size of the effective batches increases while the sample size remains fixed because the group size \(h\) increases with simulation length. When aggregation is used, the effective batches become longer while simulation time increases, and the correlation between effective batches should decrease with simulation time. However, the increment to the target number of batches must always be a multiple of the sample size, which can lead to useless simulation if the sample size is large.</p>
<p>This class must be extended to implement a batch means simulator, and the appropriate methods must be defined or overridden. This class uses a simulation event to stop the simulation at the end of the warmup period and batches. One can use this event for fixed-duration warmup and batches, or schedule their own events which call <code>Sim.stop</code> to end warmup or batches. To change how the warmup period is terminated, one must override the method <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a101bbfc4b8397b53f3b2709c529c8e56" title="Performs a warmup by calling warmup(double). ">warmup</a>. For the batch termination condition to be redefined, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af02e7007c56dfc77e16efba953d9422a" title="Simulate a new batch with default length. ">simulateBatch</a> must be overridden.</p>
<p>One must implement <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a76e62dd2ef8965d2a6d44076d9cd041c" title="Initializes the simulator for a new run. ">initSimulation</a> to initialize the simulated model before the warmup, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9a1683dda525d4b417022cd5852c9571" title="Resets the counters used for computing observations during the simulation at the beginning of a new b...">initBatchStat</a> to reset the model-specific counters used to compute the \(\mathbf{V}_j\)’s, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9614ccd1eb8c65c521b4f8565ba0d761" title="Initializes any statistical collector for real batches. ">initRealBatchProbes</a> and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa5d5a31527ab24aba6c6c5ff9acb4771" title="Collects values of a  vector concerning the last simulated real batch. ">addRealBatchObs</a> to initialize statistical probes and add observations for real batches, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0b3843064274dc3a525fc23ff623a0c3" title="Initializes any statistical collector for effective batches. ">initEffectiveBatchProbes</a> and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs(int,int,double)</a> to initialize statistical probes and add observations for effective batches.</p>
<p>The moment the latter methods are called depends on the status of batch aggregation: when aggregation is turned ON, before any error check or the end of the simulation, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0b3843064274dc3a525fc23ff623a0c3" title="Initializes any statistical collector for effective batches. ">initEffectiveBatchProbes</a> is called once before <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs(int,int,double)</a> is called \(n\) successive times, with different parameters. When aggregation is turned OFF, then method <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0b3843064274dc3a525fc23ff623a0c3" title="Initializes any statistical collector for effective batches. ">initEffectiveBatchProbes</a> is called after the warmup is over, and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs(int,int,double)</a> is called each time a batch ends, after <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa5d5a31527ab24aba6c6c5ff9acb4771" title="Collects values of a  vector concerning the last simulated real batch. ">addRealBatchObs</a> is called.</p>
<p>If sequential sampling is used, <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a90aa162984f84cd54d9e3583806cb0a0" title="Computes the approximate number of required real batches to be simulated before the simulation can be...">getRequiredNewBatches</a> must be overridden to implement error checking. In some particular situations, the user may also need to override <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa7e2a20f8e69eca5f8189e8ccf5ffc40" title="Allocates the necessary memory for storing capacity real batches. ">allocateCapacity(int)</a> and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches(int)</a>.</p>
<div class="SSJ-bigskip"></div> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a13dbbb91fb87628d2f5934c1696ffa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dbbb91fb87628d2f5934c1696ffa95">&#9670;&nbsp;</a></span>BatchMeansSim() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html">BatchMeansSim</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new batch means simulator using at least <code>minBatches</code> batches with size <code>batchSize</code>, with a warmup period of duration <code>warmupTime</code>. </p>
<p>By default, batch aggregation and batch lengths keeping are turned off, and the maximal number of batches is infinite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minBatches</td><td>the minimal number of batches to simulate. </td></tr>
    <tr><td class="paramname">batchSize</td><td>the size of the batches. </td></tr>
    <tr><td class="paramname">warmupTime</td><td>the duration of the warmup period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the minimal number of batches is smaller than or equal to 0, or if the warmup time is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1917d0d3dc025a9e48fce1573129916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1917d0d3dc025a9e48fce1573129916">&#9670;&nbsp;</a></span>BatchMeansSim() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html">BatchMeansSim</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a batch means simulator with a maximum of <code>maxBatches</code> batches to avoid excessive memory usage and too long simulations when using sequential sampling. </p>
<p>See <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a13dbbb91fb87628d2f5934c1696ffa95" title="Constructs a new batch means simulator using at least minBatches batches with size batchSize...">BatchMeansSim(int,double,double)</a> for more information about the other parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minBatches</td><td>the minimal number of batches to simulate. </td></tr>
    <tr><td class="paramname">maxBatches</td><td>the maximal number of batches to simulate. </td></tr>
    <tr><td class="paramname">batchSize</td><td>the size of the batches. </td></tr>
    <tr><td class="paramname">warmupTime</td><td>the duration of the warmup period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the minimal number of batches is smaller than or equal to 0, or if the warmup time is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dee2486588125a2be15993f0ed48c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dee2486588125a2be15993f0ed48c54">&#9670;&nbsp;</a></span>BatchMeansSim() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html">BatchMeansSim</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a>&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the first constructor, with a user-defined simulator <code>sim</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim</td><td>the simulator attached to this object. </td></tr>
    <tr><td class="paramname">minBatches</td><td>the minimal number of batches to simulate. </td></tr>
    <tr><td class="paramname">batchSize</td><td>the size of the batches. </td></tr>
    <tr><td class="paramname">warmupTime</td><td>the duration of the warmup period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the minimal number of batches is smaller than or equal to 0, or if the warmup time is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5397b5aa8789680c58b2733f4d113263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5397b5aa8789680c58b2733f4d113263">&#9670;&nbsp;</a></span>BatchMeansSim() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html">BatchMeansSim</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">Simulator</a>&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the second constructor, with a user-defined simulator <code>sim</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim</td><td>the simulator attached to this object. </td></tr>
    <tr><td class="paramname">minBatches</td><td>the minimal number of batches to simulate. </td></tr>
    <tr><td class="paramname">maxBatches</td><td>the maximal number of batches to simulate. </td></tr>
    <tr><td class="paramname">batchSize</td><td>the size of the batches. </td></tr>
    <tr><td class="paramname">warmupTime</td><td>the duration of the warmup period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the minimal number of batches is smaller than or equal to 0, or if the warmup time is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2d2e52c400d0e3a5289a2a26f982c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2e52c400d0e3a5289a2a26f982c26d">&#9670;&nbsp;</a></span>addEffectiveBatchObs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void addEffectiveBatchObs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an observation to each statistical collector corresponding to an effective batch. </p>
<p>The effective batch for which this method is called has length <code>l</code>, and regroups real batches <code>s</code>, …, <code>s + h - 1</code>. This method is called after each error check if aggregation is turned ON, or after each real batch if it is turned OFF. </p>

</div>
</div>
<a id="aa5d5a31527ab24aba6c6c5ff9acb4771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d5a31527ab24aba6c6c5ff9acb4771">&#9670;&nbsp;</a></span>addRealBatchObs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void addRealBatchObs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects values of a \(\mathbf{V}_j\) vector concerning the last simulated real batch. </p>
<p>This method is called at the end of each real batch. </p>

</div>
</div>
<a id="a9ec9d986ecf4ef3aa6631842df712132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec9d986ecf4ef3aa6631842df712132">&#9670;&nbsp;</a></span>adjustTargetBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adjustTargetBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numNewBatches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the target number of real batches to simulate <code>numNewBatches</code> additionnal real batches. </p>
<p>This method clamps the target number of real batches to the maximal number of batches, and ensures that the target number of batches is a multiple of the minimal number of batches when aggregation is turned ON. </p>

</div>
</div>
<a id="aa7e2a20f8e69eca5f8189e8ccf5ffc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e2a20f8e69eca5f8189e8ccf5ffc40">&#9670;&nbsp;</a></span>allocateCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocateCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the necessary memory for storing <code>capacity</code> real batches. </p>
<p>When using sequential sampling, if the variance of estimators is high, many additional batches may be needed to reach the target precision. To avoid memory problems after a long simulation time, this method can preallocate the necessary memory. The method must ensure that the data structures used to store the \(\mathbf{V}_j\)’s can contain <code>capacity</code> real batches. This is done by recreating arrays or resizing data structures. By default, this method throws an UnsupportedOperationException. <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches</a> must be implemented if this method does not throw this exception. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>the number of real batches to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>to indicate that capacity allocation is not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae21cd7bacd0e04da32417b729f51f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21cd7bacd0e04da32417b729f51f8a">&#9670;&nbsp;</a></span>dropFirstRealBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dropFirstRealBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops the <code>n</code> first real batches to save memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of real batches to drop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if <code>n</code> is negative or greater than the number of stored real batches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#adb47c2fa081e9eada5e0441726235fd0" title="Returns the number of real batches dropped. ">getDroppedRealBatches()</a> </dd></dl>

</div>
</div>
<a id="a36f430995e3782e7f76456a38e976983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f430995e3782e7f76456a38e976983">&#9670;&nbsp;</a></span>getBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBatch </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the real batch corresponding to simulation time <code>time</code> when batch lengths are kept. </p>
<p>If batch lengths are not kept, or if the given time corresponds to the warmup period, this method returns a negative value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the simulation time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the batch corresponding to the time, or a negative value. </dd></dl>

</div>
</div>
<a id="a5435458fd47402535d7748509a75f367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5435458fd47402535d7748509a75f367">&#9670;&nbsp;</a></span>getBatchAggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean getBatchAggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the aggregation of batches is turned ON. </p>
<p>If <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a90aa162984f84cd54d9e3583806cb0a0" title="Computes the approximate number of required real batches to be simulated before the simulation can be...">getRequiredNewBatches</a> always returns 0 (the default), the aggregation has no effect since the number of batches is not random. By default, batch aggregation is turned OFF. </p><dl class="section return"><dt>Returns</dt><dd>the batch aggregation indicator. </dd></dl>

</div>
</div>
<a id="ad84d4bb7e5ad71d88d8949098730b183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84d4bb7e5ad71d88d8949098730b183">&#9670;&nbsp;</a></span>getBatchFraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getBatchFraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the remaining fraction of batch to be simulated. </p>
<p>This method is called when scheduling the end of the next batch during a simulation. Sometimes, it can be necessary to increase the batch size to avoid excessive memory usage. In this case, stored real batches (the \(\mathbf{V}_j\)’s) have to be regrouped to use less memory, and the last stored \(\mathbf{V}_j\) may represent an incomplete batch with respect to the new batch size. This method returns the fraction of batch, with respect to the new batch size, remaining to be simulated before a new batch starts. If regrouping is not used, this always returns 1. The returned value is always greater than 0 and smaller than or equal to 1. For example, with a fixed time batch size <code>s</code>, the next end of batch will be scheduled in <code>s*getBatchFraction()</code> simulation time units. This method returns values different from 1 only if one overrides <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa7e2a20f8e69eca5f8189e8ccf5ffc40" title="Allocates the necessary memory for storing capacity real batches. ">allocateCapacity(int)</a>, and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches</a>. </p><dl class="section return"><dt>Returns</dt><dd>the remaining fraction of batch to simulate.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches(int)</a> </dd></dl>

</div>
</div>
<a id="ad1c048e823db19b5efa54d6798c49ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c048e823db19b5efa54d6798c49ab3">&#9670;&nbsp;</a></span>getBatchLengthsKeeping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean getBatchLengthsKeeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that the length, in simulation time units, of each real batch has to be kept. </p>
<p>By default, this is set to <code>false</code>. When batch aggregation is turned ON, the batch lengths are always kept. </p><dl class="section return"><dt>Returns</dt><dd>the batch lengths keeping indicator. </dd></dl>

</div>
</div>
<a id="a363889276e14b29042c858598008fc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363889276e14b29042c858598008fc1e">&#9670;&nbsp;</a></span>getBatchSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getBatchSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current batch size as defined for this simulator. </p>
<p>By default, this is a duration in simulation time units. Depending on the batch termination condition, which can be changed by overriding <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af02e7007c56dfc77e16efba953d9422a" title="Simulate a new batch with default length. ">simulateBatch</a>, it can be the number of occurrences of an event, or 1 for regenerative cycles. </p><dl class="section return"><dt>Returns</dt><dd>the current batch size. </dd></dl>

</div>
</div>
<a id="aba2cf9f5abdde261c01bd1f1efd368ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2cf9f5abdde261c01bd1f1efd368ca">&#9670;&nbsp;</a></span>getBatchSizeMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getBatchSizeMultiplier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the batch size multiplier after the simulation of a new batch. </p>
<p>This is called when scheduling the end of a new batch, to multiply the batch size after <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches(int)</a> has regrouped real batches. This can return any value greater than 0, or 1 if the size is unchanged (the most common case) or if aggregation is not used. This method returns values different from 1 only if one overrides <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa7e2a20f8e69eca5f8189e8ccf5ffc40" title="Allocates the necessary memory for storing capacity real batches. ">allocateCapacity(int)</a>, and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches</a>. </p><dl class="section return"><dt>Returns</dt><dd>the batch size multiplier.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a70998c7df9a6d31ee33c17e66421bf0b" title="Regroups real batches x by x. ">regroupRealBatches(int)</a> </dd></dl>

</div>
</div>
<a id="a15c88ff2d5d1c950f26529ffdaabb896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c88ff2d5d1c950f26529ffdaabb896">&#9670;&nbsp;</a></span>getCompletedRealBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCompletedRealBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of completed real batches since the beginning of the run. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of completed real batches. </dd></dl>

</div>
</div>
<a id="adb47c2fa081e9eada5e0441726235fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb47c2fa081e9eada5e0441726235fd0">&#9670;&nbsp;</a></span>getDroppedRealBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDroppedRealBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of real batches dropped. </p>
<p>When using sequential sampling, the target number of batches can become very high, resulting in not enough memory available to store the real batches. One simple heuristic to address this issue is to drop the first real batches, and increase the batch length. This method gives the number of real batches which have been dropped to save memory. </p><dl class="section return"><dt>Returns</dt><dd>the number of dropped real batches. </dd></dl>

</div>
</div>
<a id="acbaae6df6d841ad510e8f1e1d1c8ce61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaae6df6d841ad510e8f1e1d1c8ce61">&#9670;&nbsp;</a></span>getMaxBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getMaxBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns \(M\), the maximal number of batches to be used for estimating the steady-state performance measures of interest. </p>
<p>This is used to prevent the number of batches from growing indefinitely when using sequential sampling. By default, this is set to java.lang.Integer.MAX_VALUE, which is equivalent to infinity in practice. </p><dl class="section return"><dt>Returns</dt><dd>the maximal number of batches. </dd></dl>

</div>
</div>
<a id="ab87397860afd295bde86eb8a130c47eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87397860afd295bde86eb8a130c47eb">&#9670;&nbsp;</a></span>getMinBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getMinBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimal number of batches required for estimating the steady-state performance measures of interest. </p>
<p>If aggregation is turned ON, this is also the final number of effective batches, i.e., the sample size. </p><dl class="section return"><dt>Returns</dt><dd>the minimal number of batches. </dd></dl>

</div>
</div>
<a id="a0a844710506e6649c63de998cab3fcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a844710506e6649c63de998cab3fcbb">&#9670;&nbsp;</a></span>getNumAggregates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumAggregates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns \(h\), the number of real batches contained into an effective batch. </p>
<p>If aggregation is turned OFF, this always returns 1 as soon as at least one batch is simulated. Otherwise, this returns a number greater than or equal to 1 as soon as <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs(int,int,double)</a> is called. </p><dl class="section return"><dt>Returns</dt><dd>the number of real batches in one effective batch.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if \(h\) is not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaceeddff4fad32a9250915d412e0b3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceeddff4fad32a9250915d412e0b3e5">&#9670;&nbsp;</a></span>getRealBatchEndingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getRealBatchEndingTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ending simulation time of batch <code>batch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>the queried batch index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ending time. </dd></dl>

</div>
</div>
<a id="a81049c79c88edf35834a0aebe7d6cd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81049c79c88edf35834a0aebe7d6cd1c">&#9670;&nbsp;</a></span>getRealBatchLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getRealBatchLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length, in simulation time units, of the real batch <code>batch</code>. </p>
<p>If batch lengths are not kept, this method can return the length of the last batch only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>the batch index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the batch.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the batch index is out of bounds. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the batch length is not available for <code>batch</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87b238fd6b48d30a8a4e9a4473534005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b238fd6b48d30a8a4e9a4473534005">&#9670;&nbsp;</a></span>getRealBatchStartingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getRealBatchStartingTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the starting simulation time of batch <code>batch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>the queried batch index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the starting time. </dd></dl>

</div>
</div>
<a id="a90aa162984f84cd54d9e3583806cb0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aa162984f84cd54d9e3583806cb0a0">&#9670;&nbsp;</a></span>getRequiredNewBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRequiredNewBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the approximate number of required real batches to be simulated before the simulation can be stopped. </p>
<p>The default implementation always returns 0, which stops the simulation after <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aeed23232dfc6ff9cbeed2be646b8a2e2" title="Returns the target number of simulated real batches at the next time the stopping condition is checke...">getTargetBatches</a> real batches are obtained; sequential sampling is not used by default.</p>
<p>Note: if the method uses umontreal.ssj.simexp.SimExp.getRequiredNewObservations(StatProbe[],double,double) with a statistical probe containing one observation per effective batch, this gives the number of additional effective batches to simulate. This value should be multiplied with <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0a844710506e6649c63de998cab3fcbb" title="Returns , the number of real batches contained into an effective batch. ">getNumAggregates</a> to get the number of additional real batches. </p><dl class="section return"><dt>Returns</dt><dd>the approximate required number of additionnal real batches. </dd></dl>

</div>
</div>
<a id="a12d5ecfe28b2ae6a52f34b350c50cc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d5ecfe28b2ae6a52f34b350c50cc74">&#9670;&nbsp;</a></span>getSum() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double getSum </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the array <code>a</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the source array. </td></tr>
    <tr><td class="paramname">start</td><td>the index of the first element to sum. </td></tr>
    <tr><td class="paramname">length</td><td>the number of elements in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>a</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td><code>length</code> is negative. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if <code>start</code> is negative, or <code>start + length</code> is greater than the length of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a951f079ad09b1efb63620678d73c98c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f079ad09b1efb63620678d73c98c5">&#9670;&nbsp;</a></span>getSum() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double getSum </td>
          <td>(</td>
          <td class="paramtype">DoubleArrayList&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the array list <code>l</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the source array list. </td></tr>
    <tr><td class="paramname">start</td><td>the index of the first element to sum. </td></tr>
    <tr><td class="paramname">length</td><td>the number of elements in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>l</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td><code>length</code> is negative. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if <code>start</code> is negative, or <code>start + length</code> is greater than the size of <code>l</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4ca3fa66b4b029c96831b5a4d1145e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ca3fa66b4b029c96831b5a4d1145e6">&#9670;&nbsp;</a></span>getSum() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double getSum </td>
          <td>(</td>
          <td class="paramtype">DoubleMatrix1D&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of elements <code>start</code>, …, <code>start + length - 1</code>, in the 1D matrix <code>m</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the source 1D matrix. </td></tr>
    <tr><td class="paramname">start</td><td>the index of the first element to sum. </td></tr>
    <tr><td class="paramname">length</td><td>the number of elements in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>m</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td><code>length</code> is negative. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if <code>start</code> is negative, or <code>start + length</code> is greater than the size of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214bae033f54d441185f0ecb43da1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214bae033f54d441185f0ecb43da1969">&#9670;&nbsp;</a></span>getSum() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] getSum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array containing the sum of columns <code>startColumn</code>, …, <code>startColumn + numColumns - 1</code>, in the 2D matrix represented by the 2D array <code>a</code>. </p>
<p>The given array is assumed to be rectangular, i.e., each of its array elements has the same length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the source 2D array. </td></tr>
    <tr><td class="paramname">startColumn</td><td>the index of the first column to sum. </td></tr>
    <tr><td class="paramname">numColumns</td><td>the number of columns in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of <code>a.length</code> elements containing the sums of the columns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>a</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td><code>numColumns</code> is negative. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if <code>startColumn</code> is negative, or <code>startColumn + numColumns</code> is greater than the number of columns in the matrix represented by <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad894c2cd577a1bc907327e278d61d445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad894c2cd577a1bc907327e278d61d445">&#9670;&nbsp;</a></span>getSum() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] getSum </td>
          <td>(</td>
          <td class="paramtype">DoubleMatrix2D&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array containing the sum of columns <code>startColumn</code>, …, <code>startColumn + numColumns - 1</code>, in the 2D matrix <code>m</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the source 2D matrix. </td></tr>
    <tr><td class="paramname">startColumn</td><td>the index of the first column to sum. </td></tr>
    <tr><td class="paramname">numColumns</td><td>the number of columns in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of <code>m.rows()</code> elements containing the sum of the columns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>m</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td><code>numColumns</code> is negative. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if <code>startColumn</code> is negative, or <code>startColumn + numColumns</code> is greater than the number of columns in <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed23232dfc6ff9cbeed2be646b8a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed23232dfc6ff9cbeed2be646b8a2e2">&#9670;&nbsp;</a></span>getTargetBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTargetBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target number of simulated real batches at the next time the stopping condition is checked. </p>
<p>By default, this number is set to the minimal number of batches and is increased if the stopping condition check requires new simulated batches. This target number of batches is not decreased automatically, even upon a new call to <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a1f451daf160cbacfab1e7b495789750e" title="Performs a batch means simulation. ">simulate</a>. </p><dl class="section return"><dt>Returns</dt><dd>the target number of batches. </dd></dl>

</div>
</div>
<a id="ad2fab66cb7896afc7d759c23a71e1d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fab66cb7896afc7d759c23a71e1d00">&#9670;&nbsp;</a></span>getWarmupTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getWarmupTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the duration of the warmup period for the simulation. </p>
<p>By default, this duration is expressed in simulation time units, but this can be changed by overriding <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a101bbfc4b8397b53f3b2709c529c8e56" title="Performs a warmup by calling warmup(double). ">warmup</a>. </p><dl class="section return"><dt>Returns</dt><dd>the warmup time for the simulation. </dd></dl>

</div>
</div>
<a id="a02fd73d861ef2e4aabb38c0c9ff82947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd73d861ef2e4aabb38c0c9ff82947">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the simulator for a new experiment. </p>
<p>This method, called by <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a1f451daf160cbacfab1e7b495789750e" title="Performs a batch means simulation. ">simulate</a>, resets the counter for the number of batches, calls <code><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7" title="Returns the simulator linked to this experiment object. ">simulator()</a>.init</code>, followed by <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a76e62dd2ef8965d2a6d44076d9cd041c" title="Initializes the simulator for a new run. ">initSimulation</a>. </p>

</div>
</div>
<a id="a0b3843064274dc3a525fc23ff623a0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3843064274dc3a525fc23ff623a0c3">&#9670;&nbsp;</a></span>initEffectiveBatchProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void initEffectiveBatchProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes any statistical collector for effective batches. </p>
<p>This is called at every stopping condition check when aggregation is ON, or at the end of the warmup period when it is OFF. </p>

</div>
</div>
<a id="a9614ccd1eb8c65c521b4f8565ba0d761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9614ccd1eb8c65c521b4f8565ba0d761">&#9670;&nbsp;</a></span>initRealBatchProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void initRealBatchProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes any statistical collector for real batches. </p>
<p>This is called at the end of the warmup period. </p>

</div>
</div>
<a id="a76e62dd2ef8965d2a6d44076d9cd041c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e62dd2ef8965d2a6d44076d9cd041c">&#9670;&nbsp;</a></span>initSimulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void initSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the simulator for a new run. </p>
<p>This is called by the <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the simulator for a new experiment. ">init</a> method after <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Sim.html#aedc913c139bb562646d3459b0ca28997" title="Reinitializes the simulation executive by clearing up the event list, and resetting the simulation cl...">umontreal.ssj.simevents.Sim.init</a> is called. </p>

</div>
</div>
<a id="ab0b78fcb9baa60ee562f2ce143c050c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b78fcb9baa60ee562f2ce143c050c7">&#9670;&nbsp;</a></span>isWarmupDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean isWarmupDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the warmup period for the simulation is over. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the warmup period is finished, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6271b96a244ad5ca6df80a445c1ed279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6271b96a244ad5ca6df80a445c1ed279">&#9670;&nbsp;</a></span>regroupElements() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regroupElements </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regroups the elements in array <code>a</code> by summing each successive <code>x</code> values. </p>
<p>When this method returns, element <code>i</code> of the given array corresponds to the sum of elements <code>ix</code>, …, <code>ix + x - 1</code> in the original array. If the size of the array is not a multiple of <code>x</code>, the remaining elements are summed up and added into an extra element of the transformed array. Remaining elements of the transformed array are set to 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the array being processed. </td></tr>
    <tr><td class="paramname">x</td><td>the regrouping factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>a</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if <code>x</code> is smaller than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94934c943435ba6bf46b977eb9404366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94934c943435ba6bf46b977eb9404366">&#9670;&nbsp;</a></span>regroupElements() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regroupElements </td>
          <td>(</td>
          <td class="paramtype">DoubleArrayList&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as #regroupElements(double[],int) for an array list. </p>
<p>The size of the list is also divided by <code>x</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the array list being processed. </td></tr>
    <tr><td class="paramname">x</td><td>the regrouping factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>l</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if <code>x</code> is smaller than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0b21e697d197819e5f656978552389e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b21e697d197819e5f656978552389e">&#9670;&nbsp;</a></span>regroupElements() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regroupElements </td>
          <td>(</td>
          <td class="paramtype">DoubleMatrix1D&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as #regroupElements(double[],int) for a 1D matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>the 1D matrix being processed. </td></tr>
    <tr><td class="paramname">x</td><td>the regrouping factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>mat</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if <code>x</code> is smaller than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6df6ec3388a2eaf02af18ad5f66ba6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6ec3388a2eaf02af18ad5f66ba6ff">&#9670;&nbsp;</a></span>regroupElements() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regroupElements </td>
          <td>(</td>
          <td class="paramtype">DoubleMatrix2D&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as #regroupElements(double[],int) for a 2D matrix. </p>
<p>This method regroups columns and considers each row as an independent array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>the 2D matrix being processed. </td></tr>
    <tr><td class="paramname">x</td><td>the regrouping factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>mat</code> is <code>null</code>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if <code>x</code> is smaller than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70998c7df9a6d31ee33c17e66421bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70998c7df9a6d31ee33c17e66421bf0b">&#9670;&nbsp;</a></span>regroupRealBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regroupRealBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regroups real batches <code>x</code> by <code>x</code>. </p>
<p>When memory is low, the simulator can try to regroup real batches and increase the batch size consequently. This is partly done by this method. The user must override it and modify the internal data structures storing the \(\mathbf{V}_j\)’s in order to regroup elements. The number of real batches \(m\) becomes \(m’=\lfloor m/x\rfloor\). After this method returns, each new \(\mathbf{V}_j\) should contain \(\mathbf{V}_j=\sum_{l=0}^{x-1}\mathbf{V}_{jx+l}\) for \(j=0,…, m’ - 1\), \(\mathbf{V}_{m’}=\sum_{l=0}^{(m \bmod x) - 1} \mathbf{V}_{m’x + l}\), and \(\mathbf{V}_j=0\) for \(j=m’+1, …, m - 1\). Some static methods called #regroupElements(double[],int) are provided by this class to help the user with this. By default, this method throws an UnsupportedOperationException, disabling this functionality which is not always needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the regrouping factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if regrouping is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae21ab10c53d00d832f156afcf4b738f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21ab10c53d00d832f156afcf4b738f0">&#9670;&nbsp;</a></span>setBatchAggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBatchAggregation </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the batch aggregation indicator to <code>a</code>. </p>
<p>This should not be called during an experiment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the new batch aggregation indicator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the warmup period is over, and simulation is not terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e2c8c676da02955f54b8d48409803f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e2c8c676da02955f54b8d48409803f">&#9670;&nbsp;</a></span>setBatchLengthsKeeping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBatchLengthsKeeping </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the batch lengths keeping indicator to <code>b</code>. </p>
<p>This has no impact if batch aggregation is turned ON. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the new value of the indicator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the warmup period is over and simulation is not terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e65b36451c83711407381ecb1d2fc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e65b36451c83711407381ecb1d2fc2f">&#9670;&nbsp;</a></span>setBatchSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBatchSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the batch size to <code>batchSize</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchSize</td><td>the new batch size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given batch size is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84f5264bed93b78e8b0e933393a19455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f5264bed93b78e8b0e933393a19455">&#9670;&nbsp;</a></span>setMaxBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMaxBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBatches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximal number of batches to <code>maxBatches</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxBatches</td><td>the new maximal number of batches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the maximal number of batches is smaller than the actual minimal number of batches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d9747a25d301fe6d548aa997b0d2743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9747a25d301fe6d548aa997b0d2743">&#9670;&nbsp;</a></span>setMinBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMinBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minBatches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimal number of batches to <code>minBatches</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minBatches</td><td>the new minimal number of batches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified minimal number of batches is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e079dcd25269f75a8ae8a90721d63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e079dcd25269f75a8ae8a90721d63b">&#9670;&nbsp;</a></span>setTargetBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTargetBatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetBatches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the target number of simulated batches before an error check or the end of the simulation to <code>targetBatches</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetBatches</td><td>the target number of batches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the new target number of batches is smaller than the minimal number of batches, or greater than the maximal number of batches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d77bfbc5fb9105bed002a843effd75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d77bfbc5fb9105bed002a843effd75d">&#9670;&nbsp;</a></span>setWarmupTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setWarmupTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the warmup time to <code>warmupTime</code>. </p>
<p>If this method is called while a simulation is in progress, the new time will affect the next simulation only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warmupTime</td><td>the new warmup time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the warmup time is smaller than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f451daf160cbacfab1e7b495789750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f451daf160cbacfab1e7b495789750e">&#9670;&nbsp;</a></span>simulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a batch means simulation. </p>
<p>This method resets the state of the system by calling <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the simulator for a new experiment. ">init</a>, and calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a101bbfc4b8397b53f3b2709c529c8e56" title="Performs a warmup by calling warmup(double). ">warmup</a> to perform the warmup. Then, the method calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a7311be0dc09066e277a34d3f353d4d63" title="Simulates batches until the number of completed real batches corresponds to the target number of batc...">simulateBatches</a> and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a90aa162984f84cd54d9e3583806cb0a0" title="Computes the approximate number of required real batches to be simulated before the simulation can be...">getRequiredNewBatches</a> until the number of completed real batches equals or exceeds the target number of batches. </p>

</div>
</div>
<a id="af02e7007c56dfc77e16efba953d9422a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e7007c56dfc77e16efba953d9422a">&#9670;&nbsp;</a></span>simulateBatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate a new batch with default length. </p>
<p>By default, this method multiplies the current batch size with <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aba2cf9f5abdde261c01bd1f1efd368ca" title="Returns the batch size multiplier after the simulation of a new batch. ">getBatchSizeMultiplier</a>, and schedules the next end-batch event to happen in <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a363889276e14b29042c858598008fc1e" title="Returns the current batch size as defined for this simulator. ">getBatchSize</a> <code>*</code> <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad84d4bb7e5ad71d88d8949098730b183" title="Returns the remaining fraction of batch to be simulated. ">getBatchFraction</a> simulation time units, by using <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af661c09717d11da5af2bd829e09878c1" title="Simulates a batch with length batchLength. ">simulateBatch(double)</a>. After the batch is simulated, the batch-size multiplier and fraction are reset to 1. If the batch lengths are not fixed, one can override this method to call <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af661c09717d11da5af2bd829e09878c1" title="Simulates a batch with length batchLength. ">simulateBatch(double)</a> with <code>Double.POSITIVE_INFINITY</code>; this prevents the method from scheduling the ending event, and let the simulator call <code><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7" title="Returns the simulator linked to this experiment object. ">simulator()</a>.stop</code> at appropriate time. </p>

</div>
</div>
<a id="af661c09717d11da5af2bd829e09878c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af661c09717d11da5af2bd829e09878c1">&#9670;&nbsp;</a></span>simulateBatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateBatch </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>batchLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a batch with length <code>batchLength</code>. </p>
<p>This method initializes the model-specific counters by using <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9a1683dda525d4b417022cd5852c9571" title="Resets the counters used for computing observations during the simulation at the beginning of a new b...">initBatchStat</a>, simulates the batch, and adds observations using <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aa5d5a31527ab24aba6c6c5ff9acb4771" title="Collects values of a  vector concerning the last simulated real batch. ">addRealBatchObs</a>. It also calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs</a> if aggregation is turned OFF. If the batch lengths are not fixed, one can call this method to call <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af661c09717d11da5af2bd829e09878c1" title="Simulates a batch with length batchLength. ">simulateBatch(double)</a> with <code>Double.POSITIVE_INFINITY</code>; this prevents the method from scheduling the ending event, and let the simulator call <code><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7" title="Returns the simulator linked to this experiment object. ">simulator()</a>.stop</code> at appropriate time. </p>

</div>
</div>
<a id="a7311be0dc09066e277a34d3f353d4d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7311be0dc09066e277a34d3f353d4d63">&#9670;&nbsp;</a></span>simulateBatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates batches until the number of completed real batches corresponds to the target number of batches. </p>
<p>This method first allocates the capacity for simulating <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#aeed23232dfc6ff9cbeed2be646b8a2e2" title="Returns the target number of simulated real batches at the next time the stopping condition is checke...">getTargetBatches</a>. It then simulate each batch using <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#af02e7007c56dfc77e16efba953d9422a" title="Simulate a new batch with default length. ">simulateBatch</a>. If aggregation is turned ON, this method also calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a0b3843064274dc3a525fc23ff623a0c3" title="Initializes any statistical collector for effective batches. ">initEffectiveBatchProbes</a>, and <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a2d2e52c400d0e3a5289a2a26f982c26d" title="Adds an observation to each statistical collector corresponding to an effective batch. ">addEffectiveBatchObs</a> to manage effective batches. </p>

</div>
</div>
<a id="a101bbfc4b8397b53f3b2709c529c8e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101bbfc4b8397b53f3b2709c529c8e56">&#9670;&nbsp;</a></span>warmup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void warmup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a warmup by calling <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a" title="Performs a warmup of fixed duration warmupTime. ">warmup(double)</a>. </p>
<p>By default, this method calls <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a" title="Performs a warmup of fixed duration warmupTime. ">warmup(double)</a> with the value returned by <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#ad2fab66cb7896afc7d759c23a71e1d00" title="Returns the duration of the warmup period for the simulation. ">getWarmupTime</a>, but one can override this method to simulate the warmup differently. If the duration of the warmup period is not fixed, one can call <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a" title="Performs a warmup of fixed duration warmupTime. ">warmup(double)</a> with <code>Double.POSITIVE_INFINITY</code>; this prevents the method from scheduling the ending event, and let the simulator call <code><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7" title="Returns the simulator linked to this experiment object. ">simulator()</a>.stop</code> at appropriate time. </p>

</div>
</div>
<a id="a3566e6a144f79b6980f82efb0452bb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3566e6a144f79b6980f82efb0452bb8a">&#9670;&nbsp;</a></span>warmup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void warmup </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>warmupTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a warmup of fixed duration <code>warmupTime</code>. </p>
<p>This method simulates for <code>warmupTime</code> simulation time units, and initializes statistical probes for real batches through <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a9614ccd1eb8c65c521b4f8565ba0d761" title="Initializes any statistical collector for real batches. ">initRealBatchProbes</a>. If the duration of the warmup period is not fixed, one can call <a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1BatchMeansSim.html#a3566e6a144f79b6980f82efb0452bb8a" title="Performs a warmup of fixed duration warmupTime. ">warmup(double)</a> with <code>Double.POSITIVE_INFINITY</code>; this prevents the method from scheduling the ending event, and let the simulator call <code><a class="el" href="classumontreal_1_1ssj_1_1simexp_1_1SimExp.html#a19f81ca8edffc892efcfaa00ee1ca1f7" title="Returns the simulator linked to this experiment object. ">simulator()</a>.stop</code> at appropriate time. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>BatchMeansSim.java</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
