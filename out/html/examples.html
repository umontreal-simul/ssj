<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SSJ introduction and tutorial by example.</p>
<h1><a class="anchor" id="REF_examples_sec_01"></a>
Introduction</h1>
<p>The aim of this document is to provide an introduction to SSJ via a brief overview and a series of examples. The examples are collected in three groups:</p>
<ul>
<li>
those that need no event or process scheduling;  </li>
<li>
those based on the discrete-event simulation paradigm and implemented with an <em>event view</em> using the package <code>simevents</code>.  </li>
</ul>
<p>Sections&#160; <a class="el" href="examples.html#REF_examples_sec_simple">Some Elementary Examples</a> to <a class="el" href="examples.html#REF_examples_sec_event">Discrete-Event Simulation</a> of this guide correspond to these three groups. Some examples (e.g., the single-server queue) are carried across two or three sections to illustrate different ways of implementing the same model. The Java code of all these examples is available on-line from the SSJ web page (just type “SSJ iro” in Google).</p>
<p>While studying the examples, the reader can refer to the functional definitions (the APIs) of the SSJ classes and methods in the guides of the corresponding packages. Each package in SSJ has its own user’s guide in the form of a <code>.pdf</code> document that contains the detailed API and complete documentation, and starts with an overview of one or two pages. We strongly recommend reading each of these overviews. We also recommend to refer to the <code>.pdf</code> versions of the guides, because they contain a more detailed and complete documentation than the <code>.html</code> versions, which are better suited for quick on-line referencing for those who are already familiar with SSJ.</p>
<p>In Section&#160; REF_examples_sec_queue, we start with a very simple classical example: a single queue. We give different variants of this example, illustrating the mixture of processes and events. In Section&#160; <a class="el" href="examples.html#REF_examples_sec_preypred">Continuous simulation: A prey-predator system</a>, we give a small example of a deterministic continuous simulation. In Sections&#160; REF_examples_sec_jobshop and REF_examples_sec_timeshared, we give examples of a job shop model and a time-shared computer model, adapted from <a class="el" href="citelist.html#CITEREF_sLAW00a">[111]</a>&thinsp;. A queuing model of a bank, taken from <a class="el" href="citelist.html#CITEREF_sBRA87a">[24]</a>&thinsp;, is programmed in Section&#160; <a class="el" href="examples.html#REF_examples_sec_bank">A simplified bank</a>, with both the process and event views. In Section&#160; REF_examples_sec_visits, we simulate a model of guided tours for groups of people, where the process synchronization is slightly more complicated than for the earlier models. In Section&#160; REF_examples_sec_ingots, we give an example of a mixed discrete-continuous simulation. In Section&#160; REF_examples_sec_robot, we give a more elaborate example, for a model discussed in <a class="el" href="citelist.html#CITEREF_sLEC91a">[124]</a>&thinsp;, where a robot maintains a series of machines subject to random failures. It illustrates the idea of modular design.</p>
<h1><a class="anchor" id="REF_examples_sec_02"></a>
Overview of SSJ</h1>
<p>SSJ is an organized set of packages whose purpose is to facilitate stochastic simulation programming in the Java language. The facilities offered are grouped into different packages, each one having its own user’s guide as a <code>.pdf</code> file. This is the official documentation. There is also a simplified on-line documentation in HTML format, produced via <code>javadoc</code>. Early descriptions of SSJ are given in <a class="el" href="citelist.html#CITEREF_sLEC02a">[125]</a>, <a class="el" href="citelist.html#CITEREF_sLEC05a">[113]</a>&thinsp;. Some of the tools can also be used for modeling (e.g., selecting and fitting distributions). SSJ is still growing actively. New packages, classes, and methods will be added in forthcoming years and others will be refined.</p>
<p>The packages currently offered are the following:</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1util.html">umontreal::ssj::util</a> contains utility classes used in the implementation of SSJ, and which are often useful elsewhere. For example, there are timers (for CPU usage), utilities to read or format numbers and arrays from/to text, operations on binary vectors and matrices, some mathematical functions and constants, root-finding tools, facilities for SQL database interface, and so on.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, and inverse distribution functions for many discrete and continuous probability distributions, as well as estimating the parameters of these distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1probdistmulti.html">umontreal::ssj::probdistmulti</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, for some multi-dimensionnal discrete and continuous probability distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> provides facilities for generating uniform random numbers over the interval \((0,1)\), or over a given range of integer values, and other types of simple random objects such as random permutations.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> provides classes implementing highly uniform point sets and sequences (HUPS), also called low-discrepancy sets and sequences, and tools for their randomization.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> provides a collection of classes for non-uniform random variate generation, primarily from standard distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1randvarmulti.html">umontreal::ssj::randvarmulti</a> provides a collection of classes for random number generators for some multi-dimensional distributions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1gof.html">umontreal::ssj::gof</a> contains tools for performing univariate goodness-of-fit (GOF) statistical tests.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> provides elementary tools for collecting statistics and computing confidence intervals.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1matrix.html">umontreal::ssj::stat::matrix</a> this subpackage of <code>stat</code> provides facilities to create and manage rectangular two-dimensional arrays of statistical collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1list.html">umontreal::ssj::stat::list</a> this subpackage of <code>stat</code> provides support to manage lists of statistical collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1list_1_1lincv.html">umontreal::ssj::stat::list::lincv</a> this subpackage of <code>stat.list</code> provides classes that help implement control variables on lists of collectors.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simevents.html">umontreal::ssj::simevents</a> provides and manages the event-driven simulation facilities as well as the simulation clock. Can manage several simulations in parallel, in the same program.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simevents_1_1eventlist.html">umontreal::ssj::simevents::eventlist</a> this subpackage of <code>simevents</code> offers several kinds of event list implementations.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1functions.html">umontreal::ssj::functions</a> contains classes that allow one to pass an arbitrary function of one variable as argument to a method and to apply elementary mathematical operations on generic functions.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1functionfit.html">umontreal::ssj::functionfit</a> provides basic facilities for curve fitting and interpolation with polynomials.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simexp.html">umontreal::ssj::simexp</a> provides facilities for performing simulation experiments using independent replications as well as simulations using batch means.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1charts.html">umontreal::ssj::charts</a> provides tools for easy construction, visualization, and customization of \(xy\) plots, histograms, and empirical styled charts from a Java program.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1discrepancy.html">umontreal::ssj::discrepancy</a> contains classes and methods to compute several kind of discrepancies for point sets.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1markovchainrqmc.html">umontreal::ssj::markovchainrqmc</a> contains classes related to Markov chains simulation using randomized quasi-Monte Carlo.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1stochprocess.html">umontreal::ssj::stochprocess</a> implements different kinds of stochastic processes.</p>
<h2><a class="anchor" id="REF_examples_sec_03"></a>
Dependence on other libraries</h2>
<p>SSJ uses some classes from other free Java libraries.</p>
<p>The <a href="http://acs.lbl.gov/software/colt/">Colt library</a> , developed at the Centre Européen de Recherche Nucléaire (CERN) in Geneva <a class="el" href="citelist.html#CITEREF_iHOS04a">[86]</a>&thinsp;, is a large library that provides a wide range of facilities for high performance scientific and technical computing in Java. SSJ uses the class DoubleArrayList from Colt in a few of its classes, namely in packages <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> and <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a>. The reason is that this class provides a very efficient and convenient implementation of an (automatically) extensible array of <code>double</code>, together with several methods for computing statistics for the observations stored in the array (see, e.g., <code>Descriptive</code>). The Colt library is distributed with the SSJ package as <b>colt.jar</b>. It must be added in the CLASSPATH environment variable.</p>
<p>The <b>linear_algebra</b> library is based on public domain LINPACK routines. They were translated from Fortran to Java by Steve Verrill at the USDA Forest Products Laboratory Madison, Wisconsin, USA. The optimization package of Steve Verrill includes Java translations of the <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Minpack_f77.html">MINPACK</a> routines <a class="el" href="citelist.html#CITEREF_iMOR80a">[89]</a>&thinsp; for nonlinear least squares problems as well as <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Uncmin_f77.html">UNCMIN</a> routines <a class="el" href="citelist.html#CITEREF_iSCHa">[187]</a>&thinsp; for unconstrained optimization. They were translated from Fortran to Java by Steve Verrill and are in the public domain. They are included in the SSJ distribution as the <b>optimization.jar</b> archive. It is used only in the <code>probdist</code> package to compute maximum likelihood estimators.</p>
<p><a href="http://www.jfree.org/jfreechart/index.html">JFreeChart</a> is a free Java library that can generate a wide variety of charts and plots for use in applications, applets and servlets. <b>JFreeChart</b> currently supports, amongst others, bar charts, pie charts, line charts, XY-plots, histograms, scatter plots and time series plots. It is distributed with SSJ as <b>jfreechart-*.jar</b>. <a href="http://www.jfree.org/jcommon/index.php">JCommon</a> is a free general purpose Java library containing many useful classes used by JFreeChart and other Java packages. It is distributed with SSJ as <b>jcommon-*.jar</b>. JFreeChart (and JCommon) are used in the SSJ package <b>charts</b> to create different kinds of charts.</p>
<p>SSJ also provides an interface to the <a href="http://statistik.wu-wien.ac.at/unuran/">UNURAN</a> library for nonuniform random number generation <a class="el" href="citelist.html#CITEREF_iLEY02a">[144]</a>&thinsp;, in the <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> package. UNURAN does not have to be installed to be used with SSJ, because it is linked statically with the appropriate SSJ native library. However, the UNURAN documentation will be required to take full advantage of the library.</p>
<h2><a class="anchor" id="REF_examples_sec_04"></a>
random number generation</h2>
<p>Random numbers feed simulation models and allow one to compute statistics. To generate random numbers from any probability distribution, uniform random numbers are required. Such numbers are uniformly distributed in the \([0,1)\) interval, i.e., the probability of getting a given number \(x\) in that interval is the same for all values of \(x\in[0,1)\). Any generated number \(x\) is also independent from any previous or future generated numbers. Although the generated uniforms are not truly independent since one uniform is obtained from the previous uniforms by a mathematical formula, one can consider them independent for simulation purposes. Selection of a random number generator is based on several criteria such as uniformity, performance, and portability <a class="el" href="citelist.html#CITEREF_rLEC01d">[135]</a>&thinsp;. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> contains the needed tools to generate such numbers. It defines an interface called <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> implemented by any random number generator supported by SSJ. This interface allows one to easily interchange random number generators since they are accessed through the same set of methods specified by the interface. Only the random number generator setup depends on the type of generator that was chosen.</p>
<p>If one wants to replace uniform random numbers with low-discrepancy point sets for variance reduction, the package <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> contains all the necessary facilities. Such highly uniform point sets all inherit from the <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> which provides a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> extending <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a>. The replacement can be easily done without modifying the model implementation, except the setup-time code.</p>
<p>To generate non-uniform random numbers, one must select a probability distribution based on the empirical data <a class="el" href="citelist.html#CITEREF_sLAW00a">[111]</a>&thinsp;. SSJ does not provide probability distribution estimation tools, but goodness of fit tests are included to help in model validation. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> contains several standard, commonly-used, probability distributions. It supports discrete and continuous distributions through two different abstract base classes: <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">umontreal.ssj.probdist.ContinuousDistribution</a> and <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1DiscreteDistribution.html">umontreal.ssj.probdist.DiscreteDistribution</a>, respectively. Again, since the distributions inherit from a common class, their access can be independent from the selected distribution, except for the setup case. One can compute the density/mass, distribution, complementary, and inverse distribution functions. These facilities are also accessible through static methods implemented in each distribution class if one does not want to create objects or needs distributions whose parameters vary in time. However, setup-time operations must be performed for each operation, which can be inefficient for certain distributions.</p>
<p>To generate non-uniform random numbers, the packages <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal::ssj::rng</a> (or <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal::ssj::hups</a> ) and <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> must be used together. The simplest generation method is to generate a uniform random number using a generator implementing <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> (or get a coordinate using a point set iterator) and to apply inversion by using the selected <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> distribution’s <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html#a47dfe73ca7d2e4a8bf34bc96af34530a" title="Returns the inverse distribution function . ">umontreal.ssj.probdist.ContinuousDistribution.inverseF</a> method. However, inversion is not the only generation method and sometimes not the most efficient. For some distributions, closed-form inverse functions or fast inversion algorithms exist. For others, inversion is performed using binary or even linear search. In such cases, the performance and precision depends on the complexity of the distribution function which is calculated several times for one inverse. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> acts as glue between uniform random number generators and probability distributions. Continuous or discrete random number generators also inherits from common base classes, namely <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGen.html">umontreal.ssj.randvar.RandomVariateGen</a> and <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGenInt.html">umontreal.ssj.randvar.RandomVariateGenInt</a>. All generators use a random stream and a probability distribution for their construction. As opposed to <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a>, one can directly instantiate <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGen.html">umontreal.ssj.randvar.RandomVariateGen</a> or <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGenInt.html">umontreal.ssj.randvar.RandomVariateGenInt</a>. However, in such cases, only inversion generation method will be available. To use an alternate generation method, one must instantiate a specialized generator class and switch to the given generation algorithm using an object method. Each specialized class also provides static method which perform the same action. Although they allow one to avoid object creation, their signatures are specific to the used distribution and they have to perform setup-time operations on each variate generation, which can become inefficient. The <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal::ssj::randvar</a> package also provides the class umontreal.ssj.randvar.RandomVariateTrans to apply transformations to a generator. This allows, for example, to generate variates from a truncated distribution.</p>
<h2><a class="anchor" id="REF_examples_sec_05"></a>
Performing simulation</h2>
<p>SSJ supports discrete-event, process-driven, continuous or mixed simulation. The discrete-event and continuous simulation are managed by the package <a class="el" href="namespaceumontreal_1_1ssj_1_1simevents.html">umontreal::ssj::simevents</a>. This package manages the simulation clock and the event list, two essential components for all discrete-event simulations. The simulation clock tracks the simulation time whereas the event list stores the scheduled events to execute them in the right order. Events are user-defined subclasses of <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html">umontreal.ssj.simevents.Event</a>. When an event occurs, any type of actions can then be taken. The package provides a class called umontreal.ssj.simevents.List which implements a linked list supporting statistical collection. Continuous simulation can be performed using the class <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html">umontreal.ssj.simevents.Continuous</a>. It uses the event framework to resolve differential equations numerically at fixed steps in the simulation time.</p>
<h2><a class="anchor" id="REF_examples_sec_06"></a>
Other tools</h2>
<p>The package <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal::ssj::stat</a> provides basic tools for statistical collection. Statistics are collected using statistical probes, i.e, objects implementing the abstract class <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">umontreal.ssj.stat.StatProbe</a>. Two types of probes are supported. The <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">umontreal.ssj.stat.Tally</a> allows to collect observations of the form \(X_1,…,X_n\) whereas <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Accumulate.html">umontreal.ssj.simevents.Accumulate</a> collects statistics for a continuous variable evolving in simulation time. During the simulation, one can add observations to such probes. After the simulation, measures can be obtained, such as sample average, sample standard deviation or confidence interval. A statistical report can be obtained for all probes. The package also provides a way to detach statistical collection from the model implementation by using bound properties.</p>
<p>To test a proposed model against empirical data, goodness of fit tests are provided in the package <a class="el" href="namespaceumontreal_1_1ssj_1_1gof.html">umontreal::ssj::gof</a>. Such tests, e.g. Kolmogorov-Smirnov or Anderson-Darling, compute a statistic using the empirical observations and the proposed distribution. The empirical observations are given as an array whereas the distribution is given as a <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal::ssj::probdist</a> object. From the computed statistic, it is possible to compute the \(p\)-value which is useful to evaluate the significance of the test.</p>
<h2><a class="anchor" id="REF_examples_sec_07"></a>
Related documentation</h2>
<p>The <code>example.pdf</code> file, in the <code>doc/pdf</code> subdirectory of the SSJ distribution, explains simulation examples implemented using SSJ. This may be the best starting point to learn SSJ. Every package introduced here contains its own reference documentation as a PDF file, in the <code>doc/pdf</code> subdirectory. This documentation describes in more details how to use the package and provides a description of each class and method.</p>
<h1><a class="anchor" id="REF_examples_sec_simple"></a>
Some Elementary Examples</h1>
<p>We start with elementary examples that illustrate how to generate uniform and nonuniform random numbers, construct probability distributions, collect elementary statistics, and compute confidence intervals, compare similar systems, and use randomized quasi-Monte Carlo point sets, with SSJ.</p>
<p>The models considered here are quite simple and some of the performance measures can be computed by (more accurate) numerical methods rather than by simulation. The fact that we use these models to give a first tasting of SSJ should not be interpreted to mean that simulation is necessarily the best tool for them.</p>
<h2><a class="anchor" id="REF_examples_sec_collision"></a>
Collisions in a hashing system</h2>
<p>We want to estimate the expected number of collisions in a hashing system. There are \(k\) locations (or addresses) and \(m\) distinct items. Each item is assigned a random location, independently of the other items. A <em>collision</em> occurs each time an item is assigned a location already occupied. Let \(C\) be the number of collisions. We want to estimate \(\mathbb E[C]\), the expected number of collisions, by simulation. A theoretical result states that when \(k\to\infty\) while \(\lambda= m^2/(2k)\) is fixed, \(C\) converges in distribution to a Poisson random variable with mean \(\lambda\). For finite values of \(k\) and \(m\), we may want to approximate the distribution of \(C\) by the Poisson distribution with mean \(\lambda\), and use Monte Carlo simulation to assess the quality of this approximation. To do that, we can generate \(n\) independent realizations of \(C\), say \(C_1,…,C_n\), compute their empirical distribution and empirical mean, and compare with the Poisson distribution.</p>
<p>The Java program in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Collision">Collision</a> simulates \(C_1,…,C_n\) and computes a 95% confidence interval on \(\mathbb E[C]\). The results for \(k = 10000\), \(m = 500\), and \(n = 100000\), are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Collision">Collision</a>. The reported confidence interval is \((12.25,  12.29)\), whereas \(\lambda= 12.5\). This indicates that the asymptotic result underestimates \(\mathbb E[C]\) by nearly 2%.</p>
<p>The Java program imports the SSJ packages <code>rng</code> and <code>stat</code>. It uses only two types of objects from SSJ: a <code>RandomStream</code> object, defined in the <code>rng</code> package, that generates a stream of independent random numbers from the uniform distribution, and a <code>Tally</code> object, from the <code>stat</code> package, to collect statistical observations and produce the report. In SSJ, <code>RandomStream</code> is actually just an interface that specifies all the methods that must be provided by its different implementations, which correspond to different brands of random streams (i.e., different types of uniform random number generators). The class <code>MRG32k3a</code>, whose constructor is invoked in the main program, is one such implementation of <code>RandomStream</code>. This is the one we use here. The class <code>Tally</code> provides the simplest type of statistical collector. It receives observations one by one, and after each new observation, it updates the number, average, variance, minimum, and maximum of the observations. At any time, it can return these statistics or compute a confidence interval for the theoretical mean of these observations, assuming that they are independent and identically distributed with the normal distribution. Other types of collectors that memorize the observations are also available in SSJ.</p>
<p><b>Simulating the number of collisions in a hashing system</b> &emsp;[Collision] <a class="anchor" id="REF_examples_lst_Collision"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Collision {</div><div class="line">   <span class="keywordtype">int</span> k;            <span class="comment">// Number of locations.</span></div><div class="line">   <span class="keywordtype">int</span> m;            <span class="comment">// Number of items.</span></div><div class="line">   <span class="keywordtype">double</span> lambda;    <span class="comment">// Theoretical expectation of C (asymptotic).</span></div><div class="line">   <span class="keywordtype">boolean</span>[] used;   <span class="comment">// Locations already used.</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> Collision (<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> m) {</div><div class="line">      this.k = k;</div><div class="line">      this.m = m;</div><div class="line">      lambda = (double) m * m / (2.0 * k);</div><div class="line">      used = <span class="keyword">new</span> <span class="keywordtype">boolean</span>[k];</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates and returns the number of collisions.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">int</span> generateC (RandomStream stream) {</div><div class="line">      <span class="keywordtype">int</span> C = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k; i++) used[i] = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++) {</div><div class="line">         <span class="keywordtype">int</span> loc = stream.nextInt (0, k-1);</div><div class="line">         <span class="keywordflow">if</span> (used[loc]) C++;</div><div class="line">         <span class="keywordflow">else</span> used[loc] = <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> C;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n indep. runs using stream and collects statistics in statC.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, RandomStream stream, Tally statC) {</div><div class="line">      statC.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) statC.add (generateC (stream));</div><div class="line">      statC.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statC.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot; Theoretical mean: &quot;</span> + lambda);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      Tally statC = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Statistics on collisions&quot;</span>);</div><div class="line">      Collision col = <span class="keyword">new</span> Collision (10000, 500);</div><div class="line">      col.simulateRuns (100000, <span class="keyword">new</span> MRG32k3a(), statC);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The class <code>Collision</code> offers the facilities to simulate copies of \(C\). Its constructor specifies \(k\) and \(m\), computes \(\lambda\), and constructs a boolean array of size \(k\) to memorize the locations used so far, in order to detect the collisions. The method <code>generateC</code> initializes the boolean array to <code>false</code>, generates the \(m\) locations, and computes \(C\). The method <code>simulateRuns</code> first resets the statistical collector <code>statC</code>, then generates \(n\) independent copies of \(C\) and pass these \(n\) observations to the collector via the method <code>add</code>. The method <code>statC.report</code> computes a confidence interval from these \(n\) observations and returns a statistical report in the form of a character string. This report is printed, together with the value of \(\lambda\).</p>
<p><b>Results of the program <code>Collision</code></b> &emsp;[Collision] <a class="anchor" id="REF_examples_res_Collision"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; Statistics on collisions</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">    100000        1.000       29.000       12.271        3.380</div><div class="line">  95.0% confidence interval <span class="keywordflow">for</span> mean (student): (    12.250,    12.292 )</div><div class="line"></div><div class="line"> Theoretical mean: 12.5</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_nonuniform"></a>
Nonuniform variate generation and simple quantile estimates</h2>
<p>The program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Nonuniform">Nonuniform</a> simulates the following artificial model. Define the random variable </p><p class="formulaDsp">
\[ X = Y_1 + \cdots+ Y_N + W_1 + …+ W_M, \]
</p>
<p> where \(N\) is Poisson with mean \(\lambda\), \(M\) is geometric with parameter \(p\), the \(Y_j\)’s are gamma with parameters \((\alpha, \beta)\), the \(W_j\)’s are lognormal with parameters \((\mu,\sigma)\), and all these random variables are independent. We want to generate \(n\) copies of \(X\), say \(X_1,…,X_n\), and estimate the 0.10, 0.50, 0.90, and 0.99 quantiles of the distribution of \(X\), simply from the quantiles of the empirical distribution.</p>
<p>The method <code>simulateRuns</code> generates \(n\) copies of \(X\) and pass them to a statistical collector of class <code>TallyStore</code>, that stores the individual observations. These observations are sorted in increasing order by invoking <code>quickSort</code>, and the appropriate empirical quantiles are printed, together with a short report.</p>
<p><b>Simulating nonuniform variates and observing quantiles</b> &emsp;[Nonuniform] <a class="anchor" id="REF_examples_lst_Nonuniform"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Nonuniform {</div><div class="line">   <span class="comment">// The parameter values are hardwired here to simplify the program.</span></div><div class="line">   <span class="keywordtype">double</span> lambda = 5.0;   <span class="keywordtype">double</span> p = 0.2;</div><div class="line">   <span class="keywordtype">double</span> alpha = 2.0;    <span class="keywordtype">double</span> beta = 1.0;</div><div class="line">   <span class="keywordtype">double</span> mu = 5.0;       <span class="keywordtype">double</span> sigma = 1.0;</div><div class="line"></div><div class="line">   RandomStream stream = <span class="keyword">new</span> LFSR113();</div><div class="line">   RandomVariateGenInt genN = <span class="keyword">new</span> RandomVariateGenInt</div><div class="line">          (stream, <span class="keyword">new</span> PoissonDist (lambda));       <span class="comment">// For N</span></div><div class="line">   RandomVariateGen genY = <span class="keyword">new</span> GammaAcceptanceRejectionGen</div><div class="line">          (stream, <span class="keyword">new</span> GammaDist (alpha, beta));    <span class="comment">// For Y_j</span></div><div class="line">   RandomVariateGen genW = <span class="keyword">new</span> RandomVariateGen</div><div class="line">          (stream, <span class="keyword">new</span> LognormalDist (mu, sigma));  <span class="comment">// For W_j</span></div><div class="line"></div><div class="line">   <span class="comment">// Generates and returns X.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> generateX () {</div><div class="line">      <span class="keywordtype">int</span> N;  <span class="keywordtype">int</span> M;  <span class="keywordtype">int</span> j;  <span class="keywordtype">double</span> X = 0.0;</div><div class="line">      N = genN.nextInt();</div><div class="line">      M = GeometricDist.inverseF (p, stream.nextDouble());  <span class="comment">// Uses static method</span></div><div class="line">      <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) X += genY.nextDouble();</div><div class="line">      <span class="keywordflow">for</span> (j = 0; j &lt; M; j++) X += genW.nextDouble();</div><div class="line">      <span class="keywordflow">return</span> X;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n indep. runs and collects statistics in statX.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n) {</div><div class="line">      TallyStore statX = <span class="keyword">new</span> TallyStore (n);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) statX.add (generateX ());</div><div class="line">      System.out.println (statX.report ());</div><div class="line">      statX.quickSort();</div><div class="line">      <span class="keywordtype">double</span>[] data = statX.getArray();</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;0.10 quantile: %9.3f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.10 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;0.50 quantile: %9.3f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.50 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;0.90 quantile: %9.3f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.90 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;0.99 quantile: %9.3f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.99 * n)]);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      (<span class="keyword">new</span> Nonuniform ()).simulateRuns (10000);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p><b>Results of the program <code>Nonuniform</code></b> &emsp;[Nonuniform] <a class="anchor" id="REF_examples_res_Nonuniform"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; null</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">     10000        0.000    15839.396     1000.890     1285.771</div><div class="line"></div><div class="line">0.10 quantile:     9.485</div><div class="line">0.50 quantile:   545.338</div><div class="line">0.90 quantile:  2628.177</div><div class="line">0.99 quantile:  5860.238</div></div><!-- fragment --><p>To simplify the program, all the parameters are fixed as constants at the beginning of the class. This is simpler, but not recommended in general because it does not permit one to perform experiments with different parameter sets in a single program. Passing the parameters to the constructor as in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Collision">Collision</a> would require more lines of code, but would provide more flexibility.</p>
<p>The class initialization also constructs a <code>RandomStream</code> of type <code>LFSR113</code> (this is a faster uniform generator that <code>MRG32k3a</code>), used to generate all the random numbers. For the generation of \(N\), we construct a Poisson distribution with mean \(\lambda\) (without giving it a name), and pass it together with the random stream to the constructor of class <code>PoissonGen</code>. The returned object <code>genN</code> is random number generator that generate Poisson random variables with mean \(\lambda\), via inversion. As similar procedure is used to construct <code>genY</code> and <code>genW</code>, which generate gamma and lognormal random variates, respectively. Note that a <code>RandomVariateGenInt</code> produces integer-valued random variates, while a <code>RandomVariateGen</code> produces real-valued random variates. For the gamma distribution, we use a special type of random number generator based on a rejection method, which is faster than inversion. These constructors precompute some (hidden) constants once for all, to speedup the random variate generation. For the Poisson distribution with mean \(\lambda\), the constructor of <code>PoissonDist</code> actually precomputes the distribution function in a table, and uses this table to compute the inverse distribution function each time a Poisson random variate needs to be generated with this particular distribution. This is possible because all Poisson random variates have the same parameter \(\lambda\). If a different \(\lambda\) was used for each variate, then we would use the static method of <code>PoissonDist</code> instead of constructing a Poisson distribution, otherwise we would have to reconstruct the distribution each time. The static method reconstructs part of the table each time, with the given \(\lambda\), so it is slower if we want to generate several Poisson variates with the same \(\lambda\). As an illustration, we use the static method to generate the geometric random variates (in <code>generateX</code>), instead of constructing a geometric distribution and variate generator. To generate \(M\), we invoke the static method <code>inverseF</code> of the class <code>GeometricDist</code>, which evaluates the inverse geometric distribution function for a given parameter \(p\) and a given uniform random variate.</p>
<p>The results of this program, with \(n = 10000\), are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Nonuniform">Nonuniform</a>. We see that \(X\) has a coefficient of variation larger than 1, and the quantiles indicate that the distribution is skewed, with a long thick tail to the right. We have \(X &lt; 553\) about half the time, but values over several thousands are not uncommon. This probably happens when \(N\) or \(M\) takes a large value. There are also cases where \(N=M=0\), in which case \(X=0\).</p>
<h2><a class="anchor" id="REF_examples_sec_inventory"></a>
A discrete-time inventory system</h2>
<p>Consider a simple inventory system where the demands for a given product on successive days are independent Poisson random variables with mean \(\lambda\). If \(X_j\) is the stock level at the beginning of day \(j\) and \(D_j\) is the demand on that day, then there are \(\min(D_j, X_j)\) sales, \(\max(0, D_j - X_j)\) lost sales, and the stock at the end of the day is \(Y_j = \max(0, X_j - D_j)\). There is a revenue \(c\) for each sale and a cost \(h\) for each unsold item at the end of the day. The inventory is controlled using a \((s,S)\) policy: If \(Y_j &lt; s\), order \(S - Y_j\) items, otherwise do not order. When an order is made in the evening, with probability \(p\) it arrives during the night and can be used for the next day, and with probability \(1-p\) it never arrives (in which case a new order will have to be made the next evening). When the order arrives, there is a fixed cost \(K\) plus a marginal cost of \(k\) per item. The stock at the beginning of the first day is \(X_0 = S\).</p>
<p>We want to simulate this system for \(m\) days, for a given set of parameters and a given control policy \((s,S)\), and replicate this simulation \(n\) times independently to estimate the expected profit per day over a time horizon of \(m\) days. Eventually, we might want to <em>optimize</em> the values of the decision parameters \((s,S)\) via simulation, but we do not do that here. (In practice, this is usually done for more complicated models.)</p>
<p><b>A simulation program for the simple inventory system</b> &emsp;[Inventory] <a class="anchor" id="REF_examples_lst_Inventory"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1PoissonDist.html">PoissonDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Inventory {</div><div class="line"></div><div class="line">   <span class="keywordtype">double</span> lambda;  <span class="comment">// Mean demand size.</span></div><div class="line">   <span class="keywordtype">double</span> c;       <span class="comment">// Sale price.</span></div><div class="line">   <span class="keywordtype">double</span> h;       <span class="comment">// Inventory cost per item per day.</span></div><div class="line">   <span class="keywordtype">double</span> K;       <span class="comment">// Fixed ordering cost.</span></div><div class="line">   <span class="keywordtype">double</span> k;       <span class="comment">// Marginal ordering cost per item.</span></div><div class="line">   <span class="keywordtype">double</span> p;       <span class="comment">// Probability that an order arrives.</span></div><div class="line"></div><div class="line">   RandomVariateGenInt genDemand;</div><div class="line">   RandomStream streamDemand = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   RandomStream streamOrder  = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   Tally statProfit          = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stats on profit&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> Inventory (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> c, <span class="keywordtype">double</span> h,</div><div class="line">                     <span class="keywordtype">double</span> K, <span class="keywordtype">double</span> k, <span class="keywordtype">double</span> p) {</div><div class="line">      this.lambda = lambda;</div><div class="line">      this.c = c;  this.h = h;  this.K = K;  this.k = k;  this.p = p;</div><div class="line">      genDemand = <span class="keyword">new</span> PoissonGen (streamDemand, <span class="keyword">new</span> PoissonDist (lambda));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Simulates the system for m days, with the (s,S) policy,</span></div><div class="line">   <span class="comment">// and returns the average profit per day.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulateOneRun (<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> S) {</div><div class="line">      <span class="keywordtype">int</span> Xj = S, Yj;         <span class="comment">// Stock in the morning and in the evening.</span></div><div class="line">      <span class="keywordtype">double</span> profit = 0.0;    <span class="comment">// Cumulated profit.</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++) {</div><div class="line">         Yj = Xj - genDemand.nextInt(); <span class="comment">// Subtract demand for the day.</span></div><div class="line">         <span class="keywordflow">if</span> (Yj &lt; 0) Yj = 0;            <span class="comment">// Lost demand.</span></div><div class="line">         profit += c * (Xj - Yj) - h * Yj;</div><div class="line">         <span class="keywordflow">if</span> ((Yj &lt; s) &amp;&amp; (streamOrder.nextDouble() &lt; p)) {</div><div class="line">            <span class="comment">// We have a successful order.</span></div><div class="line">            profit -= K + k * (S - Yj);</div><div class="line">            Xj = S;</div><div class="line">         } <span class="keywordflow">else</span></div><div class="line">            Xj = Yj;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> profit / m;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n independent simulation runs of the system for m days,</span></div><div class="line">   <span class="comment">// with the (s,S) policy, and returns a report with a 90% confidence</span></div><div class="line">   <span class="comment">// interval on the expected average profit per day.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> S) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line">         statProfit.add (simulateOneRun (m, s, S));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      Inventory system = <span class="keyword">new</span> Inventory (100.0, 2.0, 0.1, 10.0, 1.0, 0.95);</div><div class="line">      system.simulateRuns (500, 2000, 80, 200);</div><div class="line">      system.statProfit.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (system.statProfit.report (0.9, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Inventory">Inventory</a> gives a Java program, based on the SSJ library, that performs the required simulation for \(n=500\), \(m=2000\), \(s=80\), \(S=200\), \(\lambda=100\), \(c=2\), \(h=0.1\), \(K=10\), \(k=1\), and \(p=0.95\).</p>
<p>The <code>import</code> statements at the beginning of the program retrieve the SSJ packages/classes that are needed. The <code>Inventory</code> class has a constructor that initializes the model parameters (saving their values in class variables) and constructs the required random number generators and the statistical collector. To generate the demands \(D_j\) on successive days, we create (in the last line of the constructor) a random number stream and a Poisson distribution with mean \(\lambda\), and then a Poisson random variate generator <code>genDemand</code> that uses this stream and this distribution. This mechanism will (automatically) precompute tables to ensure that the Poisson variate generation is efficient. This can be done because the value of \(\lambda\) does not change during the simulation. The random number stream <code>streamOrder</code>, used to decide which orders are received, and the statistical collector <code>statProfit</code>, are also created when the <code>Inventory</code> constructor is invoked. The code that invokes their constructors is outside the <code>Inventory</code> constructor, but it could have been inside as well. On the other hand, <code>genDemand</code> must be constructed inside the <code>Inventory</code> constructor, because the value of \(\lambda\) is not yet defined outside. The <em>random number streams</em> can be viewed as virtual random number generators that generate random numbers in the interval \([0,1)\) according to the uniform probability distribution.</p>
<p>The method <code>simulateOneRun</code> simulates the system for \(m\) days, with a given policy, and returns the average profit per day. For each day, we generate the demand \(D_j\), compute the stock \(Y_j\) at the end of the day, and add the sales revenues minus the leftover inventory costs to the profit. If \(Y_j &lt; s\), we generate a uniform random variable \(U\) over the interval \((0,1)\) and an order of size \(S - Y_j\) is received the next morning if \(U &lt; p\) (that is, with probability \(p\)). In case of a successful order, we pay for it and the stock level is reset to \(S\).</p>
<p>The method <code>simulateRuns</code> performs \(n\) independent simulation runs of this system and returns a report that contains a 90% confidence interval for the expected profit. The main program constructs an <code>Inventory</code> object with the desired parameters, asks for \(n\) simulation runs, and prints the report. It also creates a timer that computes the total CPU time to execute the program, and prints it. The results are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Inventory">Inventory</a>. The average profit per day is approximately 85. It took 0.39 seconds (on a 2.4 GHz computer running Linux) to simulate the system for 2000 days, compute the statistics, and print the results.</p>
<p><b>Results of the program <code>Inventory</code></b> &emsp;[Inventory] <a class="anchor" id="REF_examples_res_Inventory"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; stats on profit</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">       500       83.969       85.753       84.961        0.324</div><div class="line">  90.0% confidence interval <span class="keywordflow">for</span> mean (student): (    84.938,    84.985 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.14</div></div><!-- fragment --><p>In Listing&#160; <a class="el" href="examples.html#REF_examples_lst_InventoryCRN">InventoryCRN</a>, we extend the <code>Inventory</code> class to a class <code>InventoryCRN</code> that compares two sets of values of the inventory control policy parameters \((s,S)\).</p>
<p><b>Comparing two inventory policies with common random numbers</b> &emsp;[InventoryCRN] <a class="anchor" id="REF_examples_lst_InventoryCRN"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>InventoryCRN <span class="keyword">extends</span> Inventory {</div><div class="line"></div><div class="line">   Tally statDiff = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stats on difference&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> InventoryCRN (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> c, <span class="keywordtype">double</span> h,</div><div class="line">                        <span class="keywordtype">double</span> K, <span class="keywordtype">double</span> k, <span class="keywordtype">double</span> p) {</div><div class="line">      super (lambda, c, h, K, k, p);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDiff (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s1, <span class="keywordtype">int</span> S1, <span class="keywordtype">int</span> s2, <span class="keywordtype">int</span> S2) {</div><div class="line">      statDiff.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div><div class="line">         <span class="keywordtype">double</span> value1 = simulateOneRun (m, s1, S1);</div><div class="line">         <span class="keywordtype">double</span> value2 = simulateOneRun (m, s2, S2);</div><div class="line">         statDiff.add (value2 - value1);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDiffCRN (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s1, <span class="keywordtype">int</span> S1, <span class="keywordtype">int</span> s2, <span class="keywordtype">int</span> S2) {</div><div class="line">      statDiff.init();</div><div class="line">      streamDemand.resetStartStream();</div><div class="line">      streamOrder.resetStartStream();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div><div class="line">         <span class="keywordtype">double</span> value1 = simulateOneRun (m, s1, S1);</div><div class="line">         streamDemand.resetStartSubstream();</div><div class="line">         streamOrder.resetStartSubstream();</div><div class="line">         <span class="keywordtype">double</span> value2 = simulateOneRun (m, s2, S2);</div><div class="line">         statDiff.add (value2 - value1);</div><div class="line">         streamDemand.resetNextSubstream();</div><div class="line">         streamOrder.resetNextSubstream();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      InventoryCRN system = <span class="keyword">new</span> InventoryCRN (100.0, 2.0, 0.1, 10.0, 1.0, 0.95);</div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line"></div><div class="line">      system.simulateDiff (5000, 200, 80, 198, 80, 200);</div><div class="line">      system.statDiff.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (system.statDiff.report (0.9, 3));</div><div class="line">      <span class="keywordtype">double</span> varianceIndep = system.statDiff.variance();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"></div><div class="line">      timer.init();</div><div class="line">      system.simulateDiffCRN (5000, 200, 80, 198, 80, 200);</div><div class="line">      System.out.println (system.statDiff.report (0.9, 3));</div><div class="line">      <span class="keywordtype">double</span> varianceCRN = system.statDiff.variance();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Variance ratio:  %8.4g%n&quot;</span>, varianceIndep/varianceCRN);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The method <code>simulateDiff</code> simulates the system with policies \((s_1, S_1)\) and \((s_2, S_2)\) independently, computes the difference in profits, and repeats this \(n\) times. These \(n\) differences are tallied in statistical collector <code>statDiff</code>, to estimate the expected difference in average daily profits between the two policies.</p>
<p>The method <code>simulateDiffCRN</code> does the same, but using <em>common random numbers</em> across pairs of simulation runs. After running the simulation with policy \((s_1, S_1)\), the two random number streams are reset to the start of their current substream, so that they produce exactly the same sequence of random numbers when the simulation is run with policy \((s_2, S_2)\). Then the difference in profits is given to the statistical collector <code>statDiff</code> as before and the two streams are reset to a new substream for the next pair of simulations.</p>
<p>Why not use the same stream for both the demands and orders? In this example, we need one random number to generate the demand each day, and also one random number to know if the order arrives, but only on the days where we make an order. These days where we make an order are not necessarily the same for the two policies. So if we use a single stream for both the demands and orders, the random numbers will not necessarily be used for the same purpose across the two policies: a random number used to decide if the order arrives in one case may end up being used to generate a demand in the other case. This can greatly diminish the power of the common random numbers technology. Using two different streams as in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_InventoryCRN">InventoryCRN</a> ensures at least that the random numbers are used for the same purpose for the two policies. For more explanations and examples about common random numbers, see <a class="el" href="citelist.html#CITEREF_sLAW00a">[111]</a>, <a class="el" href="citelist.html#CITEREF_sLEC09a">[119]</a>&thinsp;.</p>
<p>The main program estimates the expected difference in average daily profits for policies \((s_1, S_1) = (80, 198)\) and \((s_2, S_2) = (80, 200)\), first with independent random numbers, then with common random numbers. The other parameters are the same as before. The results are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_InventoryCRN">InventoryCRN</a>. We see that use of common random numbers reduces the variance by a factor of approximately 19 in this case.</p>
<p><b>Results of the program <code>InventoryCRN</code></b> &emsp;[InventoryCRN] <a class="anchor" id="REF_examples_res_InventoryCRN"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; stats on difference</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">      5000       -4.961        5.737        0.266        1.530</div><div class="line">  90.0% confidence interval <span class="keywordflow">for</span> mean (student): (     0.230,     0.302 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.19</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; stats on difference</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">      5000       -1.297        2.124        0.315        0.352</div><div class="line">  90.0% confidence interval for mean (student): (     0.307,     0.324 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.16</div><div class="line">Variance ratio:     18.85</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_queue_lindley"></a>
A single-server queue with Lindley’s recurrence</h2>
<p>We consider here a <em>single-server queue</em>, where customers arrive randomly and are served one by one in their order of arrival, i.e., <em>first in, first out</em> (FIFO). We suppose that the times between successive arrivals are exponential random variables with mean \(1/\lambda\), that the service times are exponential random variables with mean \(1/\mu\), and that all these random variables are mutually independent. The customers arriving while the server is busy must join the queue. The system initially starts empty. We want to simulate the first \(m\) customers in the system and compute the mean waiting time per customer.</p>
<p>This simple model is well-known in queuing theory: It is called an \(M/M/1\) queue. Simple formulas are available for this model to compute the average waiting time per customer, average queue length, etc., over an <em>infinite</em> time horizon <a class="el" href="citelist.html#CITEREF_pKLE75a">[102]</a>&thinsp;. For a finite number of customers or a finite time horizon, these expectations can also be computed by numerical methods, but here we just want to show how it can be simulated.</p>
<p>In a single-server queue, if \(W_i\) and \(S_i\) are the waiting time and service time of the \(i\)th customer, and \(A_i\) is the time between the arrivals of the \(i\)th and \((i+1)\)th customers, we have \(W_1=0\) and the \(W_i\)’s follow the recurrence <a class="anchor" id="REF_examples_examples_eq_lindley"></a> </p><p class="formulaDsp">
\[ W_{i+1} = \max(0,\; W_i + S_i - A_i), \tag{lindley} \]
</p>
<p> known as <em>Lindley’s equation</em> <a class="el" href="citelist.html#CITEREF_pKLE75a">[102]</a>&thinsp;.</p>
<p><b>A simulation based on Lindley’s recurrence</b> &emsp;[QueueLindley] <a class="anchor" id="REF_examples_lst_QueueLindley"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1ExponentialDist.html">ExponentialDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueLindley {</div><div class="line"></div><div class="line">   RandomStream streamArr  = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   RandomStream streamServ = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   Tally averageWaits = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average waits&quot;</span>);</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulateOneRun (<span class="keywordtype">int</span> numCust, <span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      <span class="keywordtype">double</span> Wi = 0.0;</div><div class="line">      <span class="keywordtype">double</span> sumWi = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt;= numCust; i++) {</div><div class="line">         Wi += ExponentialDist.inverseF (mu, streamServ.nextDouble()) -</div><div class="line">               ExponentialDist.inverseF (lambda, streamArr.nextDouble());</div><div class="line">         <span class="keywordflow">if</span> (Wi &lt; 0.0) Wi = 0.0;</div><div class="line">         sumWi += Wi;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> sumWi / numCust;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> numCust, <span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      averageWaits.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)</div><div class="line">      averageWaits.add (simulateOneRun (numCust, lambda, mu));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { </div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      QueueLindley queue = <span class="keyword">new</span> QueueLindley();</div><div class="line">      queue.simulateRuns (100, 10000, 1.0, 2.0);</div><div class="line">      System.out.println (queue.averageWaits.report());</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueLindley">QueueLindley</a> exploits ( <a class="el" href="">lindley</a> ) to compute the average waiting time of the first \(m\) customers in the queue, repeats it \(n\) times independently, and prints a summary of the results. Here, for a change, we pass the model parameters to the methods instead of to the constructor, and the random variates are generated by static methods instead of via a <code>RandomVariateGen</code> object as in the <em>Inventory</em> class (previous example). This illustrates various ways of doing the same thing. The instruction “<code>Wi += …</code>” could also be replaced by</p>
<div class="fragment"><div class="line">Wi += - Math.log (1.0 - streamServ.nextDouble()) / mu</div><div class="line">      + Math.log (1.0 - streamArr.nextDouble()) / lambda;</div></div><!-- fragment --><p>which directly implements inversion of the exponential distribution.</p>
<h2><a class="anchor" id="REF_examples_sec_observer"></a>
Using the observer design pattern</h2>
<p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueObs">QueueObs</a> adds a few ingredients to the program <code>QueueLindley</code>, in order to illustrate the <em>observer</em> design pattern implemented in package <code>stat</code>. This mechanism permits one to separate data generation from data processing. It can be very helpful in large simulation programs or libraries, where different objects may need to process the same data in different ways. These objects may have the task of storing observations or displaying statistics in different formats, for example, and they are not necessarily fixed in advance.</p>
<p>The <em>observer</em> pattern, supported by the <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> interface in SSJ, offers the appropriate flexibility for that kind of situation. A statistical probe maintains a list of registered <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> objects, and broadcasts information to all its registered observers whenever appropriate. Any object that implements the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> can register as an observer.</p>
<p><code>StatProbe</code> in package <code>stat</code>, as well as its subclasses <code>Tally</code> and <code>Accumulate</code>, contains a list of <code>ObservationListener</code>’s. Whenever they receive a new statistical observation, e.g., via <code>Tally.add</code> or <code>Accumulate.update</code>, they send the new value to all registered observers. To register as an observer, an object must implement the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> This implies that it must provide an implementation of the method <code>newObservation</code>, whose purpose is to recover the information that the object has registered for.</p>
<p>In the example, the statistical collector <code>waitingTimes</code> transmits to all its registered listeners each new statistical observation that it receives via its <code>add</code> method. More specifically, each call to <code>waitingTimes.add(x)</code> generates in the background a call to <code>o.newObservation(waitingTimes, x)</code> for all registered observers <code>o</code>.</p>
<p>The method <code>notifyObs</code> is used to turn the tally into such an agency. In fact, the collector is both a tally and a distribution agency, but its tally functionality can be disabled using the <code>stopCollectStat</code> method. This can be useful when the registered observers already perform statistical collection.</p>
<p>Two observers register to receive observations from <code>waitingTimes</code> in the example. They are anonymous objects of classes <code>ObservationTrace</code> and <code>LargeWaitsCollector</code>, respectively. Each one is informed of any new observation \(W_i\) via its <code>newObservation</code> method. The task of the <code>ObservationTrace</code> observer is to print the waiting times \(W_5\), \(W_{10}\), \(W_{15}\), …, whereas the <code>LargeWaitsCollector</code> observer stores in an array all waiting times that exceed 2. The statistical collector <code>waitingTimes</code> itself also stores appropriate information to be able to provide a statistical report when required.</p>
<p>The <code>ObservationListener</code> interface specifies that <code>newObservation</code> must have two formal parameters, of classes <code>StatProbe</code> and <code>double</code>, respectively. The second parameter is the value of the observation. In the case where the observer registers to several <code>ObservationListener</code> objects, the first parameter of <code>newObservation</code> tells it which one is sending the information, so it can adopt the correct behavior for this sender.</p>
<p><b>A simulation of Lindley’s recurrence using observers</b> &emsp;[QueueObs] <a class="anchor" id="REF_examples_lst_QueueObs"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueObs {</div><div class="line"></div><div class="line">   Tally waitingTimes = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times&quot;</span>);</div><div class="line">   Tally averageWaits = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average wait&quot;</span>);</div><div class="line">   RandomVariateGen genArr;</div><div class="line">   RandomVariateGen genServ;</div><div class="line">   <span class="keywordtype">int</span> cust;    <span class="comment">// Number of the current customer.</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> QueueObs (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu, <span class="keywordtype">int</span> step) {</div><div class="line">      genArr = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), lambda);</div><div class="line">      genServ = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), mu);</div><div class="line">      waitingTimes.setBroadcasting (<span class="keyword">true</span>);</div><div class="line">      waitingTimes.addObservationListener (<span class="keyword">new</span> ObservationTrace (step));</div><div class="line">      waitingTimes.addObservationListener (<span class="keyword">new</span> LargeWaitsCollector (2.0));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulateOneRun (<span class="keywordtype">int</span> numCust) {</div><div class="line">      waitingTimes.init();</div><div class="line">      <span class="keywordtype">double</span> Wi = 0.0;</div><div class="line">      waitingTimes.add (Wi);</div><div class="line">      <span class="keywordflow">for</span> (cust = 2; cust &lt;= numCust; cust++) {</div><div class="line">         Wi += genServ.nextDouble() - genArr.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (Wi &lt; 0.0) Wi = 0.0;</div><div class="line">         waitingTimes.add (Wi);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> waitingTimes.average();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> numCust) {</div><div class="line">      averageWaits.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)</div><div class="line">      averageWaits.add (simulateOneRun (numCust));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>ObservationTrace <span class="keyword">implements</span> ObservationListener {</div><div class="line">      <span class="keyword">private</span> <span class="keywordtype">int</span> step;</div><div class="line"></div><div class="line">      <span class="keyword">public</span> ObservationTrace (<span class="keywordtype">int</span> step) { this.step = step; }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="classtutorial_1_1QueueObs_1_1ObservationTrace.html#a08e03181ba7d3c28fdd37b757e792f21">newObservation</a> (StatProbe probe, <span class="keywordtype">double</span> x) {</div><div class="line">         <span class="keywordflow">if</span> (cust % step == 0)</div><div class="line">            System.out.println (<span class="stringliteral">&quot;Customer &quot;</span> + cust + <span class="stringliteral">&quot; waited &quot;</span> </div><div class="line">                   + x + <span class="stringliteral">&quot; time units.&quot;</span>);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>LargeWaitsCollector <span class="keyword">implements</span> ObservationListener {</div><div class="line">      <span class="keywordtype">double</span> threshold;</div><div class="line">      ArrayList&lt;Double&gt; largeWaits = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line"></div><div class="line">      <span class="keyword">public</span> LargeWaitsCollector (<span class="keywordtype">double</span> threshold) {</div><div class="line">         this.threshold = threshold;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="classtutorial_1_1QueueObs_1_1ObservationTrace.html#a08e03181ba7d3c28fdd37b757e792f21">newObservation</a> (StatProbe probe, <span class="keywordtype">double</span> x) {</div><div class="line">         <span class="keywordflow">if</span> (x &gt; threshold) largeWaits.add (x);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> String formatLargeWaits () {</div><div class="line">      <span class="comment">// Should print the list largeWaits. </span></div><div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;not yet implemented...&quot;</span>;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { </div><div class="line">      QueueObs queue = <span class="keyword">new</span> QueueObs (1.0, 2.0, 5);</div><div class="line">      queue.simulateRuns (2, 100);</div><div class="line">      System.out.println (<span class="stringliteral">&quot;\n\n&quot;</span> + queue.averageWaits.report());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_asian"></a>
Pricing an Asian option</h2>
<p>A <em>geometric Brownian motion</em> (GBM) \(\{S(\zeta), \zeta\ge0\}\) satisfies </p><p class="formulaDsp">
\[ S(\zeta) = S(0) \exp\left[(r - \sigma^2/2)\zeta+ \sigma B(\zeta)\right] \]
</p>
<p> where \(r\) is the <em>risk-free appreciation rate</em>, \(\sigma\) is the <em>volatility parameter</em>, and \(B\) is a standard Brownian motion, i.e., a stochastic process whose increments over disjoint intervals are independent normal random variables, with mean 0 and variance \(\delta\) over an interval of length \(\delta\) (see, e.g., <a class="el" href="citelist.html#CITEREF_fGLA04a">[64]</a>&thinsp;). The GBM process is a popular model for the evolution in time of the market price of financial assets. A discretely-monitored <em>Asian option</em> on the arithmetic average of a given asset has discounted payoff <a class="anchor" id="REF_examples_examples_eq_payasian"></a> </p><p class="formulaDsp">
\[ \tag{payasian} X = e^{-rT} \max[\bar{S} - K,  0] \]
</p>
<p> where \(K\) is a constant called the <em>strike price</em> and <a class="anchor" id="REF_examples_examples_eq_arithmetic_average"></a> </p><p class="formulaDsp">
\[ \tag{arithmetic-average} \bar{S} = \frac{1}{t} \sum_{j=1}^t S(\zeta_j), \]
</p>
<p> for some fixed observation times \(0 &lt; \zeta_1 &lt; \cdots&lt; \zeta_t = T\). The value (or fair price) of the Asian option is \(c = E[X]\) where the expectation is taken under the so-called risk-neutral measure (which means that the parameters \(r\) and \(\sigma\) have to be selected in a particular way; see <a class="el" href="citelist.html#CITEREF_fGLA04a">[64]</a>&thinsp;).</p>
<p>This value \(c\) can be estimated by simulation as follows. Generate \(t\) independent and identically distributed (i.i.d.) \(N(0,1)\) random variables \(Z_1,…,Z_t\) and put \(B(\zeta_j) = B(\zeta_{j-1}) + \sqrt{\zeta_j - \zeta_{j-1}} Z_j\), for \(j=1,…,t\), where \(B(\zeta_0) = \zeta_0 = 0\). Then, <a class="anchor" id="REF_examples_examples_eq_Szetaj"></a> </p><p class="formulaDsp">
\[ S(\zeta_j) = S(0) e^{(r-\sigma^2/2)\zeta_j + \sigma B(\zeta_j)} = S(\zeta_{j-1}) e^{(r-\sigma^2/2)(\zeta_j-\zeta_{j-1}) + \sigma\sqrt{\zeta_j - \zeta_{j-1}} Z_j} \tag{Szetaj} \]
</p>
<p> for \(j = 1,…,t\) and the payoff can be computed via ( <a class="el" href="">payasian</a> ). This can be replicated \(n\) times, independently, and the option value is estimated by the average discounted payoff. The Java program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Asian">Asian</a> implement this procedure.</p>
<p>Note that generating the sample path and computing the payoff is done in two different methods. This way, other methods could eventually be added to compute payoffs that are defined differently (e.g., based on the geometric average, or with barriers, etc.) over the same generated sample path.</p>
<p><b>Pricing an Asian option on a GMB process</b> &emsp;[Asian] <a class="anchor" id="REF_examples_lst_Asian"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.<a class="code" href="classjava_1_1io_1_1IOException.html">IOException</a>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1NormalDist.html">NormalDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Asian {</div><div class="line">   <span class="keywordtype">double</span> strike;    <span class="comment">// Strike price.</span></div><div class="line">   <span class="keywordtype">int</span> s;            <span class="comment">// Number of observation times.</span></div><div class="line">   <span class="keywordtype">double</span> discount;  <span class="comment">// Discount factor exp(-r * zeta[t]).</span></div><div class="line">   <span class="keywordtype">double</span>[] muDelta; <span class="comment">// Differences * (r - sigma^2/2).</span></div><div class="line">   <span class="keywordtype">double</span>[] sigmaSqrtDelta; <span class="comment">// Square roots of differences * sigma.</span></div><div class="line">   <span class="keywordtype">double</span>[] logS;    <span class="comment">// Log of the GBM process: logS[t] = log (S[t]).</span></div><div class="line"></div><div class="line">   <span class="comment">// Array zeta[0..s] must contain zeta[0]=0.0, plus the s observation times.</span></div><div class="line">   <span class="keyword">public</span> Asian (<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> strike,</div><div class="line">                 <span class="keywordtype">double</span> s0, <span class="keywordtype">int</span> s, <span class="keywordtype">double</span>[] zeta) {</div><div class="line">      this.strike = strike;</div><div class="line">      this.s = s;</div><div class="line">      discount = Math.exp (-r * zeta[s]);</div><div class="line">      <span class="keywordtype">double</span> mu = r - 0.5 * sigma * sigma;</div><div class="line">      muDelta = <span class="keyword">new</span> <span class="keywordtype">double</span>[s];</div><div class="line">      sigmaSqrtDelta = <span class="keyword">new</span> <span class="keywordtype">double</span>[s];</div><div class="line">      logS = <span class="keyword">new</span> <span class="keywordtype">double</span>[s+1];</div><div class="line">      <span class="keywordtype">double</span> delta;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; s; j++) {</div><div class="line">         delta = zeta[j+1] - zeta[j];</div><div class="line">         muDelta[j] = mu * delta;</div><div class="line">         sigmaSqrtDelta[j] = sigma * Math.sqrt (delta);</div><div class="line">      }</div><div class="line">      logS[0] = Math.log (s0);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates the process S.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> generatePath (RandomStream stream) {</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; s; j++)</div><div class="line">          logS[j+1] = logS[j] + muDelta[j] + sigmaSqrtDelta[j]</div><div class="line">                   * NormalDist.inverseF01 (stream.nextDouble());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Computes and returns the discounted option payoff.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> getPayoff () {</div><div class="line">       <span class="keywordtype">double</span> average = 0.0;  <span class="comment">// Average of the GBM process.</span></div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= s; j++) average += Math.exp (logS[j]);</div><div class="line">       average /= s;</div><div class="line">       <span class="keywordflow">if</span> (average &gt; strike) <span class="keywordflow">return</span> discount * (average - strike);</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n indep. runs using stream and collects statistics in statValue.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, RandomStream stream, Tally statValue) {</div><div class="line">      statValue.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {</div><div class="line">         generatePath (stream);</div><div class="line">         statValue.add (getPayoff ());</div><div class="line">         stream.resetNextSubstream();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args)  <span class="keywordflow">throws</span> IOException {</div><div class="line">      <span class="keywordtype">int</span> s = 12;</div><div class="line">      <span class="keywordtype">double</span>[] zeta = <span class="keyword">new</span> <span class="keywordtype">double</span>[s+1];   zeta[0] = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1; j&lt;=s; j++)</div><div class="line">         zeta[j] = (<span class="keywordtype">double</span>)j / (double)s;</div><div class="line">      Asian process = <span class="keyword">new</span> Asian (0.05, 0.5, 100.0, 100.0, s, zeta);</div><div class="line">      Tally statValue = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Stats on value of Asian option&quot;</span>);</div><div class="line"></div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      <span class="keywordtype">int</span> n = 100000;</div><div class="line">      process.simulateRuns (n, <span class="keyword">new</span> MRG32k3a(), statValue);</div><div class="line">      statValue.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statValue.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time:      &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The method <code>simulateRuns</code> performs \(n\) independent simulation runs using the given random number stream and put the \(n\) observations of the net payoff in the statistical collector <code>statValue</code>. In the <code>main</code> program, we first specify the 12 observation times \(\zeta_j = j/12\) for \(j=1,…,12\), and put them in the array <code>zeta</code> (of size 13) together with \(\zeta_0=0\). We then construct an <code>Asian</code> object with parameters \(r=0.05\), \(\sigma=0.5\), \(K = 100\), \(S(0)=100\), \(t=12\), and the observation times contained in array <code>zeta</code>. We then create the statistical collector <code>statValue</code>, perform \(10^5\) simulation runs, and print the results. The discount factor \(e^{-rT}\) and the constants \(\sigma\sqrt{\zeta_j - \zeta_{j-1}}\) and \((r-\sigma^2/2)(\zeta_j - \zeta_{j-1})\) are precomputed in the constructor <code>Asian</code>, to speed up the simulation.</p>
<p>The program in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_AsianQMC">AsianQMC</a> extends the class <code>Asian</code> to <code>AsianQMC</code>, whose method <code>simulateQMC</code> estimates the option value via randomized quasi-Monte Carlo. It uses \(m\) independently randomized copies of digital net <code>p</code> and puts the results in statistical collector <code>statAverage</code>. The randomization is a left matrix scramble followed by a digital random shift, applied before each batch of \(n\) simulation runs.</p>
<p><b>Pricing an Asian option on a GMB process with quasi-Monte Carlo</b> &emsp;[AsianQMC] <a class="anchor" id="REF_examples_lst_AsianQMC"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.<a class="code" href="classjava_1_1io_1_1IOException.html">IOException</a>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1hups.html">hups</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>AsianQMC <span class="keyword">extends</span> Asian {</div><div class="line"></div><div class="line">   <span class="keyword">public</span> AsianQMC (<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> strike,</div><div class="line">                    <span class="keywordtype">double</span> s0, <span class="keywordtype">int</span> s, <span class="keywordtype">double</span>[] zeta) {</div><div class="line">       super (r, sigma, strike, s0, s, zeta);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Makes m independent randomizations of the digital net p using stream</span></div><div class="line">   <span class="comment">// noise. For each of them, performs one simulation run for each point</span></div><div class="line">   <span class="comment">// of p, and adds the average over these points to the collector statQMC.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateQMC (<span class="keywordtype">int</span> m, DigitalNet p,</div><div class="line">                            RandomStream noise, Tally statQMC) {</div><div class="line">      Tally statValue  = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stat on value of Asian option&quot;</span>);</div><div class="line">      PointSetIterator stream = p.iterator ();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;m; j++) {</div><div class="line">          p.leftMatrixScramble (noise);</div><div class="line">          p.addRandomShift (0, p.getDimension(), noise);</div><div class="line">          stream.resetStartStream();</div><div class="line">          simulateRuns (p.getNumPoints(), stream, statValue);</div><div class="line">          statQMC.add (statValue.average());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args)  <span class="keywordflow">throws</span> IOException {</div><div class="line">      <span class="keywordtype">int</span> s = 12;</div><div class="line">      <span class="keywordtype">double</span>[] zeta = <span class="keyword">new</span> <span class="keywordtype">double</span>[s+1];</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;=s; j++)</div><div class="line">         zeta[j] = (<span class="keywordtype">double</span>)j / (double)s;</div><div class="line">      AsianQMC process = <span class="keyword">new</span> AsianQMC (0.05, 0.5, 100.0, 100.0, s, zeta);</div><div class="line">      Tally statValue  = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;value of Asian option&quot;</span>);</div><div class="line">      Tally statQMC = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;QMC averages for Asian option&quot;</span>);</div><div class="line"></div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      <span class="keywordtype">int</span> n = 100000;</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Ordinary MC:\n&quot;</span>);</div><div class="line">      process.simulateRuns (n, <span class="keyword">new</span> MRG32k3a(), statValue);</div><div class="line">      statValue.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statValue.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">      <span class="keywordtype">double</span> varMC = statValue.variance();</div><div class="line">      <span class="keywordtype">double</span> cpuMC = timer.getSeconds() / n;  <span class="comment">// CPU seconds per run.</span></div><div class="line">      System.out.println (<span class="stringliteral">&quot;------------------------\n&quot;</span>);</div><div class="line"></div><div class="line">      timer.init();</div><div class="line">      DigitalNet p = <span class="keyword">new</span> SobolSequence (16, 31, s); <span class="comment">// 2^{16} points.</span></div><div class="line">      n = p.getNumPoints();</div><div class="line">      <span class="keywordtype">int</span> m = 20;                     <span class="comment">// Number of QMC randomizations.</span></div><div class="line">      process.simulateQMC (m, p, <span class="keyword">new</span> MRG32k3a(), statQMC);</div><div class="line">      System.out.println (<span class="stringliteral">&quot;QMC with Sobol point set with &quot;</span> + n +</div><div class="line">          <span class="stringliteral">&quot; points and affine matrix scramble:\n&quot;</span>);</div><div class="line">      statQMC.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statQMC.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordtype">double</span> varQMC = p.getNumPoints() * statQMC.variance();</div><div class="line">      <span class="keywordtype">double</span> cpuQMC = timer.getSeconds() / (m * n);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Variance ratio:   %9.4g%n&quot;</span>, varMC/varQMC);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Efficiency ratio: %9.4g%n&quot;</span>,</div><div class="line">           (varMC * cpuMC) / (varQMC * cpuQMC));</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The random number stream passed to the method <code>simulateRuns</code> is an iterator that enumerates the points and coordinates of the randomized point set <code>p</code>. These point set iterators, available for each type of point set in package <code>hups</code>, implement the <code>RandomStream</code> interface and permit one to easily replace the uniform random numbers by (randomized) highly-uniform point sets or sequences, without changing the code of the model itself. The method <code>resetStartStream</code>, invoked immediately after each randomization, resets the iterator to the first coordinate of the first point of the point set <code>p</code>. The number \(n\) of simulation runs is equal to the number of points. The points correspond to substreams in the <code>RandomStream</code> interface. The method <code>resetNextSubstream</code>, invoked after each simulation run in <code>simulateRuns</code>, resets the iterator to the first coordinate of the next point. Each generation of a uniform random number (directly or indirectly) with this stream during the simulation moves the iterator to the next coordinate of the current point.</p>
<p>The point set used in this example is a <em>Sobol’ net</em> with \(n = 2^{16}\) points in \(t\) dimensions. The <code>main</code> program passes this point set to <code>simulateQMC</code> and asks for \(m=20\) independent randomizations. It then computes the empirical variance and CPU time <em>per simulation run</em> for both MC and randomized QMC. It prints the ratio of variances, which can be interpreted as the estimated <em>variance reduction factor</em> obtained when using QMC instead of MC in this example, and the ratio of efficiencies, which can be interpreted as the estimated <em>efficiency improvement factor</em>. (The efficiency of an estimator is defined as 1/(variance \(\times\) CPU time per run.) The results are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_AsianQMC">AsianQMC</a>: QMC reduces the variance by a factor of around 250 and improves the efficiency by a factor of over 500. Randomized QMC not only reduces the variance, it also runs faster than MC. The main reason for this is the call to <code>resetNextSubstream</code> in <code>simulateRuns</code>, which is rather costly for a random number stream of class <code>MRG32k3a</code> (with the current implementation) and takes negligible time for an iterator over a digital net in base 2. In fact, in the the case of MC, the call to <code>resetNextSubstream</code> is not really needed. Removing it for that case reduces the CPU time by more than 40%.</p>
<p><b>Results of the program <code>AsianQMC</code></b> &emsp;[AsianQMC] <a class="anchor" id="REF_examples_res_AsianQMC"></a></p><div class="fragment"><div class="line">Ordinary MC:</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; value of Asian option</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">    100000        0.000      386.378       13.119       22.696</div><div class="line">  95.0% confidence interval <span class="keywordflow">for</span> mean (student): (    12.978,    13.260 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.19</div><div class="line">------------------------</div><div class="line"></div><div class="line">QMC with Sobol point set with 65536 points and affine matrix scramble:</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; QMC averages for Asian option</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">        20       13.108       13.133       13.120       5.6E-3</div><div class="line">  95.0% confidence interval for mean (student): (    13.118,    13.123 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:1.28</div><div class="line"></div><div class="line">Variance ratio:       250.2</div><div class="line">Efficiency ratio:     489.9</div></div><!-- fragment --><h1><a class="anchor" id="REF_examples_sec_event"></a>
Discrete-Event Simulation</h1>
<p>Examples of discrete-event simulation programs, based on the event view supported by the package <code>simevents</code>, are given in this section.</p>
<h2><a class="anchor" id="REF_examples_sec_queue_event"></a>
The single-server queue with an event view</h2>
<p>We return to the single-server queue considered in Section&#160; <a class="el" href="examples.html#REF_examples_sec_queue_lindley">A single-server queue with Lindley’s recurrence</a>. This time, instead of simulating a fixed number of customers, we simulate the system for a fixed time horizon of 1000.</p>
<p><b>Event-oriented simulation of an \(M/M/1\) queue</b> &emsp;[QueueEv] <a class="anchor" id="REF_examples_lst_QueueEv"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueEv {</div><div class="line"></div><div class="line">   RandomVariateGen genArr;</div><div class="line">   RandomVariateGen genServ;</div><div class="line">   LinkedList&lt;Customer&gt; waitList = <span class="keyword">new</span> LinkedList&lt;Customer&gt; ();</div><div class="line">   LinkedList&lt;Customer&gt; servList = <span class="keyword">new</span> LinkedList&lt;Customer&gt; ();</div><div class="line">   Tally custWaits     = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times&quot;</span>);</div><div class="line">   Accumulate totWait  = <span class="keyword">new</span> Accumulate (<span class="stringliteral">&quot;Size of queue&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Customer { <span class="keywordtype">double</span> arrivTime, servTime; }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> QueueEv (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      genArr = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), lambda);</div><div class="line">      genServ = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), mu);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateOneRun (<span class="keywordtype">double</span> timeHorizon) {</div><div class="line">      Sim.init();</div><div class="line">      <span class="keyword">new</span> EndOfSim().schedule (timeHorizon);</div><div class="line">      <span class="keyword">new</span> Arrival().schedule (genArr.nextDouble());</div><div class="line">      Sim.start();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keyword">new</span> Arrival().schedule (genArr.nextDouble()); <span class="comment">// Next arrival.</span></div><div class="line">         Customer cust = <span class="keyword">new</span> Customer();  <span class="comment">// Cust just arrived.</span></div><div class="line">         cust.arrivTime = Sim.time();</div><div class="line">         cust.servTime = genServ.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (servList.size() &gt; 0) {       <span class="comment">// Must join the queue.</span></div><div class="line">            waitList.addLast (cust);</div><div class="line">            totWait.update (waitList.size());</div><div class="line">         } <span class="keywordflow">else</span> {                         <span class="comment">// Starts service.</span></div><div class="line">            custWaits.add (0.0);</div><div class="line">            servList.addLast (cust);</div><div class="line">            <span class="keyword">new</span> Departure().schedule (cust.servTime);</div><div class="line">         }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Departure <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         servList.removeFirst();</div><div class="line">         <span class="keywordflow">if</span> (waitList.size() &gt; 0) {</div><div class="line">            <span class="comment">// Starts service for next one in queue.</span></div><div class="line">            Customer cust = waitList.removeFirst();</div><div class="line">            totWait.update (waitList.size());</div><div class="line">            custWaits.add (Sim.time() - cust.arrivTime);</div><div class="line">            servList.addLast (cust);</div><div class="line">            <span class="keyword">new</span> Departure().schedule (cust.servTime);</div><div class="line">         }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>EndOfSim <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         Sim.stop();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      QueueEv queue = <span class="keyword">new</span> QueueEv (1.0, 2.0);</div><div class="line">      queue.simulateOneRun (1000.0);</div><div class="line">      System.out.println (queue.custWaits.report());</div><div class="line">      System.out.println (queue.totWait.report());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueEv">QueueEv</a> gives an event-oriented simulation program, where a subclass of the class <code>Event</code> is defined for each type of event that can occur in the simulation: arrival of a customer (<code>Arrival</code>), departure of a customer (<code>Departure</code>), and end of the simulation (<code>EndOfSim</code>). Each event <em>instance</em> is inserted into the <em>event list</em> upon its creation, with a scheduled time of occurrence, and is <em>executed</em> when the simulation clock reaches this time. Executing an event means invoking its <code>actions</code> method. Each event subclass must implement this method. The simulation clock and the event list (i.e., the list of events scheduled to occur in the future) are maintained behind the scenes by the class <code>Sim</code> of package <code>simevents</code>.</p>
<p>When <code>QueueEv</code> is instantiated by the <code>main</code> method, the program creates two streams of random numbers, two random variate generators, two lists, and two statistical probes (or collectors). The random number streams are attached to random variate generators <code>genArr</code> and <code>genServ</code> which are used to generate the times between successive arrivals and the service times, respectively. We can use such an attached generator because the means (parameters) do not change during simulation. The lists <code>waitList</code> and <code>servList</code> contain the customers waiting in the queue and the customer in service (if any), respectively. Maintaining a list for the customer in service may seem exaggerated, because this list never contains more than one object, but the current design has the advantage of working with very little change if the queuing model has more than one server, and in other more general situations. Note that we could have used the class <code>LinkedListStat</code> from package <code>simevents</code> instead of <code>java.util.LinkedList</code>. However, with our current implementation, the automatic statistical collection in that <code>LinkedListStat</code> class would not count the customers whose waiting time is zero, because they are never placed in the list. Here we use the class <code>List</code> from package <code>simevents</code>. This class is equivalent to the standard class <code>java.util.LinkedList</code>, except that its implementation is more efficient than the current one in JDK and it can also collect statistics automatically. However, the automatic statistical collection on <code>waitList</code> would not count the customers whose waiting time is zero, because they are never placed in this list, so we do not use this facility.</p>
<p>The statistical probe <code>custWaits</code> collects statistics on the customer’s waiting times. It is of the class <code>Tally</code>, which is appropriate when the statistical data of interest is a sequence of observations \(X_1, X_2, …\) of which we might want to compute the sample mean, variance, and so on. A new observation is given to this probe by the <code>add</code> method each time a customer starts its service. Every <code>add</code> to a <code>Tally</code> probe brings a new observation \(X_i\), which corresponds here to a customer’s waiting time in the queue. The other statistical probe, <code>totWait</code>, is of the class <code>Accumulate</code>, which means that it computes the integral (and, eventually, the time-average) of a continuous-time stochastic process with piecewise-constant trajectory. Here, the stochastic process of interest is the length of the queue as a function of time. One must call <code>totWait.update</code> whenever there is a change in the queue size, to update the (hidden) <em>accumulator</em> that keeps the current value of the integral of the queue length. This integral is equal, after each update, to the total waiting time in the queue, for all the customers, since the beginning of the simulation.</p>
<p>Each customer is an object with two fields: <code>arrivTime</code> memorizes this customer’s arrival time to the system, and <code>servTime</code> memorizes its service time. This object is created, and its fields are initialized, when the customer arrives.</p>
<p>The method <code>simulateOneRun</code> simulates this system for a fixed time horizon. It first invokes <code>Sim.init</code>, which initializes the clock and the event list. The method <code>Sim.start</code> actually starts the simulation by advancing the clock to the time of the first event in the event list, removing this event from the list, and executing it. This is repeated until either <code>Sim.stop</code> is called or the event list becomes empty. <code>Sim.time</code> returns the current time on the simulation clock. Here, two events are scheduled before starting the simulation: the end of the simulation at time horizon, and the arrival of the first customer at a random time that has the exponential distribution with <em>rate</em> \(\lambda\) (i.e., <em>mean</em> \(1/\lambda\)), generated by <code>genArr</code> using inversion and its attached random stream. The method <code>genArr.nextDouble</code> returns this exponential random variate.</p>
<p>The method <code>actions</code> of the class <code>Arrival</code> describes what happens when an arrival occurs. Arrivals are scheduled by a domino effect: the first action of each arrival event schedules the next event in a random number of time units, generated from the exponential distribution with rate \(\lambda\). Then, the newly arrived customer is created, its arrival time is set to the current simulation time, and its service time is generated from the exponential distribution with mean \(1/\mu\), using the random variate generator <code>genServ</code>. If the server is busy, this customer is inserted at the end of the queue (the list <code>waitList</code>) and the statistical probe <code>totWait</code>, that keeps track of the size of the queue, is updated. Otherwise, the customer is inserted in the server’s list <code>servList</code>, its departure is scheduled to happen in a number of time units equal to its service time, and a new observation of 0.0 is given to the statistical probe <code>custWaits</code> that collects the waiting times.</p>
<p>When a <code>Departure</code> event occurs, the customer in service is removed from the list (and disappears). If the queue is not empty, the first customer is removed from the queue (<code>waitList</code>) and inserted in the server’s list, and its departure is scheduled. The waiting time of that customer (the current time minus its arrival time) is given as a new observation to the probe <code>custWaits</code>, and the probe <code>totWait</code> is also updated with the new (reduced) size of the queue.</p>
<p>The event <code>EndOfSim</code> stops the simulation. Then the <code>main</code> routine regains control and prints statistical reports for the two probes. The results are shown in Listing&#160; <a class="el" href="examples.html#REF_examples_res_QueueEv">QueueEv</a>. When calling <code>report</code> on an <code>Accumulate</code> object, an implicit update is done using the current simulation time and the last value given to <code>update</code>. In this example, this ensures that the <code>totWait</code> accumulator will integrate the total wait until the time horizon, because the simulation clock is still at that time when the report is printed. Without such an automatic update, the accumulator would integrate only up to the last update time before the time horizon.</p>
<p><b>Results of the program <code>QueueEv</code></b> &emsp;[QueueEv] <a class="anchor" id="REF_examples_res_QueueEv"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; Waiting times</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">      1037        0.000        6.262        0.495        0.835</div><div class="line"></div><div class="line">REPORT on Accumulate stat. collector ==&gt; Size of queue</div><div class="line">      from time   to time       min         max         average</div><div class="line">        0.00      1000.00      0.000      10.000         0.513</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_preypred"></a>
Continuous simulation: A prey-predator system</h2>
<p>We consider a classical prey-predator system, where the preys are food for the predators (see, e.g., <a class="el" href="citelist.html#CITEREF_sLAW00a">[111]</a>&thinsp;, page 87). Let \(x(t)\) and \(z(t)\) be the numbers of preys and predators at time \(t\), respectively. These numbers are integers, but as an approximation, we shall assume that they are real-valued variables evolving according to the differential equations </p><p class="formulaDsp">
\begin{align*} x’(t) &amp; = r x(t) - c x(t) z(t) \\ z’(t) &amp; = -s z(t) + d x(t) z(t) \end{align*}
</p>
<p> with initial values \(x(0)=x_0&gt;0\) et \(z(0)=z_0&gt;0\). This is a <em>Lotka-Volterra</em> system of differential equations, which has a known analytical solution. Here, in the program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_PreyPred">PreyPred</a>, we simply simulate its evolution, to illustrate the continuous simulation facilities of SSJ.</p>
<p><b>Simulation of the prey-predator system</b> &emsp;[PreyPred] <a class="anchor" id="REF_examples_lst_PreyPred"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>PreyPred {</div><div class="line">   <span class="keywordtype">double</span> r  = 0.005,      c  = 0.00001,</div><div class="line">          s  = 0.01,       d  = 0.000005,     h = 5.0;</div><div class="line">   <span class="keywordtype">double</span> x0 = 2000.0,     z0 = 150.0;</div><div class="line">   <span class="keywordtype">double</span> horizon = 501.0;</div><div class="line">   Simulator sim = <span class="keyword">new</span> Simulator();</div><div class="line">   Continuous x;</div><div class="line">   Continuous z;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { <span class="keyword">new</span> PreyPred(); }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> PreyPred() {</div><div class="line">      x = <span class="keyword">new</span> Preys(sim);</div><div class="line">      z = <span class="keyword">new</span> Preds(sim);</div><div class="line">      sim.init();</div><div class="line">      <span class="keyword">new</span> EndOfSim(sim).schedule (horizon);</div><div class="line">      <span class="keyword">new</span> PrintPoint(sim).schedule (h);</div><div class="line">      (sim.continuousState()).selectRungeKutta4 (h);</div><div class="line">      x.startInteg (x0);</div><div class="line">      z.startInteg (z0);</div><div class="line">      sim.start();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>Preys <span class="keyword">extends</span> Continuous {</div><div class="line">      <span class="keyword">public</span> Preys(Simulator sim) { super(sim); }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">double</span> derivative (<span class="keywordtype">double</span> t) {</div><div class="line">         <span class="keywordflow">return</span> (r * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() - c * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() * z.value());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>Preds <span class="keyword">extends</span> <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#a774bfff9677b042003ce9d6afcedfb15">Continuous</a> {</div><div class="line">      <span class="keyword">public</span> Preds(Simulator sim) { super(sim); }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">double</span> derivative (<span class="keywordtype">double</span> t) {</div><div class="line">         <span class="keywordflow">return</span> (-s * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() + d * x.value() * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>PrintPoint <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> PrintPoint(Simulator sim) { super(sim); }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         System.out.println (sim.time() + <span class="stringliteral">&quot;  &quot;</span> + x.value() + <span class="stringliteral">&quot;  &quot;</span> + z.value());</div><div class="line">         this.schedule (h);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>EndOfSim <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> EndOfSim(Simulator sim) { super(sim); }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { sim.stop(); }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Note that, instead of using the default simulator, this program explicitly creates a discrete-event <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">umontreal.ssj.simevents.Simulator</a> object to manage the execution of the simulation, unlike the other examples in this section.</p>
<p>The program prints the triples \((t, x(t), z(t))\) at values of \(t\) that are multiples of <code>h</code>, one triple per line. This is done by an event of class <code>PrintPoint</code>, which is rescheduled at every <code>h</code> units of time. This output can be redirected to a file for later use, for example to plot a graph of the trajectory. The continuous variables <code>x</code> and <code>z</code> are instances of the classes <code>Preys</code> and <code>Preds</code>, whose method <code>derivative</code> give their derivative \(x’(t)\) and \(z’(t)\), respectively. The differential equations are integrated by a Runge-Kutta method of order 4.</p>
<h2><a class="anchor" id="REF_examples_sec_bank"></a>
A simplified bank</h2>
<p>This is Example&#160;1.4.1 of <a class="el" href="citelist.html#CITEREF_sBRA87a">[24]</a>&thinsp;, page&#160;14. A bank has a random number of tellers every morning. On any given day, the bank has \(t\) tellers with probability \(q_t\), where \(q_3 = 0.80\), \(q_2 = 0.15\), and \(q_1 = 0.05\). All the tellers are assumed to be identical from the modeling viewpoint.</p>
<div class="image">
<object type="image/svg+xml" data="examples_examples_01.svg">examples_examples_01.svg</object>
</div>
<center>Arrival rate of customers to the bank.</center><p><a class="anchor" id="REF_examples_fig_blambda"></a> <b>Event-oriented simulation of the bank model</b> &emsp;[BankEv] <a class="anchor" id="REF_examples_lst_BankEv"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>BankEv {</div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">double</span> minute = 1.0 / 60.0;</div><div class="line">   <span class="keywordtype">int</span>      nbTellers;         <span class="comment">// Number of tellers.</span></div><div class="line">   <span class="keywordtype">int</span>      nbBusy;            <span class="comment">// Number of tellers busy.</span></div><div class="line">   <span class="keywordtype">int</span>      nbWait;            <span class="comment">// Queue length.</span></div><div class="line">   <span class="keywordtype">int</span>      nbServed;          <span class="comment">// Number of customers served so far</span></div><div class="line">   <span class="keywordtype">double</span>   meanDelay;         <span class="comment">// Mean time between arrivals.</span></div><div class="line">   Event    nextArriv       = <span class="keyword">new</span> Arrival();   <span class="comment">// The next arrival.</span></div><div class="line">   RandomStream  streamArr  = <span class="keyword">new</span> MRG32k3a();   <span class="comment">// Customer&#39;s arrivals</span></div><div class="line">   ErlangGen genServ = <span class="keyword">new</span> ErlangConvolutionGen (<span class="keyword">new</span> MRG32k3a(), 2, 1.0/minute);</div><div class="line">   RandomStream  streamTeller = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// Number of tellers</span></div><div class="line">   RandomStream  streamBalk   = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// Balking decisions</span></div><div class="line">   Tally statServed = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Nb. served per day&quot;</span>);</div><div class="line">   Tally avWait     = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average wait per day (hours)&quot;</span>);</div><div class="line">   Accumulate wait  = <span class="keyword">new</span> Accumulate (<span class="stringliteral">&quot;cumulated wait for this day&quot;</span>);</div><div class="line"></div><div class="line">   Event e9h45 = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         meanDelay = 2.0*minute;</div><div class="line">         nextArriv.schedule</div><div class="line">            (ExponentialGen.nextDouble (streamArr, 1.0/meanDelay));</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e10h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keywordtype">double</span> u = streamTeller.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (u &gt;= 0.2) nbTellers = 3;</div><div class="line">         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt; 0.05) nbTellers = 1;</div><div class="line">         <span class="keywordflow">else</span> nbTellers = 2;</div><div class="line">         <span class="keywordflow">while</span> (nbWait &gt; 0 &amp;&amp; nbBusy &lt; nbTellers) {</div><div class="line">            nbBusy++;  nbWait--;</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">         }</div><div class="line">         wait.update (nbWait);</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e11h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.reschedule ((nextArriv.time() - Sim.time())/2.0);</div><div class="line">         meanDelay = minute;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e14h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.reschedule ((nextArriv.time() - Sim.time())*2.0);</div><div class="line">         meanDelay = 2.0*minute;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e15h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { nextArriv.cancel(); }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keywordtype">boolean</span> balk() {</div><div class="line">      <span class="keywordflow">return</span> (nbWait &gt; 9) ||</div><div class="line">             (nbWait &gt; 5 &amp;&amp; (5.0*streamBalk.nextDouble() &lt; nbWait-5));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.schedule</div><div class="line">            (ExponentialGen.nextDouble (streamArr, 1.0/meanDelay));</div><div class="line">         <span class="keywordflow">if</span> (nbBusy &lt; nbTellers) {</div><div class="line">            nbBusy++;</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!balk())</div><div class="line">            { nbWait++;  wait.update (nbWait); }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Departure <span class="keyword">extends</span>  <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html#a85b9e8172cffad1f169d55688e49a72f">Event</a> {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nbServed++;</div><div class="line">         <span class="keywordflow">if</span> (nbWait &gt; 0) {</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">            nbWait--;   wait.update (nbWait);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">else</span> nbBusy--;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulOneDay() {</div><div class="line">      Sim.init();       wait.init();</div><div class="line">      nbTellers = 0;    nbBusy    = 0;</div><div class="line">      nbWait    = 0;    nbServed  = 0;</div><div class="line">      e9h45.schedule (9.75);</div><div class="line">      e10h.schedule (10.0);</div><div class="line">      e11h.schedule (11.0);</div><div class="line">      e14h.schedule (14.0);</div><div class="line">      e15h.schedule (15.0);</div><div class="line">      Sim.start();</div><div class="line">      statServed.add (nbServed);</div><div class="line">      wait.update();</div><div class="line">      avWait.add (wait.sum());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDays (<span class="keywordtype">int</span> numDays) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=numDays; i++)  simulOneDay();</div><div class="line">      System.out.println (statServed.report());</div><div class="line">      System.out.println (avWait.report());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">       <span class="keyword">new</span> BankEv().simulateDays (100);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The bank opens at 10:00 and closes at 15:00 (i.e., 3 p.m.). The customers arrive randomly according to a Poisson process with piecewise constant rate \(\lambda(t)\), \(t\ge0\). The arrival rate \(\lambda(t)\) (see Fig.&#160; <a class="el" href="examples.html#REF_examples_fig_blambda">blambda</a> ) is 0.5 customer per minute from 9:45 until 11:00 and from 14:00 until 15:00, and one customer per minute from 11:00 until 14:00. The customers who arrive between 9:45 and 10:00 join a FIFO queue and wait for the bank to open. At 15:00, the door is closed, but all the customers already in will be served. Service starts at 10:00.</p>
<p>Customers form a FIFO queue for the tellers, with balking. An arriving customer will balk (walk out) with probability \(p_k\) if there are \(k\) customers ahead of him in the queue (not counting the people receiving service), where </p><p class="formulaDsp">
\[ p_k = \begin{cases} 0 &amp; \text{if $k\le5$;} \\ (n-5)/5 &amp; \text{if $5 &lt; k &lt; 10$;} \\ 1 &amp; \text{if $k\ge10$.} \end{cases} \]
</p>
<p> The customer service times are independent Erlang random variables: Each service time is the sum of two independent exponential random variables with mean one.</p>
<p>We want to estimate the expected number of customers served in a day, and the expected average wait for the customers served on a day.</p>
<p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_BankEv">BankEv</a> gives and event-oriented simulation program for this bank model. There are events at the fixed times 9:45, 10:00, etc. At 9:45, the counters are initialized and the arrival process is started. The time until the first arrival, or the time between one arrival and the next one, is (tentatively) an exponential with a mean of 2 minutes. However, as soon as an arrival turns out to be past 11:00, its time must be readjusted to take into account the increase of the arrival rate at 11:00. The event 11:00 takes care of this readjustment, and the event at 14:00 makes a similar readjustment when the arrival rate decreases. We give the specific name <code>nextArriv</code> to the next planned arrival event in order to be able to reschedule that particular event to a different time. Note that a <em>single</em> arrival event is created at the beginning and this same event is scheduled over and over again. This can be done because there is never more than one arrival event in the event list. (We could have done that as well for the \(M/M/1\) queue in Listing <a class="el" href="examples.html#REF_examples_lst_QueueEv">QueueEv</a>.)</p>
<p>At the bank opening at 10:00, an event generates the number of tellers and starts the service for the corresponding customers. The event at 15:00 cancels the next arrival.</p>
<p>Upon arrival, a customer checks if a teller is free. If so, one teller becomes busy and the customer generates its service time and schedules his departure, otherwise the customer either balks or joins the queue. The balking decision is computed by the method <code>balk</code>, using the random number stream <code>streamBalk</code>. The arrival event also generates the next scheduled arrival. Upon departure, the customer frees the teller, and the first customer in the queue, if any, can start its service. The generator <code>genServ</code> is an <code>ErlangConvolutionGen</code> generator, so that the Erlang variates are generated by adding two exponentials instead of using inversion.</p>
<p>The method <code>simulateDays</code> simulates the bank for <code>numDays</code> days and prints a statistical report. If \(X_i\) is the number of customers served on day \(i\) and \(Q_i\) the total waiting time on day \(i\), the program estimates \(E[X_i]\) and \(E[Q_i]\) by their sample averages \(\bar{X}_n\) and \(\bar{Q}_n\) with \(n = \)<code>numDays</code>. For each simulation run (each day), <code>simulOneDay</code> initializes the clock, event list, and statistical probe for the waiting times, schedules the deterministic events, and runs the simulation. After 15:00, no more arrival occurs and the event list becomes empty when the last customer departs. At that point, the program returns to right after the <code>Sim.start()</code> statement and updates the statistical counters for the number of customers served during the day and their total waiting time.</p>
<p>The results are given in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Bank">Bank</a>.</p>
<p><b>Results of the <code>BankEv</code> program</b> &emsp;[Bank] <a class="anchor" id="REF_examples_res_Bank"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; Nb. served per day</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">       100      152.000      285.000      240.590       19.210</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; Average wait per day (hours)</div><div class="line">    num. obs.      min          max        average     standard dev.</div><div class="line">       100        0.816       35.613        4.793        5.186</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_call_center"></a>
A call center</h2>
<p>We consider here a simplified model of a telephone contact center (or <em>call center</em>) where agents answer incoming calls. Each day, the center operates for \(m\) hours. The number of agents answering calls and the arrival rate of calls vary during the day; we shall assume that they are constant within each hour of operation but depend on the hour. Let \(n_j\) be the number of agents in the center during hour \(j\), for \(j=0,…,m-1\). For example, if the center operates from 8 am to 9 pm, then \(m=13\) and hour \(j\) starts at ( \(j+8\)) o’clock. All agents are assumed to be identical. When the number of occupied agents at the end of hour \(j\) is larger than \(n_{j+1}\), ongoing calls are all completed but new calls are answered only when there are less than \(n_{j+1}\) agents busy. After the center closes, ongoing calls are completed and calls already in the queue are answered, but no additional incoming call is taken.</p>
<p>The calls arrive according to a Poisson process with piecewise constant rate, equal to \(R_j = B \lambda_j\) during hour \(j\), where the \(\lambda_j\) are constants and \(B\) is a random variable having the gamma distribution with parameters \((\alpha_0,\alpha_0)\). Thus, \(B\) has mean 1 and variance \(1/\alpha_0\), and it represents the <em>busyness</em> of the day; it is more busy than usual when \(B &gt; 1\) and less busy when \(B &lt; 1\). The Poisson process assumption means that conditional on \(B\), the number of incoming calls during any subinterval \((t_1, t_2]\) of hour \(j\) is a Poisson random variable with mean \((t_2 - t_1) B \lambda_j\) and that the arrival counts in any disjoint time intervals are independent random variables. This arrival process model is motivated and studied in <a class="el" href="citelist.html#CITEREF_ccWHI99c">[215]</a>&thinsp; and <a class="el" href="citelist.html#CITEREF_ccAVR04a">[11]</a>&thinsp;.</p>
<p>Incoming calls form a FIFO queue for the agents. A call is <em>lost</em> (abandons the queue) when its waiting time exceed its <em>patience time</em>. The patience times of calls are assumed to be i.i.d. random variables with the following distribution: with probability \(p\) the patience time is 0 (so the person hangs up unless there is an agent available immediately), and with probability \(1-p\) it is exponential with mean \(1/\nu\). The service times are i.i.d. gamma random variables with parameters \((\alpha,\beta)\).</p>
<p>We want to estimate the following quantities <em>in the long run</em> (i.e., over an infinite number of days): (a) \(w\), the average waiting time per call, (b) \(g(s)\), the fraction of calls whose waiting time is less than \(s\) seconds for a given threshold \(s\), and (c) \(\ell\), the fraction of calls lost due to abandonment.</p>
<p>Suppose we simulate the model for \(n\) days. For each day \(i\), let \(A_i\) be the number of arrivals, \(W_i\) the total waiting time of all calls, \(G_i(s)\) the number of calls who waited less than \(s\) seconds, and \(L_i\) the number of abandonments. For this model, the expected number of incoming calls in a day is \(a = E[A_i] = \sum_{j=0}^{m-1} \lambda_j\). Then, \(W_i/a\), \(G_i(s)/a\), and \(L_i/a\), \(i=1,…,n\), are i.i.d. unbiased estimators of \(w\), \(g(s)\), and \(\ell\), respectively, and can be used to compute confidence intervals for these quantities in a standard way if \(n\) is large.</p>
<p><b>Simulation of a simplified call center</b> &emsp;[CallCenter] <a class="anchor" id="REF_examples_lst_CallCenter"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>CallCenter {</div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">double</span> HOUR = 3600.0;  <span class="comment">// Time is in seconds.</span></div><div class="line"></div><div class="line">   <span class="comment">// Data</span></div><div class="line">   <span class="comment">// Arrival rates are per hour, service and patience times are in seconds.</span></div><div class="line">   <span class="keywordtype">double</span> openingTime;    <span class="comment">// Opening time of the center (in hours).</span></div><div class="line">   <span class="keywordtype">int</span> numPeriods;        <span class="comment">// Number of working periods (hours) in the day.</span></div><div class="line">   <span class="keywordtype">int</span>[] numAgents;       <span class="comment">// Number of agents for each period.</span></div><div class="line">   <span class="keywordtype">double</span>[] lambda;       <span class="comment">// Base arrival rate lambda_j for each j.</span></div><div class="line">   <span class="keywordtype">double</span> alpha0;         <span class="comment">// Parameter of gamma distribution for B.</span></div><div class="line">   <span class="keywordtype">double</span> p;              <span class="comment">// Probability that patience time is 0.</span></div><div class="line">   <span class="keywordtype">double</span> nu;             <span class="comment">// Parameter of exponential for patience time.</span></div><div class="line">   <span class="keywordtype">double</span> alpha, beta;    <span class="comment">// Parameters of gamma service time distribution.</span></div><div class="line">   <span class="keywordtype">double</span> s;              <span class="comment">// Want stats on waiting times smaller than s.</span></div><div class="line"></div><div class="line">   <span class="comment">// Variables</span></div><div class="line">   <span class="keywordtype">double</span> busyness;       <span class="comment">// Current value of B.</span></div><div class="line">   <span class="keywordtype">double</span> arrRate = 0.0;  <span class="comment">// Current arrival rate.</span></div><div class="line">   <span class="keywordtype">int</span> nAgents;           <span class="comment">// Number of agents in current period.</span></div><div class="line">   <span class="keywordtype">int</span> nBusy;             <span class="comment">// Number of agents occupied;</span></div><div class="line">   <span class="keywordtype">int</span> nArrivals;         <span class="comment">// Number of arrivals today;</span></div><div class="line">   <span class="keywordtype">int</span> nAbandon;          <span class="comment">// Number of abandonments during the day.</span></div><div class="line">   <span class="keywordtype">int</span> nGoodQoS;          <span class="comment">// Number of waiting times less than s today.</span></div><div class="line">   <span class="keywordtype">double</span> nCallsExpected; <span class="comment">// Expected number of calls per day.</span></div><div class="line"></div><div class="line">   Event nextArrival = <span class="keyword">new</span> Arrival();           <span class="comment">// The next Arrival event.</span></div><div class="line">   LinkedList&lt;Call&gt; waitList = <span class="keyword">new</span> LinkedList&lt;Call&gt;();</div><div class="line"></div><div class="line">   RandomStream streamB        = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For B.</span></div><div class="line">   RandomStream streamArr      = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For arrivals.</span></div><div class="line">   RandomStream streamPatience = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For patience times.</span></div><div class="line">   GammaGen genServ;      <span class="comment">// For service times; created in readData().</span></div><div class="line"></div><div class="line">   Tally[] allTal = <span class="keyword">new</span> Tally [4];</div><div class="line">   Tally statArrivals = allTal[0] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Number of arrivals per day&quot;</span>);</div><div class="line">   Tally statWaits = allTal[1] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average waiting time per customer&quot;</span>);</div><div class="line">   Tally statGoodQoS = allTal[2] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Proportion of waiting times &lt; s&quot;</span>);</div><div class="line">   Tally statAbandon = allTal[3] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Proportion of calls lost&quot;</span>);</div><div class="line">   Tally statWaitsDay = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times within a day&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> CallCenter (String fileName) <span class="keywordflow">throws</span> IOException {</div><div class="line">      readData (fileName);</div><div class="line">      <span class="comment">// genServ can be created only after its parameters are read.</span></div><div class="line">      <span class="comment">// The acceptance/rejection method is much faster than inversion.</span></div><div class="line">      genServ = <span class="keyword">new</span> GammaAcceptanceRejectionGen (<span class="keyword">new</span> MRG32k3a(), alpha, beta);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Reads data and construct arrays.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> readData (String fileName) <span class="keywordflow">throws</span> IOException {</div><div class="line">      Locale loc = Locale.getDefault();</div><div class="line">      Locale.setDefault(Locale.US); <span class="comment">// to read reals as 8.3 instead of 8,3</span></div><div class="line">      BufferedReader input = <span class="keyword">new</span> BufferedReader (<span class="keyword">new</span> FileReader (fileName));</div><div class="line">      Scanner scan = <span class="keyword">new</span> Scanner(input);</div><div class="line">      openingTime = scan.nextDouble();      scan.nextLine();</div><div class="line">      numPeriods = scan.nextInt();          scan.nextLine();</div><div class="line">      numAgents = <span class="keyword">new</span> <span class="keywordtype">int</span>[numPeriods];</div><div class="line">      lambda = <span class="keyword">new</span> <span class="keywordtype">double</span>[numPeriods];</div><div class="line">      nCallsExpected = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numPeriods; j++) {</div><div class="line">         numAgents[j] = scan.nextInt();</div><div class="line">         lambda[j] = scan.nextDouble();</div><div class="line">         nCallsExpected += lambda[j];       scan.nextLine();</div><div class="line">      }</div><div class="line">      alpha0 = scan.nextDouble();      scan.nextLine();</div><div class="line">      p = scan.nextDouble();           scan.nextLine();</div><div class="line">      nu = scan.nextDouble();          scan.nextLine();</div><div class="line">      alpha = scan.nextDouble();       scan.nextLine();</div><div class="line">      beta = scan.nextDouble();        scan.nextLine();</div><div class="line">      s = scan.nextDouble();</div><div class="line">      scan.close();</div><div class="line">      Locale.setDefault(loc);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// A phone call.</span></div><div class="line">   <span class="keyword">class </span>Call {</div><div class="line">      <span class="keywordtype">double</span> arrivalTime, serviceTime, patienceTime;</div><div class="line"></div><div class="line">      <span class="keyword">public</span> Call() {</div><div class="line">         serviceTime = genServ.nextDouble(); <span class="comment">// Generate service time.</span></div><div class="line">         <span class="keywordflow">if</span> (nBusy &lt; nAgents) {           <span class="comment">// Start service immediately.</span></div><div class="line">            nBusy++;</div><div class="line">            nGoodQoS++;</div><div class="line">            statWaitsDay.add (0.0);</div><div class="line">            <span class="keyword">new</span> CallCompletion().schedule (serviceTime);</div><div class="line">         } <span class="keywordflow">else</span> {                         <span class="comment">// Join the queue.</span></div><div class="line">            patienceTime = generPatience();</div><div class="line">            arrivalTime = Sim.time();</div><div class="line">            waitList.addLast (<span class="keyword">this</span>);</div><div class="line">         }</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> endWait() {</div><div class="line">         <span class="keywordtype">double</span> wait = Sim.time() - arrivalTime;</div><div class="line">         <span class="keywordflow">if</span> (patienceTime &lt; wait) { <span class="comment">// Caller has abandoned.</span></div><div class="line">            nAbandon++;</div><div class="line">            wait = patienceTime;    <span class="comment">// Effective waiting time.</span></div><div class="line">         } <span class="keywordflow">else</span> {</div><div class="line">            nBusy++;</div><div class="line">            <span class="keyword">new</span> CallCompletion().schedule (serviceTime);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">if</span> (wait &lt; s) nGoodQoS++;</div><div class="line">         statWaitsDay.add (wait);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A new period begins.</span></div><div class="line">   <span class="keyword">class </span>NextPeriod <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keywordtype">int</span> j;     <span class="comment">// Number of the new period.</span></div><div class="line">      <span class="keyword">public</span> NextPeriod (<span class="keywordtype">int</span> period) { j = period; }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keywordflow">if</span> (j &lt; numPeriods) {</div><div class="line">            nAgents = numAgents[j];</div><div class="line">            arrRate = busyness * lambda[j] / HOUR;</div><div class="line">            <span class="keywordflow">if</span> (j == 0) {</div><div class="line">               nextArrival.schedule</div><div class="line">                  (ExponentialDist.inverseF (arrRate, streamArr.nextDouble()));</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">               checkQueue();</div><div class="line">               nextArrival.reschedule ((nextArrival.time() - Sim.time())</div><div class="line">                                       * lambda[j-1] / lambda[j]);</div><div class="line">            }</div><div class="line">            <span class="keyword">new</span> NextPeriod(j+1).schedule (1.0 * HOUR);</div><div class="line">         } <span class="keywordflow">else</span></div><div class="line">            nextArrival.cancel();  <span class="comment">// End of the day.</span></div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A call arrives.</span></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArrival.schedule</div><div class="line">            (ExponentialDist.inverseF (arrRate, streamArr.nextDouble()));</div><div class="line">         nArrivals++;</div><div class="line">         <span class="keyword">new</span> Call();               <span class="comment">// Call just arrived.</span></div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A call is completed.</span></div><div class="line">   <span class="keyword">class </span>CallCompletion <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { nBusy--;   checkQueue(); }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Start answering new calls if agents are free and queue not empty.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> checkQueue() {</div><div class="line">      <span class="keywordflow">while</span> ((waitList.size() &gt; 0) &amp;&amp; (nBusy &lt; nAgents))</div><div class="line">         (waitList.removeFirst()).endWait();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates the patience time for a call.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> generPatience() {</div><div class="line">      <span class="keywordtype">double</span> u = streamPatience.nextDouble();</div><div class="line">      <span class="keywordflow">if</span> (u &lt;= p)</div><div class="line">         <span class="keywordflow">return</span> 0.0;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> ExponentialDist.inverseF (nu, (1.0-u) / (1.0-p));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateOneDay (<span class="keywordtype">double</span> busyness) {</div><div class="line">      Sim.init();        statWaitsDay.init();</div><div class="line">      nArrivals = 0;     nAbandon = 0;</div><div class="line">      nGoodQoS = 0;      nBusy = 0;</div><div class="line">      this.busyness = busyness;</div><div class="line"></div><div class="line">      <span class="keyword">new</span> NextPeriod(0).schedule (openingTime * HOUR);</div><div class="line">      Sim.start();</div><div class="line">      <span class="comment">// Here the simulation is running...</span></div><div class="line"></div><div class="line">      statArrivals.add ((<span class="keywordtype">double</span>)nArrivals);</div><div class="line">      statAbandon.add ((<span class="keywordtype">double</span>)nAbandon / nCallsExpected);</div><div class="line">      statGoodQoS.add ((<span class="keywordtype">double</span>)nGoodQoS / nCallsExpected);</div><div class="line">      statWaits.add (statWaitsDay.sum() / nCallsExpected);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateOneDay () {</div><div class="line">      simulateOneDay (GammaDist.inverseF (alpha0, alpha0, 8,</div><div class="line">                                          streamB.nextDouble()));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="keywordtype">void</span> main (String[] args) <span class="keywordflow">throws</span> IOException {</div><div class="line">      CallCenter cc = <span class="keyword">new</span> CallCenter (args.length == 1 ? args[0] : <span class="stringliteral">&quot;CallCenter.dat&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; i++)  cc.simulateOneDay();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;\nNum. calls expected = &quot;</span> + cc.nCallsExpected +<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cc.allTal.length; i++) {</div><div class="line">         cc.allTal[i].setConfidenceIntervalStudent();</div><div class="line">         cc.allTal[i].setConfidenceLevel (0.90);</div><div class="line">      }</div><div class="line">      System.out.println (Tally.report (<span class="stringliteral">&quot;CallCenter:&quot;</span>, cc.allTal));</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_CallCenter">CallCenter</a> gives an event-oriented simulation program for this call center model. When the <code>CallCenter</code> class is instantiated by the <code>main</code> method, the random streams, list, and statistical probes are created, and the model parameters are read from a file by the method <code>readData</code>. The line <code>Locale.setDefault(Locale.US)</code> is added because real numbers in the data file are read in the anglo-saxon form 8.3 instead of the form 8,3 used by most countries in the world. The <code>main</code> program then simulates \(n = 1000\) operating days and prints the value of \(a\), as well as 90% confidence intervals on \(a\), \(w\), \(g(s)\), and \(\ell\), based on their estimators \(\bar{A}_n\), \(\bar{W}_n/a\), \(\bar{G}_n(s)/a\), and \(\bar{L}_n/a\), assuming that these estimators have approximately the Student distribution. This is justified by the fact that \(W_i\), and \(G_i(s)\), and \(L_i\) are themselves “averages” over several observations, so we may expect their distribution to be not far from a normal.</p>
<p>To generate the service times, we use a gamma random variate generator called <code>genServ</code>, created in the constructor after the parameters \((\alpha,\beta)\) of the service time distribution have been read from the data file. For the other random variables in the model, we simply create random streams of i.i.d. uniforms (in the preamble) and apply inversion explicitly to generate the random variates. The latter approach is more convenient, e.g., for patience times because their distribution is not standard and for the inter-arrival times because their mean changes every period. For the gamma service time distribution, on the other hand, the parameters always remain the same and inversion is rather slow, so we decided to create a generator that uses a faster special method.</p>
<p>The method <code>simulateOneDay</code> simulates one day of operation. It initializes the simulation clock, event list, and counters, schedules the center’s opening and the first arrival, and starts the simulation. When the day is over, it updates the statistical collectors. Note that there are two versions of this method; one that generates the random variate \(B\) and the other that takes its value as an input parameter. This is convenient in case one wishes to simulate the center with a fixed value of \(B\).</p>
<p>An event <code>NextPeriod(j)</code> marks the beginning of each period \(j\). The first of these events (for \(j=0\)) is scheduled by <code>simulateOneDay</code>; then the following ones schedule each other successively, until the end of the day. This type of event updates the number of agents in the center and the arrival rate for the next period. If the number of agents has just increased and the queue is not empty, some calls in the queue can now be answered. The method <code>checkQueue</code> verifies this and starts service for the appropriate number of calls. The time until the next planned arrival is readjusted to take into account the change of arrival rate, as follows. The inter-arrival times are i.i.d. exponential with mean \(1/R_{j-1}\) when the arrival rate is fixed at \(R_{j-1}\). But when the arrival rate changes from \(R_{j-1}\) to \(R_j\), the residual time until the next arrival should be modified from an exponential with mean \(1/R_{j-1}\) (already generated) to an exponential with mean \(1/R_j\). Multiplying the residual time by \(\lambda_{j-1}/\lambda_j\) is an easy way to achieve this. We give the specific name <code>nextArrival</code> to the next arrival event in order to be able to reschedule it to a different time. Note that there is a <em>single</em> arrival event which is scheduled over and over again during the entire simulation. This is more efficient than creating a new arrival event for each call, and can be done here because there is never more than one arrival event at a time in the event list. At the end of the day, simply canceling the next arrival makes sure that no more calls will arrive.</p>
<p>Each arrival event first schedules the next one. Then it increments the arrivals counter and creates the new call that just arrived. The call’s constructor generates its service time and decides where the incoming call should go. If an agent is available, the call is answered immediately (its waiting time is zero), and an event is scheduled for the completion of the call. Otherwise, the call must join the queue; its patience time is generated by <code>generPatience</code> and memorized, together with its arrival time, for future reference.</p>
<p>Upon completion of a call, the number of busy agents is decremented and one must verify if a waiting call can now be answered. The method <code>checkQueue</code> verifies that and if the answer is yes, it removes the first call from the queue and activates its <code>endWait</code> method. This method first compares the call’s waiting time with its patience time, to see if this call is still waiting or has been lost (by abandonment). If the call was lost, we consider its waiting time as being equal to its patience time (i.e., the time that the caller has really waited), for the statistics. If the call is still there, the number of busy agents is incremented and an event is scheduled for the call completion.</p>
<p>The results of this program, with the data in file <code>CallCenter.dat</code>, are shown in Listing&#160; <a class="el" href="examples.html#REF_examples_res_CallCenter">CallCenter</a>.</p>
<p><b>Simulation of a simplified call center</b> &emsp;[CallCenter] <a class="anchor" id="REF_examples_res_CallCenter"></a></p><div class="fragment"><div class="line"></div><div class="line">Num. calls expected = 1660.0</div><div class="line"></div><div class="line">Report <span class="keywordflow">for</span> CallCenter:</div><div class="line">                                    num obs.     min        max        average      std. dev.   conf. <span class="keywordtype">int</span>.  </div><div class="line">Number of arrivals per day          1000      460.000    4206.000     1639.507       513.189   90.0% ( 1612.789, 1666.225)</div><div class="line">Average waiting time per customer   1000        0.000     570.757       11.834        34.078   90.0% (   10.060,   13.608)</div><div class="line">Proportion of waiting times &lt; s     1000        0.277       1.155        0.853         0.169   90.0% (    0.844,    0.862)</div><div class="line">Proportion of calls lost            1000        0.000       0.844        0.034         0.061   90.0% (    0.031,    0.037)</div><div class="line"></div></div><!-- fragment --><p>This model is certainly an oversimplification of actual call centers. It can be embellished and made more realistic by considering different types of agents, different types of calls, agents taking breaks for lunch, coffee, or going to the restroom, agents making outbound calls to reach customers when the inbound traffic is low (e.g., for marketing purpose or for returning calls), and so on. One could also model the revenue generated by calls and the operating costs for running the center, and use the simulation model to compare alternative operating strategies in terms of the expected net revenue, for example. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
