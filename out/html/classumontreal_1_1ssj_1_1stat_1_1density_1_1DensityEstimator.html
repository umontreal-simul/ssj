<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DensityEstimator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1density.html">density</a></li><li class="navelem"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DensityEstimator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This abstract class represents a univariate density estimator (DE).  
 <a href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for DensityEstimator:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator__inherit__graph.svg" width="467" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a682fd278d58d084d180aa0145d14a032"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a682fd278d58d084d180aa0145d14a032">setData</a> (double[] <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a2769cd30087309e2a0605ebbd95606b4">data</a>)</td></tr>
<tr class="memdesc:a682fd278d58d084d180aa0145d14a032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observations for the density estimator do <em>data</em>.  <a href="#a682fd278d58d084d180aa0145d14a032">More...</a><br /></td></tr>
<tr class="separator:a682fd278d58d084d180aa0145d14a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27f1ed28de9d1d45b61c0e5562bd4bc"><td class="memItemLeft" align="right" valign="top">double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aa27f1ed28de9d1d45b61c0e5562bd4bc">getData</a> ()</td></tr>
<tr class="memdesc:aa27f1ed28de9d1d45b61c0e5562bd4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the observations for this density estimator, if any.  <a href="#aa27f1ed28de9d1d45b61c0e5562bd4bc">More...</a><br /></td></tr>
<tr class="separator:aa27f1ed28de9d1d45b61c0e5562bd4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fe8be449d76c9e8ec7eef54735cd5c"><td class="memItemLeft" align="right" valign="top">abstract double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a86fe8be449d76c9e8ec7eef54735cd5c">evalDensity</a> (double x)</td></tr>
<tr class="memdesc:a86fe8be449d76c9e8ec7eef54735cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the density estimator at <em>x</em>.  <a href="#a86fe8be449d76c9e8ec7eef54735cd5c">More...</a><br /></td></tr>
<tr class="separator:a86fe8be449d76c9e8ec7eef54735cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eae5b3d962a6b4f9f533e955005b9b"><td class="memItemLeft" align="right" valign="top">double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a39eae5b3d962a6b4f9f533e955005b9b">evalDensity</a> (double[] evalPoints)</td></tr>
<tr class="memdesc:a39eae5b3d962a6b4f9f533e955005b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the density estimator at the points in <em>evalPoints</em>.  <a href="#a39eae5b3d962a6b4f9f533e955005b9b">More...</a><br /></td></tr>
<tr class="separator:a39eae5b3d962a6b4f9f533e955005b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35059e827b69531eee64a20bf584a098"><td class="memItemLeft" align="right" valign="top">double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a35059e827b69531eee64a20bf584a098">evalDensity</a> (double[] evalPoints, double[] <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a2769cd30087309e2a0605ebbd95606b4">data</a>)</td></tr>
<tr class="memdesc:a35059e827b69531eee64a20bf584a098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observations for the density estimator to <em>data</em> and evaluates the density at each point in <em>evalPoints</em>.  <a href="#a35059e827b69531eee64a20bf584a098">More...</a><br /></td></tr>
<tr class="separator:a35059e827b69531eee64a20bf584a098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a4b355b87b8f89dbdc1268755f382f"><td class="memItemLeft" align="right" valign="top">double [][]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#ac5a4b355b87b8f89dbdc1268755f382f">evalDensity</a> (double[] evalPoints, double[][] <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a2769cd30087309e2a0605ebbd95606b4">data</a>)</td></tr>
<tr class="memdesc:ac5a4b355b87b8f89dbdc1268755f382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is particularly designed to evaluate the density estimator in such a way that the result can be easily used to estimate the empirical IV and other convergence-related quantities.  <a href="#ac5a4b355b87b8f89dbdc1268755f382f">More...</a><br /></td></tr>
<tr class="separator:ac5a4b355b87b8f89dbdc1268755f382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e2151cf49df9f80a4999e0e9e54d55"><td class="memItemLeft" align="right" valign="top">abstract String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a77e2151cf49df9f80a4999e0e9e54d55">toString</a> ()</td></tr>
<tr class="memdesc:a77e2151cf49df9f80a4999e0e9e54d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a short description of the estimator.  <a href="#a77e2151cf49df9f80a4999e0e9e54d55">More...</a><br /></td></tr>
<tr class="separator:a77e2151cf49df9f80a4999e0e9e54d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3ebd01bd7ca67bf8832af3dd8f2bc39d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a3ebd01bd7ca67bf8832af3dd8f2bc39d">evalDensity</a> (ArrayList&lt; <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a> &gt; listDE, double[] evalPoints, double[][] <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a2769cd30087309e2a0605ebbd95606b4">data</a>, ArrayList&lt; double[][]&gt; listDensity)</td></tr>
<tr class="memdesc:a3ebd01bd7ca67bf8832af3dd8f2bc39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is particularly designed for experiments with many different types of density estimators, as it evaluates all of these estimators at the points in <em>evalPoints</em>.  <a href="#a3ebd01bd7ca67bf8832af3dd8f2bc39d">More...</a><br /></td></tr>
<tr class="separator:a3ebd01bd7ca67bf8832af3dd8f2bc39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9">computeVariance</a> (double[][] density)</td></tr>
<tr class="memdesc:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the empirical variance based on the values given in <em>data</em>.  <a href="#a16f04c4763dc6c1d50ab0c277a2ddfc9">More...</a><br /></td></tr>
<tr class="separator:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aca9c290eebf7cdc7d4ebcf883fe90b88">computeIV</a> (double[][] density, double a, double b, double[] variance)</td></tr>
<tr class="memdesc:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical IV over the interval \([a,b]\).  <a href="#aca9c290eebf7cdc7d4ebcf883fe90b88">More...</a><br /></td></tr>
<tr class="separator:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a650c049ba7e2d47161c6796b6dc5b5cc">computeIV</a> (ArrayList&lt; double[][]&gt; listDensity, double a, double b, ArrayList&lt; Double &gt; listIV)</td></tr>
<tr class="memdesc:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical IV over the interval \([a,b]\) for a collection of different estimators.  <a href="#a650c049ba7e2d47161c6796b6dc5b5cc">More...</a><br /></td></tr>
<tr class="separator:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8349c434950e5c5c6e245e3928cb96ac"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8349c434950e5c5c6e245e3928cb96ac">computeMISE</a> (<a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a> dist, double[] evalPoints, double[][] density, double a, double b, double[] variance, double[] sqBias, double[] mse)</td></tr>
<tr class="memdesc:a8349c434950e5c5c6e245e3928cb96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">In situations where the true density is known this method can estimate the empirical MISE over the interval \([a,b]\).  <a href="#a8349c434950e5c5c6e245e3928cb96ac">More...</a><br /></td></tr>
<tr class="separator:a8349c434950e5c5c6e245e3928cb96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed45f859027b55025865ecec4014c1ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aed45f859027b55025865ecec4014c1ea">computeMISE</a> (<a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a> dist, double[] evalPoints, ArrayList&lt; double[][]&gt; listDensity, double a, double b, ArrayList&lt; double[]&gt; listMISE)</td></tr>
<tr class="memdesc:aed45f859027b55025865ecec4014c1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical MISE over the interval \([a,b]\) for a collection of different estimators.  <a href="#aed45f859027b55025865ecec4014c1ea">More...</a><br /></td></tr>
<tr class="separator:aed45f859027b55025865ecec4014c1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b223706dc90bab33746a61504e7be95"><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a7b223706dc90bab33746a61504e7be95">plotDensity</a> (double[] evalPoints, double[] density, String plotTitle, String[] axisTitles)</td></tr>
<tr class="memdesc:a7b223706dc90bab33746a61504e7be95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a plot of the estimated density.  <a href="#a7b223706dc90bab33746a61504e7be95">More...</a><br /></td></tr>
<tr class="separator:a7b223706dc90bab33746a61504e7be95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a88d2d3720ac775f5953b35ac0a504a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a3a88d2d3720ac775f5953b35ac0a504a">roughnessFunctional</a> (double[] density, double a, double b)</td></tr>
<tr class="memdesc:a3a88d2d3720ac775f5953b35ac0a504a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the roughness functional.  <a href="#a3a88d2d3720ac775f5953b35ac0a504a">More...</a><br /></td></tr>
<tr class="separator:a3a88d2d3720ac775f5953b35ac0a504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2769cd30087309e2a0605ebbd95606b4"><td class="memItemLeft" align="right" valign="top"><a id="a2769cd30087309e2a0605ebbd95606b4"></a>
double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a2769cd30087309e2a0605ebbd95606b4">data</a></td></tr>
<tr class="memdesc:a2769cd30087309e2a0605ebbd95606b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data associated with this <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html" title="This abstract class represents a univariate density estimator (DE). ">DensityEstimator</a> object, if any. <br /></td></tr>
<tr class="separator:a2769cd30087309e2a0605ebbd95606b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This abstract class represents a univariate density estimator (DE). </p>
<p>In this abstract class, only non-static methods for evaluating the density estimator are provided. However, typically, its subclasses offer static methods as well. In a majority of cases, one simply wishes to estimate the density at a finite set of evaluation points, from a given set of data, and perhaps plot the estimated density. To do that, there is no need to create an object. One can simply use a static <code>evalDensity</code> method followed by <code>plotDensity</code>. Note that calling the <code>evalDensity</code> method only once for a vector of evaluation points is typically much faster than calling it separately for each evaluation point.</p>
<p>In case one plans to evaluate the same density several times with the same data, it may be worthwhile to construct a <code><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html" title="This abstract class represents a univariate density estimator (DE). ">DensityEstimator</a></code> object and build the density estimate from the given data. After that, one can evaluate the density at any given point, often much faster than by calling the static method. In the case of a histogram or average shifted histogram, for example, constructing the density estimator takes time, but once it is constructed, evaluating it is relatively fast. For a KDE with fixed bandwidth, the difference (or gain) may be small.</p>
<p>In a non-abstract subclass, it suffices (in principle) to implement the abstract method <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a86fe8be449d76c9e8ec7eef54735cd5c">evalDensity(double)</a>, which evaluates the density at a single point \(x\) given the data points. However, other methods will typically be overridden to make them more efficient. For example, evaluating the DE over a set of evaluation points \(\{x_0, x_1, \dots, x_{k-1}\} \) can often be performed more efficiently than by calling <code>evalDensity(x)</code> repeatedly in a loop.</p>
<p>More precisely, the single point evaluation <code><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a86fe8be449d76c9e8ec7eef54735cd5c" title="Evaluates the density estimator at x. ">evalDensity(double)</a></code> is abstract, since it will definitely differ between subclasses. For the evaluation on a set of points one can use <code>evalDensity(double[]).</code> Even though a default implementation is provided, very often specific estimators will have more efficient evaluation algorithms. So, overriding this method can be beneficial in many cases. Furthermore, this class includes a method to plot the estimated density.</p>
<p>Another important abstract method is <code>setData</code>, which allows to change the observations that define the density estimator. This can be especially useful when one intends to evaluate the same type of density estimator for different observations.</p>
<p>This class also provides more elaborate methods that deal with the convergence behavior of the DEs in terms of their IV, ISB, and MISE.</p>
<p>As these only require evaluations of the density estimator, they are implemented as static methods.</p>
<p>One such method estimates the empirical IV, see <code>computeIV(double[][], double, double, double[])</code> for one individual DE and <code>computeIV(ArrayList, double, double, ArrayList)</code> for several DEs. These methods merely compute an estimate, since computing an exact integral is out of reach for this class.</p>
<p>Note that the MISE can only be computed in situations where either the ISB is zero or the true density is known. In the first case, the IV is the same as the MISE, of course. For the second case this class provides the possibility to estimate the empirical MISE for a single DE via <code>computeMISE(ContinuousDistribution, double[], double[][], double, double, double[], double[], double[])</code> as well as for several DEs via <code>computeMISE(ContinuousDistribution, double[], ArrayList, double, double, ArrayList)</code>. Again, as explained before for the IV, this merely gives an estimate of the empirical MISE. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aca9c290eebf7cdc7d4ebcf883fe90b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c290eebf7cdc7d4ebcf883fe90b88">&#9670;&nbsp;</a></span>computeIV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double computeIV </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>variance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical IV over the interval \([a,b]\). </p>
<p>Based on the density estimates of \(m\) independent replications of the density estimator evaluated at \(k\) evaluation points, which are provided by <em>density</em>, it computes the empirical variance at each evaluation point and stores it in <em>variance</em>.</p>
<p>To estimate the empirical IV, we sum up the variance at the evaluation points \(x_1,x_2,\dots,x_k\) and multiply by \((b-a)/k\), i.e.</p>
<p class="formulaDsp">
\[ \int_a^b \hat{f}(x)\mathrm{d}x \approx \frac{b-a}{k} \sum_{j = 1}^k\hat{f}(x_j), \]
</p>
<p>where \(\hat{f}\) denotes the density estimator. In other words, we approximate the empirical IV by an equally weighted quadrature rule using the aforementioned evaluation points as integration nodes.</p>
<p>Note that this is only an approximation of the true empirical IV and that the approximation quality significantly depends on the choice of evaluation points.</p>
<p>The data for the variance are given in the two-dimensional \(m\times k\) array <em>density</em>, which is also described in <code><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9" title="This method computes the empirical variance based on the values given in data. ">computeVariance(double[][])</a></code> and can be obtained by <code>evalDensity(double[], double[][])</code> . The boundaries of the interval are given by <em>a</em> and <em>b</em>. Note that the array <em>variance</em> needs to be of length \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the \(m\times k\) array that contains the data of evaluating \(m\) replicates of the density estimator at \(k\) evaluation points </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">variance</td><td>the array of length \(k\) in which the variance at each evaluation point is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated empirical IV over \([a,b]\). </dd></dl>

</div>
</div>
<a id="a650c049ba7e2d47161c6796b6dc5b5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650c049ba7e2d47161c6796b6dc5b5cc">&#9670;&nbsp;</a></span>computeIV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void computeIV </td>
          <td>(</td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; Double &gt;&#160;</td>
          <td class="paramname"><em>listIV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical IV over the interval \([a,b]\) for a collection of different estimators. </p>
<p>In <em>densityList</em> the user passes a list of \(m\times k\) arrays which contain the density estimates of \(m\) independent replications of each density estimator evaluated at \(k\) evaluation points. Such a list can be obtained via <code>evalDensity(ArrayList, double[], double[][], ArrayList)</code> , for instance.</p>
<p>The method then calls <code>computeIV(double[][], double, double, double[])</code> for each element of <em>densityList</em> and adds the thereby obtained estimated empirical IV to the list that is being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listDensity</td><td>list containing \(m\times k\) arrays that contain the data of evaluating \(m\) replicates of each density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">listIV</td><td>the list to which the estimated empirical IV of each density estimator will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="a8349c434950e5c5c6e245e3928cb96ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8349c434950e5c5c6e245e3928cb96ac">&#9670;&nbsp;</a></span>computeMISE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] computeMISE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>sqBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>mse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In situations where the true density is known this method can estimate the empirical MISE over the interval \([a,b]\). </p>
<p>This can be particularly interesting and useful for testing density estimators. Since it is necessary to compute either the ISB or the IV to get the MISE and as there is not much computational overhead to estimate the other, an array containing the estimated empirical IV, the ISB, and MISE in exactly this order is returned. Based on the density estimates of \(m\) independent replications of the density estimator evaluated at \(k\) evaluation points <em>evalPoints</em>, which are provided by <em>density</em>, it computes the empirical variance, the square-bias, and the mean square error (MSE) at each evaluation point and stores the result in <em>variance</em>, <em>sqBias</em>, and <em>mse</em>, respectively. It is important that the evaluation points in <em>evalPoints</em> are the same as the ones used to construct <em>density</em>.</p>
<p>To estimate the empirical IV and MISE we sum up the variance and the MSE at the \(k\) evaluation points and multiply by \((b-a)/k\), i.e. we approximate the empirical IV by an equally weighted quadrature rule with <em>evalPoints</em> as integration nodes. The ISB is then computed as the difference of the MISE and the IV. Note that this is only an approximation of the true empirical values and that the approximation quality significantly depends on the choice of <em>evalPoints</em>.</p>
<p>The data for the variance and mse are given in the two-dimensional \(m\times k\) array <em>density</em>, which is also described in <code><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9" title="This method computes the empirical variance based on the values given in data. ">computeVariance(double[][])</a></code> and can be obtained by <code>evalDensity(double[], double[][], double, double)</code>, and the true density is passed via a <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">umontreal.ssj.probdist.ContinuousDistribution</a>. The evaluation points are contained in <em>evalPoints</em> and the boundaries of the interval over which we estimate are given by <em>a</em> and <em>b</em>. Note that the arrays <em>variance</em>, <em>sqBias</em>, and <em>mse</em> all need to be of length \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>the true density. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the \(k\) evaluation points. </td></tr>
    <tr><td class="paramname">density</td><td>the \(m\times k\) array that contains the data of evaluating \(m\) replicates of the density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">variance</td><td>the array of length \(k\) in which the variance at each evaluation point is stored. </td></tr>
    <tr><td class="paramname">sqBias</td><td>the array of length \(k\) in which the square-bias at each evaluation point is stored. </td></tr>
    <tr><td class="paramname">mse</td><td>the array of length \(k\) in which the MSE at each evaluation point is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the estimated empirical IV, ISB, and MISE in exactly this order. </dd></dl>

</div>
</div>
<a id="aed45f859027b55025865ecec4014c1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed45f859027b55025865ecec4014c1ea">&#9670;&nbsp;</a></span>computeMISE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void computeMISE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[]&gt;&#160;</td>
          <td class="paramname"><em>listMISE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical MISE over the interval \([a,b]\) for a collection of different estimators. </p>
<p>This can be done when the true density is actually known and is particularly interesting and/or useful for testing density estimators.</p>
<p>In <em>densityList</em> the user passes a list of \(m\times k\) arrays which contain the density estimates of \(m\) independent replications of each density estimator evaluated at \(k\) evaluation points. Such a list can be obtained by calling <code>evalDensity(ArrayList, double[], double[][], ArrayList)</code>, for instance.</p>
<p>The method then calls <code>computeMISE(ContinuousDistribution, double[], double[][], double, double, double[], double[], double[])</code> for each element of <em>listDensity</em>. This results in an array containing the estimated empirical IV, ISB, and MISE in exactly this order, which is then added to the list <em>listMISE</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>the true density. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the \(k\) evaluation points. </td></tr>
    <tr><td class="paramname">listDensity</td><td>list of \(m\times k\) arrays that contain the data of evaluating \(m\) replicates of each density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">listMISE</td><td>a list to which the arrays containing the estimated empirical IV, ISB, and MISE of each density estimator are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="a16f04c4763dc6c1d50ab0c277a2ddfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f04c4763dc6c1d50ab0c277a2ddfc9">&#9670;&nbsp;</a></span>computeVariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] computeVariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method computes the empirical variance based on the values given in <em>data</em>. </p>
<p>More precisely, <em>density</em> is a \(m\times k\) matrix, whose entries correspond to \(m\) independent realizations of the density estimator, each evaluated at \(k\) evaluation points. Such a matrix can, for instance, be obtained by <code>evalDensity(double[], double[][])</code>.</p>
<p>The empirical variance is computed at each of those \(k \) evaluation points and returned in an array of size \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the estimated density of \(m\) independent realizations of the estimator, each evaluated at \(k\) evaluation points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the empirical variance at those \(k\) evaluation points. </dd></dl>

</div>
</div>
<a id="a86fe8be449d76c9e8ec7eef54735cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fe8be449d76c9e8ec7eef54735cd5c">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract double evalDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the density estimator at <em>x</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the evaluation point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator evaluated at \(x\). </dd></dl>

</div>
</div>
<a id="a39eae5b3d962a6b4f9f533e955005b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eae5b3d962a6b4f9f533e955005b9b">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [] evalDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the density estimator at the points in <em>evalPoints</em>. </p>
<p>By default, this method calls <code><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a86fe8be449d76c9e8ec7eef54735cd5c" title="Evaluates the density estimator at x. ">evalDensity(double)</a></code> for each entry of <em>evalPoints</em>. Many density estimators can handle evaluation at a set of points more efficiently than that. If so, it is suggested to override this method in the implementation of the corresponding estimator.</p>
<dl class="section return"><dt>Returns</dt><dd>the density estimator evaluated at the points <em>evalPoints</em>. </dd></dl>

</div>
</div>
<a id="a35059e827b69531eee64a20bf584a098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35059e827b69531eee64a20bf584a098">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [] evalDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the observations for the density estimator to <em>data</em> and evaluates the density at each point in <em>evalPoints</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator defined by <em>data</em> evaluated at each point in <em>evalPoints</em>. </dd></dl>

</div>
</div>
<a id="ac5a4b355b87b8f89dbdc1268755f382f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a4b355b87b8f89dbdc1268755f382f">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [][] evalDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>[][]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is particularly designed to evaluate the density estimator in such a way that the result can be easily used to estimate the empirical IV and other convergence-related quantities. </p>
<p>Assume that we have \(m\) independent realizations of the underlying model. For each such realization this method constructs a density and evaluates it at the points from <em>evalPoints</em>. The independent realizations are passed via the 2-dimensional \(m\times n\) array <em>data</em>, where \(n\) denotes the number of observations per realization. Hence, its first index identifies the independent realization while its second index identifies a specific observation of this realization.</p>
<p>The result is returned as a \(m\times k\) matrix, where \(k \) is the number of evaluation points, i.e., the length of <em>evalPoints</em>. The first index, again, identifies the independent realization whereas the second index corresponds to the point of <em>evalPoints</em> at which the density estimator was evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the two-dimensional array carrying the observations of \(m\) independent realizations of the underlying model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator for each realization evaluated at <em>evalPoints</em>. </dd></dl>

</div>
</div>
<a id="a3ebd01bd7ca67bf8832af3dd8f2bc39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebd01bd7ca67bf8832af3dd8f2bc39d">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evalDensity </td>
          <td>(</td>
          <td class="paramtype">ArrayList&lt; <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a> &gt;&#160;</td>
          <td class="paramname"><em>listDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is particularly designed for experiments with many different types of density estimators, as it evaluates all of these estimators at the points in <em>evalPoints</em>. </p>
<p>To this end, the user passes a list of density estimators in <em>listDE</em> as well as \(m\) independent realizations of the underlying model consisting of \(n\) observations each in the \(m\times n\) array <em>data</em>.</p>
<p>This method then calls <code>evalDensity(double[], double[][])</code> for each density estimator in <em>listDE</em>, thus evaluating the respective density estimator at the \(k\) points in <em>evalPoints</em> and adds the resulting \(m\times k\) array to <em>listDensity</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listDE</td><td>the list of density estimators. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the two-dimensional array carrying the observations of \(m\) independent realizations of the underlying model. </td></tr>
    <tr><td class="paramname">listDensity</td><td>a list to which the evaluations at <em>evalPoints</em> of each density estimator in <em>listDE</em> are added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="aa27f1ed28de9d1d45b61c0e5562bd4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27f1ed28de9d1d45b61c0e5562bd4bc">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [] getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the observations for this density estimator, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>the observations for this density estimator. </dd></dl>

</div>
</div>
<a id="a7b223706dc90bab33746a61504e7be95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b223706dc90bab33746a61504e7be95">&#9670;&nbsp;</a></span>plotDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static String plotDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>plotTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String []&#160;</td>
          <td class="paramname"><em>axisTitles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a plot of the estimated density. </p>
<p>The \(x\)-values are passed in <em>evalPoints</em> and the \(y\)-values in <em>density</em>. The user may also set the title of the plot via <em>plotTitle</em> as well as the names of the axes via <em>axisTitles</em>. The latter contains the name of the \(x\) axis as first element and the name of the \(y\) axis as second.</p>
<p>The plot itself is returned as a string, which forms a stand-alone LaTex file (including necessary headers) implementing a tikZ picture.</p>
<p>This function merely tailors and simplifies the methods provided by <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1PgfDataTable.html">umontreal.ssj.stat.PgfDataTable</a> for the purpose of plotting a univariate function. If the user seeks to produce more sophisticated plots, please refer to the aforementioned class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the \(x\)-values. </td></tr>
    <tr><td class="paramname">density</td><td>the \(y\)-values. </td></tr>
    <tr><td class="paramname">plotTitle</td><td>the title of the plot. </td></tr>
    <tr><td class="paramname">axisTitles</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3a88d2d3720ac775f5953b35ac0a504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a88d2d3720ac775f5953b35ac0a504a">&#9670;&nbsp;</a></span>roughnessFunctional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double roughnessFunctional </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the roughness functional. </p>
<p class="formulaDsp">
\[ R(g) = \int_a^b g^2(x)\mathrm{d}x\]
</p>
<p>of a function \(g\) over the interval \([a,b]\). This is done via a quadrature rule using predetermined values of \(g\) passed by the user via <em>density</em> as integration nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the function evaluations. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a682fd278d58d084d180aa0145d14a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682fd278d58d084d180aa0145d14a032">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void setData </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observations for the density estimator do <em>data</em>. </p>
<p>Note that, in some cases, this requires to completely reconstruct the density estimator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the desired observations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e2151cf49df9f80a4999e0e9e54d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e2151cf49df9f80a4999e0e9e54d55">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract String toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a short description of the estimator. </p>
<dl class="section return"><dt>Returns</dt><dd>a short description. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>DensityEstimator.java</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
