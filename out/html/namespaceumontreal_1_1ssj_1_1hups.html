<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>umontreal::ssj::hups Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">hups</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">umontreal::ssj::hups Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Highly Uniform Point Sets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">AntitheticPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class provides antithetic points.  <a href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html">BakerTransformedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class embodies a point set to which a <em>Baker transformation</em> is applied (see, e.g., <a class="el" href="citelist.html#CITEREF_vHIC02a">[79]</a>&thinsp;).  <a href="classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">CachedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class caches a point set by precomputing and storing its points locally in an array.  <a href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">ContainerPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This acts as a generic base class for all <em>container classes</em> that contain a point set and apply some kind of transformation to the coordinates to define a new point set.  <a href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html">CycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LFSR generators produce numbers by generating a sequence of bits from a linear recurrence modulo 2, and forming fractional numbers by taking blocks of successive bits.  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class provides the basic structures for storing and manipulating a <em>highly uniform point set</em> defined by a set of cycles.  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">CycleBasedPointSetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a>, except that the successive values in the cycles are stored as integers in the range \(\{0,…,2^k-1\}\), where \(1\le k \le31\).  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the basic structures for storing and manipulating <em>linear digital nets in base \(b\)</em>, for an arbitrary base \(b\ge2\).  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">DigitalNetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> for the base \(b=2\).  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html">DigitalNetBase2FromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to read the parameters defining a digital net <em>in base 2</em> either from a file, or from a URL address on the World Wide Web.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html">DigitalNetFromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to read the parameters defining a digital net either from a file, or from a URL address on the World Wide Web.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">DigitalSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html">DigitalSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html">EmptyRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an empty <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">F2wCycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear feedback shift register sequence.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">F2wCycleBasedPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear congruential sequence in the finite field \(\mathbb F_{2^w}[z]/P(z)\).  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">F2wNetLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a linear feedback shift register generator.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">F2wNetPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a polynomial LCG in \(\mathbb F_{2^w}[z]/P(z)\).  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html">F2wStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements methods and fields needed by the classes <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">umontreal.ssj.hups.F2wNetLFSR</a>, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">umontreal.ssj.hups.F2wNetPolyLCG</a>, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">umontreal.ssj.hups.F2wCycleBasedLFSR</a> and <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">umontreal.ssj.hups.F2wCycleBasedPolyLCG</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html">FaureSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets or digital sequences formed by the first \(n = b^k\) points of the Faure sequence in base \(b\).  <a href="classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html">HaltonSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the sequence of Halton <a class="el" href="citelist.html#CITEREF_rHAL60a">[71]</a>&thinsp;, which is essentially a modification of Hammersley nets for producing an infinite sequence of points having low discrepancy.  <a href="classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html">HammersleyPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>Hammersley point sets</em>, which are defined as follows.  <a href="classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html">IndependentPointsCached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to IndependentPoints, but the points are all generated and stored (cached) when the point set is randomized.  <a href="classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html">KorobovLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>Korobov lattices</em>, which represents the same point sets as in class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a>, but implemented differently.  <a href="classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLatticeSequence.html">KorobovLatticeSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html">LatinHypercube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Latin Hypercube Sampling (LHS) with \(n\) points in the \(s\)-dimensional unit hypercube.  <a href="classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a recurrence-based point set defined via a linear congruential recurrence of the form \(x_i = a x_{i-1} \mod n\) and \(u_i = x_i / n\).  <a href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html">LMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a left matrix scrambling and adds a random digital shift.  <a href="classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html">NestedUniformScrambling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a> that performs Owen's nested uniform scrambling <a class="el" href="citelist.html#CITEREF_vOWE95a">[166]</a>, <a class="el" href="citelist.html#CITEREF_vOWE03a">[170]</a> .  <a href="classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html">NiedSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences constructed from the Niederreiter sequence in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html">NiedXingSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences based on the Niederreiter-Xing sequence in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">PaddedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class realizes <em>padded point sets</em>, constructed by taking some coordinates from a point set \(P_1\), other coordinates from a point set \(P_2\), and so on.  <a href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">PointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class defines the basic methods for accessing and manipulating point sets.  <a href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">PointSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects of classes that implement this interface are <em>iterators</em> that permit one to enumerate (or observe) the successive points of a point set and the successive coordinates of these points.  <a href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface is used to randomize a <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>.  <a href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html">RadicalInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements basic methods for working with radical inverses of integers in an arbitrary basis \(b\).  <a href="classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html">RandomShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomStart.html">RandomStart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that randomizes a sequence with a random starting point.  <a href="classumontreal_1_1ssj_1_1hups_1_1RandomStart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedPointSet.html">RandShiftedPointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements point sets specified by integration lattices of rank.  <a href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html">RQMCPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used for <em>randomized quasi-Monte Carlo</em> (RQMC) simulations <a class="el" href="citelist.html#CITEREF_vLEC00b">[117]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[118]</a>, <a class="el" href="citelist.html#CITEREF_vOWE97a">[167]</a>, <a class="el" href="citelist.html#CITEREF_vOWE97b">[168]</a>&thinsp;.  <a href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html">SMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a striped matrix scrambling and adds a random digital shift.  <a href="classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html">SobolSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets or digital sequences in base 2 formed by the first \(n = 2^k\) points of a Sobol’ sequence <a class="el" href="citelist.html#CITEREF_rSOB67a">[195]</a>, <a class="el" href="citelist.html#CITEREF_rSOB76b">[196]</a>&thinsp;.  <a href="classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SortedAndCutPointSet.html">SortedAndCutPointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation.  <a href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html">StratifiedUnitCubeAnti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation, similar to <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">SubsetOfPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class permits one to select a subset of a point set.  <a href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Highly Uniform Point Sets. </p>
<h2>Monte Carlo and quasi-Monte Carlo</h2>
<p>This package provides classes implementing <em>highly uniform point sets</em> (HUPS) over the \(s\)-dimensional unit hypercube \([0,1)^s\), and tools for their randomization. The terminology <em>low-discrepancy sequence</em> (LDS) is often used for infinite sequences of points such that the <em>discrepancy</em> between the distribution of the first \(n\) points of the sequence and the uniform distribution converges to zero at a certain rate when \(n\to\infty\) <a class="el" href="citelist.html#CITEREF_rNIE92b">[164]</a>&thinsp;. HUPS and LDS are used for quasi-Monte Carlo integration, as we now briefly explain. See, e.g., <a class="el" href="citelist.html#CITEREF_vFOX99a">[59]</a>, <a class="el" href="citelist.html#CITEREF_fGLA04a">[64]</a>, <a class="el" href="citelist.html#CITEREF_rHEL98a">[74]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[118]</a>, <a class="el" href="citelist.html#CITEREF_vLEC03b">[136]</a>, <a class="el" href="citelist.html#CITEREF_vOWE98a">[169]</a>, <a class="el" href="citelist.html#CITEREF_rNIE92b">[164]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[193]</a>, <a class="el" href="citelist.html#CITEREF_rTEZ95a">[204]</a>&thinsp; for further details.</p>
<p>Suppose we want to estimate the integral of a function \(f\) defined over the \(s\)-dimensional unit hypercube, <a class="anchor" id="REF_hups_overview_eq_mu"></a> </p><p class="formulaDsp">
\[ \mu= \int_{[0,1)^s} f(\mathbf{u}) d\mathbf{u}. \tag{mu} \]
</p>
<p> Practically any mathematical expectation that can be estimated by simulation can be written in this way, usually for a very complicated \(f\) and sometimes for \(s=\infty\). Indeed, the source of randomness of stochastic simulations is usually a <em>stream</em> of real numbers \(\mathbf{u}= (u_0,u_1,u_2,…)\) whose purpose is to imitate i.i.d. \(U(0,1)\) random variables. These real numbers are transformed in complicated ways to produce the estimator. Thus, the dimension \(s\) of the integral ( <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_mu">mu</a> ) represents the number of calls to the uniform random number generator if that number is deterministic. If it is random and unbounded, we take \(s = \infty\). In the latter case, however, we can assume that the <em>actual</em> number of calls is finite with probability one (otherwise the simulation may never end).</p>
<p>We consider an estimator of \(\mu\) of the form <a class="anchor" id="REF_hups_overview_eq_Qn"></a> </p><p class="formulaDsp">
\[ Q_n = \frac{1}{n} \sum_{i=0}^{n-1} f(\mathbf{u}_i), \tag{Qn} \]
</p>
<p> which is the average of \(f\) over the <em>point set</em> \(P_n = \{\mathbf{u}_0,…,\mathbf{u}_{n-1}\} \subset[0,1)^s\).</p>
<p>With the <em>Monte Carlo</em> (MC) method, the \(\mathbf{u}_i\)’s are i.i.d. random vectors uniformly distributed over \([0,1)^s\). Then, \(Q_n\) is an unbiased estimator of \(\mu\) with variance \(\sigma^2/n\), where </p><p class="formulaDsp">
\[ \sigma^2 = \int_{[0,1)^s} f^2(\mathbf{u}) d\mathbf{u}- \mu^2, \]
</p>
<p> and it obeys a central-limit theorem if \(\sigma^2 &lt; \infty\).</p>
<p><em>Quasi-Monte Carlo</em> (QMC) methods use point sets \(P_n\) that are <em>more evenly distributed</em> over the unit hypercube than typical random points. We call them <em>highly uniform point sets</em> (HUPS). The aim is to reduce the size of the integration error \(Q_n - \mu\). Two important classes of methods for constructing such point sets are <em>digital nets</em> and <em>integration lattices</em> <a class="el" href="citelist.html#CITEREF_rNIE92b">[164]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[193]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[118]</a>, <a class="el" href="citelist.html#CITEREF_fGLA04a">[64]</a>&thinsp;. Both are implemented in this package, in various flavors.</p>
<h2>Elementary constructions</h2>
<p>To give an idea of how HUPS and LDS can be constructed, we start with a simple one-dimensional example. If \(s=1\) and \(n\) is fixed, very simple highly uniform constructions are the point sets \(P_n = \{0,  1/n, …, (n-1)/n\}\) and the shifted version \(P’_n = \{1/(2n),  3/(2n),  …, (2n-1)/(2n)\}\).</p>
<p>In \(s &gt; 1\) dimensions, the simplest extensions would be as follows. Let \(n = d^s\) for some integer \(d\) and define \(P_n\) as the Cartesian product of \(s\) copies of the one-dimensional sets \(P_d\); that is, \(P_n = \{(u_0,…,u_{s-1}) : u_j \in\{0,  1/d,  …, (d-1)/d\}\) for each \(j\}\), and similarly for \(P’_n\). The point sets thus obtained are regular rectangular grids. Unfortunately, this approach breaks down rapidly when \(s\) gets large, because \(n\) must increase exponentially fast with \(s\) for fixed \(d\). Another important drawback is that when \(P_n\) is projected over lower-dimensional subspaces, several points are projected onto each other and become redundant <a class="el" href="citelist.html#CITEREF_vLEC02a">[118]</a>&thinsp;.</p>
<p>A better idea is to construct a point set \(P_n\) in \(s\) dimensions such that each one-dimensional projection of \(P_n\) is the set of values \(\{0,  1/n,  …, (n-1)/n\}\). Of course, these values should not be visited in the same order for all coordinates, because otherwise all the points would lie on the diagonal line going from \((0,…,0)\) to \((1,…,1)\). In other words, for each coordinate \(j\), \(0\le j &lt; s\), we must define a different <em>permutation</em> of the integers \(\{0,…,n-1\}\) and visit the values \(\{0,  1/n,  …, (n-1)/n\}\) in the order determined by that permutation. The trick is to select those permutations in a way that \(P_n\) itself is highly uniform over \([0,1)^s\) in a well-defined sense (to be determined). This is what most construction methods attempt to achieve. Before looking at concrete ways of defining such permutations, we introduce a related issue: what to do if \(n\) is not fixed.</p>
<p>For \(s=1\), a simple way of filling up the unit interval \([0,1)\) uniformly is via the low-discrepancy sequence 0, 1/2, 1/4, 3/4, 1/8, 5/8, 3/8, 7/8, 1/16, 9/16, …, called the <em>van der Corput sequence</em> in base 2. More generally, select an integer \(b \ge2\), called the <em>base</em>. The <em>radical inverse</em> function in base \(b\), \(\psi_b : \mathbb{N}\to[0,1)\), is defined as follows. If \(i\) is a \(k\)-digit integer in base \(b\) with digital \(b\)-ary expansion </p><p class="formulaDsp">
\[ i = a_0 + a_1 b + …+ a_{k-1} b^{k-1}, \]
</p>
<p> then </p><p class="formulaDsp">
\[ \psi_b(i) = a_0 b^{-1} + a_1 b^{-2} + \cdots+ a_{k-1} b^{-k}. \]
</p>
<p> For a given \(b\), \(\psi_b(0), \psi_b(1), \psi_b(2), …\) is called the <em>van der Corput sequence in base \(b\)</em>. This sequence fills up the unit interval \([0,1)\) quite uniformly. For example, for \(b=2\) we obtain the sequence mentioned above and for \(b=3\) we obtain 0, 1/3, 2/3, 1/9, 4/9, 7/9, 2/9, 5/9, 8/9, 1/27, 10/27, 19/27, …. Moreover, for two relatively prime bases \(b_1\) and \(b_2\), the two sequences have no value in common except 0.</p>
<p>For \(s &gt; 1\), one could either take different (relatively prime) bases for the different coordinates, or take the same basis \(b\) but permute the successive values using a different permutation for each coordinate. These permutations are usually selected in a way that for every integer \(k\), the first \(b^k\) values that are enumerated remain the same (they are the values of \(\psi_b(i)\) for \(i=0,…,b^k-1\)), but they are enumerated in a different order. Several digital net constructions (to be defined later) fit this framework.</p>
<p>If we decide to take different bases, the most natural choice is to take the \(j\)th smallest prime, \(b_j\), as a base for coordinate \(j-1\); that is, base 2 for coordinate 0, base 3 for coordinate 1, base 5 for coordinate 2, and so on. The infinite sequence thus defined, where point \(i\) is <a class="anchor" id="REF_hups_overview_eq_Halton_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_s}(i)) \tag{Halton-point} \]
</p>
<p> for \(i \ge0\), was proposed in <a class="el" href="citelist.html#CITEREF_rHAL60a">[71]</a>&thinsp; and is called the <em>Halton sequence</em>. One drawback of this sequence is that for large \(s\), the base \(b_s\) becomes quite large.</p>
<p>In the case where \(n\) is fixed, we can always take \(i/n\) as the first coordinate of point \(i\). In particular, the <em>Hammersley point set</em> with \(n\) points in \(s\) dimensions contains the points <a class="anchor" id="REF_hups_overview_eq_Hammersley_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (i/n,\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_{s-1}}(i)), \tag{Hammersley-point} \]
</p>
<p> for \(i=0,…,n-1\) <a class="el" href="citelist.html#CITEREF_rHAM60a">[73]</a>&thinsp;. Historically, Halton sequences were defined as extensions of Hammersley point sets.</p>
<h2>Digital nets</h2>
<p><em>Digital nets and sequences</em> are an important class of HUPS and LDS constructions. Most concrete implementations, e.g., those proposed by Sobol’, Faure, Niederreiter, and Niederreiter and Xing, are <em>linear</em> digital nets and sequences, defined as follows (see also <a class="el" href="citelist.html#CITEREF_rNIE92b">[164]</a>, <a class="el" href="citelist.html#CITEREF_rTEZ95a">[204]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[118]</a>&thinsp;).</p>
<p>Let \(b\ge2\) be an arbitrary integer (usually a prime number), called the <em>base</em>. A net that contains \(n = b^k\) points in \(s\) dimensions is defined via \(s\) <em>generator matrices</em> \(\mathbf{C}_0,…,\mathbf{C}_{s-1}\), which are (in theory) \(\infty\times k\) matrices whose elements are in \(\mathbb{Z}_b = \{0,…,b-1\}\). The matrix \(\mathbf{C}_j\) is used for coordinate \(j\) of all the points, for \(j\ge0\). To define the \(i\)th point \(\mathbf{u}_i\), for \(i=0,…,b^k-1\), write the digital expansion of \(i\) in base \(b\) and multiply the vector of its digits by \(\mathbf{C}_j\) to obtain the digits of the expansion of \(u_{i,j}\), the \(j\)th coordinate of \(\mathbf{u}_i\). That is, <a class="anchor" id="REF_hups_overview_eq_digital_i"></a><a class="anchor" id="REF_hups_overview_eq_digital_Cj"></a><a class="anchor" id="REF_hups_overview_eq_digital_uij"></a><a class="anchor" id="REF_hups_overview_eq_digital_ui"></a> </p><p class="formulaDsp">
\begin{align} i &amp; = \sum_{\ell=0}^{k-1} a_{i,\ell} b^{\ell}, \tag{digital-i} \\ \begin{pmatrix} u_{i,j,1} \\ u_{i,j,2} \\ \vdots \end{pmatrix} &amp; = \mathbf{C}_j \begin{pmatrix} a_{i,0} \\ a_{i,1} \\ \vdots \\ a_{i,k-1} \end{pmatrix} , \tag{digital-Cj} \\ u_{i,j} &amp; = \sum_{\ell=1}^{\infty}u_{i,j,\ell} b^{-\ell}, \tag{digital-uij} \\ \mathbf{u}_i &amp; = (u_{i,0},…,u_{i,s-1}). \tag{digital-ui} \end{align}
</p>
<p> In practice, the expansion in ( <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_digital_uij">digital-uij</a> ) is truncated to the first \(r\) digits for some positive integer \(r\), so each matrix \(\mathbf{C}_j\) is actually truncated to a \(r\times k\) matrix. Typically \(r\) is equal to \(k\), or is slightly larger, or is selected so that \(b^r\) is near \(2^{31}\).</p>
<p>Usually, the first \(k\) lines of each \(\mathbf{C}_j\) form a nonsingular \(k\times k\) matrix. Then, the \(n\) output values for coordinate \(j\), \(u_{0,j},…, u_{n-1,j}\), when truncated to their first \(k\) fractional digits in base \(b\), are a permutation of the numbers \(0, 1/n, …, (n-1)/n\). Different coordinates simply use different permutations, implemented via the matrices \(\mathbf{C}_j\).</p>
<p>When the first \(k\) lines of \(\mathbf{C}_j\) form the identity and the other lines are zero, the first \(n\) output values are the first \(n\) elements of the van der Corput sequence in base \(b\). If we reverse the order of the columns of that matrix \(\mathbf{C}_j\) (i.e., column \(c\) will contain a one in line \(k-c+1\) and zeros elsewhere, for \(0\le c &lt; k\)), we obtain the output values \(0, 1/n, …, (n-1)/n\) in that order. With a slight abuse of language, we shall call this first matrix (with the identity followed by lines of zeros) the <em>identity</em> and the second one (with the columns in reverse order) the <em>reflected identity</em>. It is customary to take \(\mathbf{C}_0\) as the identity for digital sequences, and often for digital nets as well. But for digital nets (where \(n\) is fixed in advance), one can take \(\mathbf{C}_0\) as the reflected identity instead, then \(\mathbf{C}_1\) as the identity, and so on. That is, the matrix \(\mathbf{C}_j\) for the digital net is taken as the matrix \(\mathbf{C}_{j-1}\) of the digital sequence. Our package often gives the choice.</p>
<p>For digital sequences, the matrices \(\mathbf{C}_j\) actually have an infinite number of columns, although only the first \(k\) columns are needed to generate the first \(b^k\) points. So in practice, we never need to store more than a finite number of columns at a time. Whenever we find that we need more than \(b^k\) points for the current value of \(k\), we can simply increase \(k\) and add the corresponding columns to the matrices \(\mathbf{C}_j\).</p>
<p>The classes <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a> and <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">umontreal.ssj.hups.DigitalSequence</a> implement generic digital nets and sequences. Specific instances are constructed in subclasses of these two classes.</p>
<h2>Lattice Rules</h2>
<p>An <em>integration lattice</em> is a discrete (but infinite) subset of \(\mathbb{R}^s\) of the form </p><p class="formulaDsp">
\[ L_s = \left\{\mathbf{v}= \sum_{j=1}^s h_j {\mathbf{v}_j} \mbox{ such that each } h_j\in\mathbb{Z}\right\}, \]
</p>
<p> where \(\mathbf{v}_1,…,\mathbf{v}_s \in\mathbb{R}^s\) are linearly independent over \(\mathbb{R}\) and \(\mathbb{Z}^s \subseteq L_s\). This last condition means that \(L_s\) must contain all integer vectors, and this implies that \(L_s\) is periodic with period 1 along each of the \(s\) coordinates. The approximation of \(\mu\) by \(Q_n\) with the point set \(P_n = L_s \cap[0,1)^s\) is called a <em>lattice rule</em> <a class="el" href="citelist.html#CITEREF_mKOR59a">[106]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[193]</a>&thinsp;. The value of \(n\) is the number of points of the lattice that are in the unit hypercube \([0,1)^s\).</p>
<p>Let \(\mathbf{V}\) be the matrix whose rows are the basis vectors \(\mathbf{v}_1,\cdots,\mathbf{v}_s\) and \(\mathbf{V}^{-1}\) its inverse. One has \(\mathbb{Z}^s\subseteq L_s\) if and only if all entries of \(\mathbf{V}^{-1}\) are integer. When this holds, \(n = \det(\mathbf{V}^{-1})\) and all entries of \(\mathbf{V}\) are multiples of \(1/n\).</p>
<p>The <em>rank</em> of the lattice is the smallest \(r\) such that one can find a basis of the form \(\mathbf{v}_1,…, \mathbf{v}_r,\mathbf{e}_{r+1},\cdots,\mathbf{e}_s\), where \(\mathbf{e}_j\) is the \(j\)th unit vector in \(s\) dimensions. In particular, a lattice rule of <em>rank 1</em> has a basis of the form \(\mathbf{v}_1 = (a_1, …, a_s)/n\) and \(\mathbf{v}_j = \mathbf{e}_j\) for \(j&gt;1\), where \(a_j \in\mathbb{Z}_n\) for each \(j\). It is a <em>Korobov</em> rule if \(\mathbf{v}_1\) has the special form \(\mathbf{v}_1 = (1,\; a,\; a^2 \mod n,\; …,\; a^{s-1} \mod n)/n\) for some \(a\in\mathbb{Z}_n\). The point set \(P_n\) of a Korobov lattice rule can also be written as \(P_n = \{(x_1,…,x_s)/n \mbox{ such that } x_1\in\mathbb{Z}_n \mbox{ and } x_j = a x_{j-1} \mod n \mbox{ for all } j &gt; 1\}\). This is the set of all vectors of successive values produced by a linear congruential generator (LCG) with modulus \(n\) and multiplier \(a\), from all possible initial states, including 0. In this case, the points are easy to enumerate by using the recurrence.</p>
<h2>Cycle-based point sets</h2>
<p>Certain types of point sets are defined pretty much like random number generators: choose a finite state space \(\mathcal{S}\), a transition function \(f : \mathcal{S}\to\mathcal{S}\), an output function \(g : \mathcal{S}\to[0,1)\), and define </p><p class="formulaDsp">
\[ P_n = \{\mathbf{u}= (u_0,u_1,…) : s_0\in\mathcal{S}, s_j = f(s_{j-1}), \mbox{ and } u_j = g(s_j) \mbox{ for all } j\}. \]
</p>
<p> This is the set of all vectors of successive output values produced by the recurrence defined by \(f\) and the output function \(g\), from all possible initial states. The value of \(n\) is the cardinality of \(\mathcal{S}\) and the dimension \(s\) is infinite. We could also have \(n = \infty\) (an infinite sequence) if \(\mathcal{S}\) is infinite but denumerable and ordered (so we know in which order to enumerate the points).</p>
<p>Let us assume that \(n\) is finite and that for each \(s_0\in\mathcal{S}\), the recurrence \(s_j = f(s_{j-1})\) is <em>purely periodic</em>, i.e., there is always an integer \(j\) such that \(s_j = s_0\). The smallest such \(j\), called the <em>period length</em>, depends in general on \(s_0\). Thus, the state space \(\mathcal{S}\) is partitioned into a finite number of <em>cycles</em>. The successive coordinates of any point \(\mathbf{u}\in P_n\) are periodic with period length equal to the length of the cycle that contains \(s_0\) (and the following \(s_j\)’s).</p>
<p>One way of implementing such a point set while avoiding to recompute \(f\) and \(g\) each time a coordinate is needed is to store explicitly all the cycles of the recurrence, in the form of a <em>list of cycles</em>. We can store either the successive \(u_j\)’s directly, or the successive \(s_j\)’s, over each cycle. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">umontreal.ssj.hups.CycleBasedPointSet</a> provides the framework for doing that.</p>
<p>For example, a Korobov lattice point set is defined via the recurrence \(x_j = a x_{j-1} \mod n\) and output function \(u_j = x_j/n\). If \(n\) is prime and \(a\) is a primitive element modulo \(n\), then there are two cycles: one of period 1 that contains only 0, and the other of period \(n-1\). For more general \(n\) and \(a\), there will be more cycles. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">umontreal.ssj.hups.LCGPointSet</a> constructs this type of point set and stores explicitly the successive values of \(u_j\) over the different cycles.</p>
<p>There are cases where \(n\) is a power of two, say \(n = 2^k\), and where the state \(s_j\) is represented as a \(k\)-bit string. In that context, it is often more convenient to store the successive \(s_j\)’s instead of the successive \(u_j\)’s, over the set of cycles (e.g., if a random digital shift in base 2 is to be applied to randomize the points, it can be performed by applying a bitwise xor directly to \(s_j\)). When generating the coordinates, the \(s_j\)’s can be interpreted as \(2^k\)-bit integers and multiplied by \(2^{-k}\) to produce the output. This is supported by the class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">umontreal.ssj.hups.CycleBasedPointSetBase2</a>. Special instances of this class are usually based on linear recurrences modulo 2 and they include the Korobov-type <em>polynomial lattice rules</em> <a class="el" href="citelist.html#CITEREF_rLEC99a">[134]</a>, <a class="el" href="citelist.html#CITEREF_vLEC99a">[116]</a>, <a class="el" href="citelist.html#CITEREF_rLEC02b">[120]</a>, <a class="el" href="citelist.html#CITEREF_vLEM03a">[140]</a>, <a class="el" href="citelist.html#CITEREF_rPAN04a">[171]</a>&thinsp;.</p>
<h2>Randomized quasi-Monte Carlo</h2>
<p>In their original versions, these HUPS are deterministic, and the corresponding QMC methods give a <em>deterministic</em> integration error that is difficult to estimate. In <em>randomized</em> QMC methods, \(P_n\) is randomized, preferably in a way that it retains its high uniformity over \([0,1)^s\) when taken as a set, while each of its points has the uniform distribution over \([0,1)^s\) when taken individually. Then, \(Q_n\) becomes an unbiased estimator of \(\mu\), hopefully with smaller variance than the standard MC estimator. To estimate the variance and compute a confidence interval on \(\mu\), one can apply \(m\) independent randomizations to the same \(P_n\), and compute \({\bar{X}_m}\) and \({S_{m,x}^2}\), the sample mean and sample variance of the \(m\) corresponding (independent) copies of \(Q_n\). Then, \(E[\bar{X}_m] = \mu\) and \(E[S_{m,x}^2] = \mathrm{Var}[Q_n] = m\mathrm{Var}[\bar{X}_m]\) <a class="el" href="citelist.html#CITEREF_vLEC00b">[117]</a>&thinsp;.</p>
<p>Two examples of such randomizations are the <em>random shift modulo 1</em>, proposed in <a class="el" href="citelist.html#CITEREF_vCRA76a">[34]</a>&thinsp; and implemented in class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedPointSet.html">umontreal.ssj.hups.RandShiftedPointSet</a>, and the <em>random digital shift in base \(b\)</em>, described and implemented in class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a>. These randomizations are also incorporated directly in certain types of point sets such as <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">umontreal.ssj.hups.CycleBasedPointSet</a>, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">umontreal.ssj.hups.CycleBasedPointSetBase2</a>, etc.</p>
<p>In the random shift modulo 1, we generate a <em>single</em> point \(\mathbf{u}\) uniformly over \([0,1)^s\) and add it to each point of \(P_n\), coordinate-wise, modulo 1. Since all points of \(P_n\) are shifted by the same amount, the set retains most of its structure and uniformity.</p>
<p>For the random digital shift in base \(b\), we generate again a single \(\mathbf{u}= (u_1,…,u_s)\) uniformly over \([0,1)^s\), write the digital expansion in base \(b\) of each of its coordinates, say \(u_j = \sum_{\ell=1}^{\infty}d_{j,\ell} b^{-\ell}\), then add \(d_{j,\ell}\) modulo \(b\) to the \(\ell\)th digit of the digital expansion in base \(b\) of the \(j\)th coordinate of each point \(\mathbf{u}_i\in P_n\). For \(b=2\), the digit-wise addition modulo \(b\) becomes a bitwise exclusive-or, which is fast to perform on a computer.</p>
<p>An interesting property of the digital shift in base \(b\) is that if the hypercube \([0,1)^s\) is partitioned into \(b^{q_1 + \cdots+ q_s}\) rectangular boxes of the same size by partitioning the \(j\)th axis into \(b^{q_j}\) equal parts for each \(j\), for some integers \(q_j \ge0\) (such a partition is called a <em> \(\mathbf{q}\)-equidissection in base \(b\)</em> of the unit hypercube, where \(\mathbf{q}= (q_1,…,q_s)\)), then the number of boxes that contain \(m\) points, for each integer \(m\), is unchanged by the randomization. In particular, if each box contains the same number of points of \(P_n\) before the randomization, then it also does after the randomization. In this case, we say that \(P_n\) is <em> \(\mathbf{q}\)-equidistributed in base \(b\)</em>. Several other randomization methods exist and most are adapted to special types of point sets; see, e.g., <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a> and <a class="el" href="citelist.html#CITEREF_vOWE03a">[170]</a>&thinsp;.</p>
<h2>Point set implementations and enumeration tools</h2>
<p>Let \(\mathbf{u}_i = (u_{i,0}, u_{i,1}, …, u_{i,s-1})\) be the elements of the point set \(P_n\), for \(i=0,…,n-1\). Both the number of points \(n\) and the dimension \(s\) can be finite or infinite. The point set can be viewed as a two-dimensional array whose element \((i,j)\) contains \(u_{i,j}\), the coordinate \(j\) of point \(i\). In the implementations of typical point sets, the values \(u_{i,j}\) are not stored explicitly in a two-dimensional array, but pertinent information is organized so that the points and their coordinates can be generated efficiently. The base class for point sets is the abstract class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>.</p>
<p>To enumerate the successive points or the successive coordinates of a given point, we use <em>point set iterators</em>, which resemble the iterators defined in Java <em>collections</em>, except that they loop over bi-dimensional sets. Their general behavior is defined in the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a>. Several independent iterators can coexist at any given time for the same point set. Each one maintains a current point index and a current coordinate index, which are incremented by one when the iterator advances to the next point or the next coordinate. Both are initialized to 0. Each subclass of <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> has its own implementation of <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> and has a method <code>iterator</code> that creates and returns a new point set iterator of the correct type.</p>
<p>An important feature of the <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> interface is that it extends the <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> interface. This means that any point set iterator can be used in place of a random stream that is supposed to generate i.i.d. \(U(0,1)\) random variables, anywhere in a simulation program. It then becomes very easy to replace the (pseudo)random numbers by the coordinates \(u_{i,j}\) of a randomized HUPS without changing the internal code of the simulation program.</p>
<h2>Transformed point sets and containers</h2>
<p>HUPS are often transformed either deterministically or randomly. Deterministic transformations can be applied to improve the uniformity, or to eliminate some points or coordinates (i.e., selecting subsets), or to concatenate point sets (padding), or to take an antithetic version of a point set, etc. Random transformations are used for randomized QMC. They are also useful when the <em>average</em> of a uniformity measure of interest over the outcomes of a certain type of randomization is much better than the worst case and may be better than the uniformity measure of the original point set. When a point set is transformed, we often want to keep the original as well, and we may want to apply different types of transformations or different independent randomizations to the same point set.</p>
<p>This can be achieved via <em>container</em> point sets, which are defined in terms of another point set to which they keep a reference and apply certain transformations. <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">umontreal.ssj.hups.ContainerPointSet</a> is the base class for such containers. One example is <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedPointSet.html">umontreal.ssj.hups.RandShiftedPointSet</a>, which applies a random shift modulo 1 to the point set that it contains. Of course, the contained point set can be a container itself and this can be done recursively, but too many levels of recursiveness may impair the performance (speed).</p>
<h2>Examples</h2>
<p>To be done...</p>
<h2>Steps for performing Quasi-Monte Carlo simulation</h2>
<ol>
<li>
Decide which type of point set will be used and create it by constructing a subclass of <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>.  </li>
<li>
Get an iterator for the point set and use it as an ordinary random number stream. It can be used to create non-uniform random number generators as well, although only inversion should be used.  </li>
<li>
<p class="startli">For each of the \(R\) replications of the simulation, do the following to compute the statistic \(x_r\), for \(r=0,…,R-1\).</p>
<ol>
<li>
Randomize the point set using a uniform x1random number stream.  </li>
<li>
<p class="startli">Perform \(n\) replications of the simulation, each with a different point in the point set. For each replication, one should obtain the result \(x_{r,i}\), where \(i=0,…,n-1\).</p>
<p class="endli">Note: All the points from a finite point set should be used to fully take advantage of its low discrepancy.  </p>
</li>
<li>
Compute the statistic <p class="formulaDsp">
\[ x_r=\frac{1}{n}\sum_{i=0}^{n-1} x_{r,i}. \]
</p>
  </li>
<li>
Reset the point set iterator for the next replication.  </li>
</ol>
</li>
<li>
The values \(x_0,…,x_{r-1}\) can be used as statistical observations to compute the \(\bar{x}\) estimator, confidence interval, ...  </li>
</ol>
<h2>Representation of a point set</h2>
<p>The (abstract) base class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> views a <em>point set</em> as a set of \(n\) points in the \(t\)-dimensional unit hypercube \([0,1)^t\). A point set can also be viewed (and stored) as an \(n\times t\) matrix whose element \((i,j)\) is the \(j\)th coordinate of the \(i\)th point, for \(0\le i &lt; n\) and \(0\le j &lt; t\) (both the point and coordinate indexes start from zero). One can directly use methods of this class, but this is sometimes not the most efficient technique for accessing coordinates of a point set and it results in two versions of the same simulation application, one for Monte Carlo and another one for Quasi-Monte Carlo. The class contains a method allowing one to construct a <em>point set iterator</em> which can traverse the point set more efficiently.</p>
<p>The <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> contains all needed methods to traverse a point set. One can return only one coordinate, \(t\) coordinates, change the current coordinate and current point index, reset the iterator, ... Since the class implements <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a>, it can be used exactly as a uniform random number generator. This allows one to use the same application logic for MC and QMC simulation; only the initialization part will depend on the type of simulation. Every point set implements its own specialized iterator, allowing an efficient access to the coordinates.</p>
<h2>Supported types of point sets</h2>
<p>The <code>hups</code> package supports several types of point sets implemented in different classes extending <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>. The <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">umontreal.ssj.hups.CycleBasedPointSet</a> class provides the needed basis for implementing cycle-based point sets. Each point is obtained by an initial value which lies in a given cycle. The coordinates are obtained by visiting all the points of the given cycle periodically, so the point set has an infinite dimension. The <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">umontreal.ssj.hups.LCGPointSet</a> is an implementation of a cycle-based point set whose cycles are generated using a small LCG. Such a point set corresponds to a Korobov lattice rule.</p>
<p>Generic rank 1 lattices rules are implemented in the class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">umontreal.ssj.hups.Rank1Lattice</a>. Korobov lattice sequences are implemented in the class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLatticeSequence.html">umontreal.ssj.hups.KorobovLatticeSequence</a>.</p>
<p>Two types of digital nets are supported, namely base-2 and base- \(b\). They are implemented in separate base class because some optimizations can be done for the special case of base&#160;2. The <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">umontreal.ssj.hups.DigitalNetBase2</a> class, which implements digital nets in base 2, provides all required facilities for computing points from such a digital net. It also supports scrambling as randomization. A digital net implementation needs to provide the adequate generating matrices to the base class. Sobol, Niederreiter and Niederreiter-Xing sequences are supported in base&#160;2.</p>
<p>The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a> provides the required facilities for implementing digital nets in an arbitrary base \(b\). For now, the only supported digital net in base \(b &gt; 2\) is the Faure sequence.</p>
<p>Some supported point sets are nor lattice rules, nor digital nets. The Halton sequence and Hammersley net are ancestors of linear digital nets and sequences and they are implemented in ordinary and scrambled forms.</p>
<h2>Randomization and container point sets</h2>
<p>Randomization can be performed in two ways. The interface umontreal.ssj.hups.Randomization is used to specify randomizations transforming the structure of the point set, for example scrambling in the case of digital nets. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> contains an internal list of randomizations that will be applied sequentially when calling the method <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html#a075c2f760581bece484b010a8d96932a" title="Randomizes the point set using the given rand. ">umontreal.ssj.hups.PointSet.randomize</a>. The method <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html#ad094f3a4e5490d701d2117d13c219392" title="By default, this method simply calls clearRandomShift(). ">umontreal.ssj.hups.PointSet.unrandomize</a> restores the point set to its original, deterministic, structure. Other randomizations act somewhat like a filter and are implemented as container point sets. For example, the class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedPointSet.html">umontreal.ssj.hups.RandShiftedPointSet</a> represents a point set whose coordinates are shifted modulo 1 with a random factor. This shift is applied after the contained point set generates its coordinates and it can be applied to any point set.</p>
<p>The package uses container point set for other purposes than randomization. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">umontreal.ssj.hups.CachedPointSet</a> can be used to store the coordinates of a point set. It is then stored internally as a matrix and can be accessed very efficiently. The <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">umontreal.ssj.hups.SubsetOfPointSet</a> allows one to constrain a point set’s size or dimension, for example to get the dimension of a cycle-based point set finite. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">umontreal.ssj.hups.PaddedPointSet</a> gathers some coordinates of several point sets to construct a padded point set. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">umontreal.ssj.hups.AntitheticPointSet</a> allows one to switch on or off the antithetic coordinates generation.</p>
<p>Such container point sets implement their own iterators that use the iterators of the contained point sets to access the points almost as efficiently as if the contained point set iterators were used directly. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
