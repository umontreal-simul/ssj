package umontreal.ssj.stat.density;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import umontreal.ssj.functionfit.LeastSquares;
import umontreal.ssj.hups.RQMCPointSet;
import umontreal.ssj.mcqmctools.MonteCarloModelDouble;
import umontreal.ssj.mcqmctools.RQMCExperiment;
import umontreal.ssj.probdist.NormalDist;
import umontreal.ssj.stat.PgfDataTable;
import umontreal.ssj.stat.Tally;
import umontreal.ssj.util.PrintfFormat;

/**
 * Implements a parametric model that is particularly designed for the
 * estimation of the density of a random variable \f$X = g(\mathbf U)\f$, where
 * \f$\mathbf U = (U_1,U_2,\dots,U_d)\sim U(0,1)^d \f$ with a given function
 * \f$g:(0,1)^d\rightarrow\mathbb{R}\f$ over a finite interval \f$[a,b]\f$. Such
 * situations arise naturally in uncertainty quantification. The observations
 * \f$X_0,X_1,\dots,X_{n-1}\f$ which are used to construct the density will
 * typically be generated by simulation of \f$\mathbf U\f$, either by Monte
 * Carlo (MC) or by randomized quasi-Monte Carlo (RQMC).
 * 
 * The model applies to density estimators that rely on the selection of a
 * bandwidth (or binwidth) and is currently implemented for histogram
 * estimators, see @ref DEHistogram, and kernel density estimators (KDEs), see
 * \ref DEKernelDensity. An extension to other bin-/bandwidth based estimators
 * is easy to obtain as is explained further below. The model is thoroughly
 * investigated in (TODO: cite our paper) and can be explained as follows. It is
 * known in general, that the mean integrated square error (MISE) can be
 * rewritten as the sum of the integrated variance (IV) and the integrated
 * square bias
 * 
 * @f[ \textrm{MISE} = \int_a^b\mathbb{E} [\hat{f}_{n,h}(x) - f(x)]^2\mathrm{d}x
 * = \int_a^b\textrm{Var}[\hat{f}_{n,h}(x)]\mathrm{d}x + \int_a^b \left(
 * \mathbb{E}[\hat{f}_{n,h}(x)] - f(x) \right)^2\mathrm{d}x = \textrm{IV} +
 * \textrm{ISB}, @f]
 * 
 * where \f$f\f$ denotes the true density and \f$\hat{f}_{n,h}\f$ the density
 * estimator. For MC it is known that, asymptotically, \f$\textrm{IV}\approx C
 * n^{-1} h^{-1}\f$ and \f$\textrm{ISB}\approx B h^{\alpha}\f$,
 * \f$C,B,\alpha>0\f$. Observe that the power of \f$h\f$ is positive in the ISB,
 * while it appears to be negative in the IV.
 * 
 * The goal is to select an optimal band- or binwidth \f$h_*\f$ which balances
 * these two terms. This is also known as the infamous <em>variance-bias
 * tradeoff</em>. One can do so, as soon as all the parameters \f$C,B,\alpha\f$
 * are explicitly known or can be sufficiently well estimated, at least. For
 * histograms and KDEs this is indeed the case. Let \f$R(g)\f$ denote the
 * roughness functional over the interval \f$[a,b]\f$ and let \f$\mu_k(g)\f$ be
 * the \f$k\f$-th moment of a function \f$g\f$, i.e.
 * 
 * \f[ R(g) = \int_a^bg^2(x)\mathrm{d}x,\qquad\text{and}\quad
 * \mu_k(g)=\int_{-\infty}^{\infty}x^kg(x)\mathrm{d}x. \f]
 * 
 * Assuming that all the entities exist and are finite, the table below lists
 * the parameter values for histograms and KDEs for observations generated with
 * MC, see \cite tSCO15a.
 * 
 * <center>
 * <table>
 * <caption id="mc_parameters"> Asymptotically optimal parameter values with
 * MC</caption>
 * <tr>
 * <th>Parameter
 * <th>Histogram
 * <th>KDE
 * <tr>
 * <td>@f$C@f$
 * <td>1
 * <td>@f$\mu_0(K^2)@f$
 * <tr>
 * <td>@f$\alpha@f$
 * <td>2
 * <td>4
 * <tr>
 * <td>@f$B@f$
 * <td>@f$R(f')/12@f$
 * <td>@f$ \mu_2^2(K) R(f'')/4@f$
 * </table>
 * </center>
 * 
 * The only highly unpleasant quantities are the roughness functional of the
 * first or second derivative of the unknown density. This, however, can be
 * overcome by using derivative estimates as implemented in \ref
 * DensityDerivativeEstimator and plugging the results back into the expression
 * for the ISB. Here, the kernel selected for the derivative estimation is a
 * standard normal. To estimate the \f$h^{r_0}_{\text{AMISE}} \f$, where
 * \f$r_0\in\{1,2\}\f$, as can be seen in the table above, we use one step of
 * the recursion DensityDerivativeEstimator#hAmiseR(int, int, double, double[],
 * double, DensityDerivativeEstimator, double[], double[], double, double). For
 * the initial value we estimate the empirical standard deviation
 * \f$\hat{\sigma}\f$ from the observations \f$X_0,\dots,X_{n-1}\f$ and assume
 * \f$f\f$ to be a normal distribution with standard deviation
 * \f$\hat{\sigma}\f$.
 * 
 * If the user wishes to use different kernels or other initial values than
 * those stated above, it is only necessary to override the corresponding
 * methods for estimating \f$B\f$. The rest will remain intact.
 * 
 * Let us now turn to the IV. What changes with RQMC is that it can cause
 * significant variance reduction, which, however, can come at the price of a
 * worse dependency on \f$h\f$. This was proven theoretically and also observed
 * empirically in (TODO: cite our paper). To reflect this behavior, we choose
 * the model
 * 
 * \f[ \textrm{IV}\approx C n^{-\beta}h^{-\delta},\qquad \beta,\delta>1, \f]
 * 
 * locally, i.e. within a small region w.r.t. \f$(n,h)\f$. This proved to be a
 * reasonable assumption.
 * 
 * Observe that taking the logarithm of both sides of the above model assumption
 * yields a linear model with variables \f$\log n\f$ and \f$\log h\f$, and
 * unknown parameters \f$\log C,\beta,\delta\f$. Based on this linear model, one
 * can estimate the empirical IV for several reasonable values of \f$(n,h)\f$
 * with the methods provided by \ref DensityEstimator and subsequently obtain
 * estimates for the unknown parameters. Together with the estimated parameters
 * from the ISB, one can thus compute an estimate for \f$h_*\f$
 * 
 * \f[ h_* = \kappa n^{-\gamma},\qquad\text{with }\kappa = \left(\frac{C
 * \delta}{B \alpha} \right)^{1/(\alpha + \delta)},~\gamma =
 * \frac{\beta}{\alpha+\delta}, \f]
 * 
 * as well as the modeled MISE
 * 
 * \f[ \textrm{MISE} \approx Kn^{-\nu} ,\qquad\text{with } K = C
 * \kappa^{-\delta} + B \kappa^{\alpha},~\nu=\frac{\alpha\beta}{\alpha+\delta}.
 * \f]
 * 
 * The main method of this class is #testMISERate which, in turn, is made up of
 * three main components. These are #parametersIVestimate,
 * #parametersISBEstimate, and #estimateMISEOptH. The first component uses a
 * test grid w.r.t. \f$(n,h)\f$ at which it estimates the empirical IV and,
 * subsequently, estimates the IV-parameters by linear regression. The second
 * component carries out the task of computing the parameter \f$ B\f$ as
 * described above. The method #estimateMISEOptH computes the optimal
 * bin-/bandwidth \f$h_*\f$ and runs the experiment for the optimal
 * bin-/bandwidth with newly generated observations. It needs to be added that
 * two flags can be set, which are set to <tt>false</tt> by default. If
 * <tt>true</tt>, #displayExec prints output during the runtime of the program
 * and #producePlots generates plots at the end of the program. The output of
 * all the variants of the main method is a formatted string containing a
 * detailled report of the entire experiment.
 * 
 * Finally, if the user wants to use this class for other estimators than \ref
 * DEHistogram or \ref DEKernelDensity this can easily be achieved by
 * implementing the methods #setH(DensityEstimator, double),
 * #setAlpha(DensityEstimator), and #parametersISBEstimate specifically for this estimator.
 */

public class DEModelBandwidthBased {

	/** Power of \f$h\f$ in ISB */
	private double alpha;
	/** Multiplicative constant in ISB */
	private double B;
	/** Negative power of \f$n\f$ in IV */
	private double beta;
	/** Multiplicative constant in IV */
	private double C;
	/** Negative power of \f$h\f$ in IV */
	private double delta;

	/**
	 * left boundary of the interval over which we estimate.
	 */
	private double a;
	/**
	 * right boundary of the interval over which we estimate.
	 */
	private double b;
	/**
	 * flag whether to display output during running experiment or not.
	 */
	protected boolean displayExec = false;

	/**
	 * flag, whether to produce plots at the end of the experiment or not.
	 */
	protected boolean producePlots = false;

	/**
	 * base of all logarithms used in the experiment. Defaults to 2.
	 */
	protected double baseOfLog = 2.0;

	private double logOfBase = Math.log(2.0);

	/**
	 * logarithms in base #baseOfLog of the number of points.
	 */
	protected double[] logN;

	/**
	 * logarithms in base #baseOfLog of the bin-/bandwidths.
	 */
	protected double[] logH;

	/**
	 * logarithms of the optimal bandwidth h_* for each value in #logN.
	 */
	protected double[] logHOpt;

	/**
	 * The loglogarithm of the estimated empirical IV of the estimator for the pairs
	 * (n,h) in the testing region #logN \f$\times\f$ #logH.
	 */
	protected double[] logIV3D;

	/**
	 * The logarithm of the estimated empirical IV of the estimator for each element
	 * in #logN with the corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logIV;
	/**
	 * The logarithm of the estimated empirical MISE of the estimator for each
	 * element in #logN with the corresponding optimal \f$h\f$, #logHOpt. More
	 * precisely, the sum of the estimated empirical IV and the modeled ISB.
	 */
	protected double[] logMISE;

	/**
	 * The logartihm of the modelled IV for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstIV;
	/**
	 * The logartihm of the modelled ISB for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstISB;
	/**
	 * The logartihm of the modelled MISE for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstMISE;

	/**
	 * Axis labels for the 3D plots.
	 */
	private String[] tableFields3D = { "log(n)", "log(h)", "log(IV)", "estimated-log(IV)" };
	/**
	 * Axis labels for the 2D plots.
	 */
	private String[] tableFields = { "log(n)", "log(IV)", "log(MISE)", "estimated-log(IV)", "estimated-log(ISB)",
			"estimated-log(MISE)" };

	/**
	 * Constructs an instance of this parametric model over the interval
	 * \f$[a,b]\f$. The density estimator \a de is only used to determine the value
	 * for \f$\alpha\f$ and does currently only work with \ref DEHistogram and \ref
	 * DEKernelDensity. In any other case refer to #DEModelBandwidthBased(double,
	 * MonteCarloModelDouble, double, double). Or implement #setAlpha for the
	 * desired estimator.
	 * 
	 * @param de
	 *            the density estimator to obtain \f$\alpha\f$.
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(DensityEstimator de, double a, double b) {

		setRange(a, b);
		setAlpha(de);
	}

	/**
	 * Constructs an instance of this parametric model over the interval
	 * \f$[a,b]\f$.
	 * 
	 * @param alpha
	 *            the value for \f$\alpha\f$ used.
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(double alpha, double a, double b) {
		this.alpha = alpha;
		setRange(a, b);
	}

	/**
	 * Sets #displayExec, i.e. the flag whether to display output during the runtime
	 * of the experiment or not to \a displayExec.
	 * 
	 * @param displayExec
	 *            flag, whether display output during runtime or not.
	 */
	public void setDisplayExec(boolean displayExec) {
		this.displayExec = displayExec;
	}

	/**
	 * Gives #displayExec, i.e. the flag whether to display output during the
	 * runtime of the experiment or not.
	 * 
	 * @return flag, whether to display output during runtime or not.
	 */
	public boolean getDisplayExec() {
		return displayExec;
	}

	/**
	 * Sets #producePlots, i.e. the flag whether to produce plots at the end of the
	 * experiment or not to \a producePlots.
	 * 
	 * @param producePlots
	 *            flag, whether to produce plots at the end of the experiment or
	 *            not.
	 */
	public void setProducePlots(boolean producePlots) {
		this.producePlots = producePlots;
	}

	/**
	 * Gives #producePlots, i.e. the flag whether to produce plots at the end of the
	 * experiment or not.
	 * 
	 * @return flag, whether to produce plots at the end of experiment or not.
	 */
	public boolean getProducePlots() {
		return producePlots;
	}

	/**
	 * Sets the current interval over which we estimate to \f$[a,b]\f$.
	 * 
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public void setRange(double a, double b) {
		this.a = a;
		this.b = b;
	}

	/**
	 * Gives the left boundary of the interval over which we estimate.
	 * 
	 * @return the left boundary of the interval over which we estimate.
	 */
	public double geta() {
		return a;
	}

	/**
	 * Gives the right boundary of the interval over which we estimate.
	 * 
	 * @return the right boundary of the interval over which we estimate.
	 */
	public double getb() {
		return b;
	}

	/**
	 * Sets the base for all logarithms in the experiment to \a base.
	 * 
	 * @param base
	 *            the base for all logarithms.
	 */
	public void setBaseOfLog(double base) {
		this.baseOfLog = base;
		logOfBase = Math.log(base);
	}

	/**
	 * Gives the base of the logarithms in this experiment, #baseOfLog.
	 * 
	 * @return the base of the logarithms in this experiment.
	 */
	public double getBaseOfLog() {
		return baseOfLog;
	}

	/**
	 * Gives the current value of \f$alpha\f$.
	 * 
	 * @return the current value of \f$\alpha\f$.
	 */
	public double getAlpha() {
		return alpha;
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to \a alpha.
	 * 
	 * @param alpha
	 *            the desired value for \f$\alpha\f$.
	 */
	public void setAlpha(double alpha) {
		this.alpha = alpha;
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to 2.
	 * 
	 * @param de
	 */
	public void setAlpha(DEHistogram de) {
		setAlpha(2.0);
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to 4.
	 * 
	 * @param de
	 */
	public void setAlpha(DEKernelDensity de) {
		setAlpha(4.0);
	}

	/**
	 * If \a de is neither a histogram or a KDE, nor has a separate method for the
	 * type of \a de has been implemented, this method will throw an exception.
	 * 
	 * @param de
	 */
	public void setAlpha(DensityEstimator de) {
		throw new UnsupportedOperationException("setAlpha is not implemented for DesityEstimator " + de.toString()
				+ ". Either implement this" + " method or use setAlpha(double)");
	}

	/**
	 * Gives the current value of \f$B\f$.
	 * 
	 * @return the current value of \f$B\f$.
	 */
	public double getB() {
		return B;
	}

	/**
	 * Sets the current value of \f$B\f$ to \a B.
	 * 
	 * @param B
	 *            the desired value for \f$B\f$.
	 */
	public void setB(double B) {
		this.B = B;
	}

	/**
	 * Sets the current value of \f$\beta\f$ to \a beta.
	 * 
	 * @param beta
	 *            the desired value for \f$\beta\f$.
	 */
	public void setBeta(double beta) {
		this.beta = beta;
	}

	/**
	 * Gives the current value of \f$\beta\f$.
	 * 
	 * @return the current value of \f$\beta\f$.
	 */
	public double getBeta() {
		return beta;
	}

	/**
	 * Sets the current value of \f$C\f$ to \a C.
	 * 
	 * @param C
	 *            the desired value for \f$C\f$.
	 */
	public void setC(double C) {
		this.C = C;
	}

	/**
	 * Gives the current value of \f$C\f$.
	 * 
	 * @return the current value of \f$C\f$.
	 */
	public double getC() {
		return C;
	}

	/**
	 * Gives the current value of \f$\delta\f$.
	 * 
	 * @return the current value of \f$\delta\f$.
	 */
	public double getDelta() {
		return delta;
	}

	/**
	 * Sets the current value of \f$\delta\f$ to \a delta.
	 * 
	 * @param delta
	 *            the desired value for \f$\delta\f$.
	 */
	public void setDelta(double delta) {
		this.delta = delta;
	}

	/**
	 * Takes the values \f$\log_b(h)=\f$\a logH and \f$\log_b(n)=\f$\a logN, where
	 * \f$b=\f$#logOfBase, and gives the logarithm in base \f$b\f$ of the modeled
	 * IV, i.e. \f$\log_b(C h^{-\delta} n^{-\beta}) \f$.
	 * 
	 * @param logH
	 *            the logarithm in base #logOfBase of \f$h\f$.
	 * @param logN
	 *            the logarithm in base #logOfBase of \f$n\f$.
	 * @return the logarithm modeled IV in base #logOfBase.
	 */
	public double estimateLogIV(double logH, double logN) {
		return (Math.log(getC()) / logOfBase - getBeta() * logN - getDelta() * logH);
	}

	/**
	 * Takes the value \f$\log_b(h)=\f$\a logH, where \f$b=\f$#logOfBase, and gives
	 * the logarithm in base \f$b\f$ of the modeled ISB, i.e. \f$\log_b(B
	 * h^{\alpha}\f$.
	 * 
	 * @param logH
	 *            the logarithm in base #logOfBase of \f$h\f$.
	 * @return the logarithm modeled ISB in base #logOfBase.
	 */
	public double estimateLogISB(double logH) {
		return (Math.log(getB()) / logOfBase + getAlpha() * logH);
	}

	/**
	 * Takes the value \f$\log_b(n)=\f$\a logN, where \f$b=\f$#logOfBase, and gives
	 * the logarithm in base \f$b\f$ of the modeled MISE, i.e. \f$\log_b(K
	 * n^{-\nu}\f$.
	 * 
	 * @param logN
	 *            the logarithm in base #logOfBase of \f$n\f$.
	 * @return the logarithm modeled MISE in base #logOfBase.
	 */
	public double estimateLogMISE(double logN) {
		return (Math.log(getK()) / logOfBase - getNu() * logN);
	}

	/**
	 * Sets the bin width of the histogram estimator \a de to \a h.
	 * 
	 * @param de
	 *            the histogram considered.
	 * @param h
	 *            the desired bin width.
	 */
	public static void setH(DEHistogram de, double h) {
		de.setH(h);
	}

	/**
	 * Sets the bin width of the kernel density estimator \a de to \a h.
	 * 
	 * @param de
	 *            the kernel density estimator considered.
	 * @param h
	 *            the desired bin width.
	 */
	public static void setH(DEKernelDensity de, double h) {
		de.setH(h);
	}

	/**
	 * Fallback method for all density estimators \a de for which this method is not
	 * specifically implemented. Throws an \ref UnsupportedOperationException.
	 * 
	 * @param de
	 *            the density estimator considered.
	 * @param h
	 *            the desired bin width.
	 */
	public static void setH(DensityEstimator de, double h) {
		throw new UnsupportedOperationException("setH is not implemented for the DensityEstimator " + de.toString());
	}

	/**
	 * Gives #logH, the logs in base #baseOfLog of the bin-/bandwidths in the test
	 * grid for \f$(n,h)\f$.
	 * 
	 * @return the logs of the bin-/bandwidths considered.
	 */
	public double[] getLogH() {
		return logH;
	}

	/**
	 * Computes the value of \f$\nu=\frac{\alpha\beta}{\alpha+\delta}\f$ in the
	 * modeled MISE.
	 * 
	 * @return the current value of \f$\nu\f$.
	 */
	public double getNu() {
		return getAlpha() * getGamma();
	}

	/**
	 * Computes the value of the parameter \f$ \kappa = \left(\frac{C \delta}{B
	 * \alpha} \right)^{1/(\alpha + \delta)}\f$.
	 * 
	 * @return the current value of \f$\kappa\f$.
	 */
	public double getKappa() {
		return Math.pow(getC() * getDelta() / (getB() * getAlpha()), 1.0 / (getAlpha() + getDelta()));
	}

	/**
	 * Computes the value of the parameter \f$ \gamma =
	 * \frac{\beta}{\alpha+\delta}\f$.
	 * 
	 * @return the current value of \f$\gamma\f$.
	 */
	public double getGamma() {
		return getBeta() / (getAlpha() + getDelta());
	}

	/**
	 * Computes the value of the parameter \f$ K = C \kappa^{-\delta} + B
	 * \kappa^{\alpha},~\nu=\frac{\alpha\beta}{\alpha+\delta}\f$.
	 * 
	 * @return the current value of \f$K\f$.
	 */
	public double getK() {
		double kappa = getKappa();
		return getC() * Math.pow(kappa, -getDelta()) + getB() * Math.pow(kappa, getAlpha());
	}

	/**
	 * Gives #logN, the logarithms in base #baseOfLog of the numbers of observations
	 * considered.
	 * 
	 * @return the logarithms of the numbers of observations considered
	 */
	public double[] getLogN() {
		return logN;
	}

	/**
	 * Sets #logH, the logarithms in base #baseOfLog of the bin-/bandwidths used in
	 * the test grid w.r.t. \f$(n,h)\f$, to \a hArray.
	 * 
	 * @param hArray
	 *            an array containing the desired bin-/bandwidths for the test grid.
	 */
	public void setLogH(double[] hArray) {
		logH = new double[hArray.length];
		for (int i = 0; i < hArray.length; i++)
			logH[i] = Math.log(hArray[i]) / logOfBase;
	}

	/**
	 * Sets #logN, the logarithms in base #baseOfLog of the numbers of observations,
	 * to \a nArray.
	 * 
	 * @param N
	 */
	public void setLogN(int[] nArray) {
		logN = new double[nArray.length];
		for (int i = 0; i < nArray.length; i++)
			logN[i] = Math.log(nArray[i]) / logOfBase;
	}

	/**
	 * For parameter estimation of the IV this method produces and returns a
	 * formatted string containing a head with basic information that can be used as
	 * a introductory head for the estimation of the IV parameters.
	 *
	 * @param pointLabel
	 *            a description of the point set employed.
	 * @param estimatorLabel
	 *            a description of the density estimator.
	 * @param numEvalPoints
	 *            the number of evaluation points to estimate the empirical IV
	 * @param m
	 *            the number of independent replications of the observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints, int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the IV over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Same as #parametersIVFormatHead(String, String, String, int) but replaces the
	 * field for the number of evaluation points by "variable". This can be used
	 * when passing evaluation points is not necessary for IV estimation, as is the
	 * case for histograms, for instance.
	 * 
	 * @param pointLabel
	 *            a description of the point set employed.
	 * @param estimatorLabel
	 *            a description of the density estimator.
	 * @param m
	 *            the number of independent replications of the observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, int m) {
		return parametersIVFormatHead(pointLabel, estimatorLabel, "variable", m);
	}

	/**
	 * Routine to initialize #logN, #logH, and #logIV3D for the estimation of the IV
	 * parameters. The array \a rqmcPts is only used to determine the numbers of
	 * observations.
	 * 
	 * @param rqmcPts
	 *            the RQMC point set of different sizes.
	 * @param hArray
	 *            the bin-/bandwidths from the testing grid for \f$(n,h)\f$.
	 */
	public void parametersIVPreprocess(RQMCPointSet[] rqmcPts, double[] hArray) {
		logIV3D = new double[rqmcPts.length * hArray.length];
		setLogH(hArray);
		logN = new double[rqmcPts.length];
		for (int i = 0; i < rqmcPts.length; i++)
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / logOfBase;
	}

	/**
	 * Computes the data for the IV over a testing grid for \f$(n,h)\f$ and returns
	 * a formatted table as a string. More precisely, for each RQMC point set in \a
	 * rqmcPts it produces \a m independent replications of the underlying model
	 * \model. Subsequently, the density estimator \a de is evaluated at \a
	 * evalPoints for each \f$h\f$. On the basis of these evaluation the IV is
	 * estimated. The pairs \f$(n,h)\f$ are stored in \a regDataX, where \f$n\f$
	 * denotes the size of the corresponding point set, and the IV estimates are
	 * written into #logIV3D.
	 * 
	 * @param model
	 *            the underlying model.
	 * @param rqmcPts
	 *            RQMC point sets of different sizes.
	 * @param m
	 *            the number of independent replications of the model for each RQMC
	 *            point set.
	 * @param de
	 *            the density estimator considered.
	 * @param hArray
	 *            the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX
	 *            two-dimensional array to which the testing grid is stored.
	 * @param evalPoints
	 *            the evaluation points used for estimating the empirical IV.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DensityEstimator de, double[] hArray, double[][] regDataX, double[] evalPoints) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");

		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				setH(de, hArray[j]);
				density = new double[m][evalPoints.length];
				density = de.evalDensity(evalPoints, data, a, b);

				variance = new double[evalPoints.length];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ logOfBase;

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();
	}

	/**
	 * Similar to #parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[],
	 * int, DensityEstimator, double[], double[][], double[]), but specifically for
	 * histograms. Recall that passing evaluation points is not necessary for a \ref
	 * DEHistogram, as the IV is constant on each bin.
	 * 
	 * @param model
	 *            the underlying model.
	 * @param rqmcPts
	 *            RQMC point sets of different sizes.
	 * @param m
	 *            the number of independent replications of the model for each RQMC
	 *            point set.
	 * @param de
	 *            the density estimator considered.
	 * @param hArray
	 *            the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX
	 *            two-dimensional array to which the testing grid is stored.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[][] regDataX) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");

		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				de.setH(hArray[j]);
				density = new double[m][de.getNumBins()];
				density = de.evalDensity(data, a, b);

				variance = new double[de.getNumBins()];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ logOfBase;

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();
	}

	/**
	 * Same as #parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[],
	 * int, DEHistogram, double[], double[][]), but contains one placeholder
	 * parameter to match the structure of
	 * parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[], int,
	 * DensityEstimator, double[], double[][], double[])
	 * 
	 * @param model
	 *            the underlying model.
	 * @param rqmcPts
	 *            RQMC point sets of different sizes.
	 * @param m
	 *            the number of independent replications of the model for each RQMC
	 *            point set.
	 * @param de
	 *            the density estimator considered.
	 * @param hArray
	 *            the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX
	 *            two-dimensional array to which the testing grid is stored.
	 * @param evalPoints
	 *            placeholder.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[][] regDataX, double[] evalPoints) {
		return parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX);
	}

	/**
	 * Takes the testing grid for \f$(n,h)\f$ in \a regDataX and performs a linear
	 * regression with the data saved in #logIV3D. Subsequently, it sets the
	 * parameters \f$C\f$, \f$\beta\f$, and \f$delta\f$ to the values obtained.
	 * 
	 * @param regDataX
	 *            the testing grid \f$(n,h)\f$.
	 */
	public void parametersIVComputeCoefficients(double[][] regDataX) {
		double[] regCoeffs = LeastSquares.calcCoefficients0(regDataX, logIV3D);
		setC(Math.pow(baseOfLog, regCoeffs[0]));
		setBeta(-regCoeffs[1]);
		setDelta(-regCoeffs[2]);
	}

	/**
	 * Gives the current values of the parameters \f$C\f$, \f$\beta\f$, and
	 * \f$delta\f$ as formatted string.
	 * 
	 * @return the IV parameters in a formatted string.
	 */
	public String parametersIVFormatCoefficients() {

		String str = "Estimated IV-parameters:\n";
		str += "-------------------------------------";
		str += "C =\t" + getC() + "\n";
		str += "beta =\t" + getBeta() + "\n";
		str += "delta =\t" + getDelta() + "\n\n";

		if (displayExec)
			System.out.print(str);

		return str;
	}

	/**
	 * Same as #parametersIVEstimate(MonteCarloModelDouble, RQMCPointSet[], int,
	 * DEHistogram, double[]), but without passing evaluation points. Recall that
	 * the IV is constant on each bin of the histogram, so considering one
	 * evaluation point per bin only is usually more efficient.
	 * 
	 * 
	 * @param rqmcPts
	 *            the RQMC point sets to construct the observation.
	 * @param model
	 *            the underlying model, from which the observations are obtained.
	 * @param m
	 *            the number of independent repetitions.
	 * @param de
	 *            the histogram.
	 * @param hArray
	 *            the values for \f$h\f$ of the testing region.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray) {
		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();
	}

	/**
	 * This method is the core function for estimating the IV parameters \f$C\f$,
	 * \f$\beta\f$, and \f$delta\f$ by estimating the empirical IV over a testing
	 * region for \f$(n,h)\f$ and, subsequently, performing a linear regression.
	 * 
	 * More precisely, \a rqmcPts is intended to contain the same type of point set
	 * in different sizes \f$n\f$. These sizes are the \f$n\f$-values for the
	 * testing region. The \f$h\f$-values are passed in \a hArray. For every point
	 * in \a rqmcPts it generates observations of \a model. This is repeated \f$m\f$
	 * times independently. On the basis of these observations it estimates the
	 * empirical IV for every \f$h\f$ in \a hArray. The evaluation points used to
	 * estimate the empirical IV are passed in \a evalPoints The estimated IVs are
	 * stored in #logIV3D. Finally, this data is used to estimate the parameters by
	 * a linear regression.
	 * 
	 * 
	 * The string which is returned is composed of an introductory heading, a table
	 * showing the results of the estimates of the empirical IV for different
	 * \f$n\f$ and \f$h\f$, and a formatted output of the estimated parameters
	 * \f$C\f$, \f$\beta\f$, and \f$delta\f$ so that the details of this experiment
	 * can be written to a file. If the user wishes to display output at runtime as
	 * well, simply set #displayExec to <tt>true<\tt>.
	 * 
	 * The way this method works is by calling #parametersIVPreprocess,
	 * #parametersIVFormatHead, #parametersIVComputeRegData,
	 * #parametersIVComputeCoefficients, and #parametersIVFormatCoefficients
	 * sequentially.
	 * 
	 * @param rqmcPts
	 *            the RQMC point sets to construct the observation.
	 * @param model
	 *            the underlying model, from which the observations are obtained.
	 * @param m
	 *            the number of independent repetitions.
	 * @param de
	 *            the histogram.
	 * @param hArray
	 *            the values for \f$h\f$ of the testing region.
	 * @param evalPoints
	 *            the evaluation points used to estimate the empirical IV.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] hArray, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX, evalPoints));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();

	}

	/**
	 * Computes the roughness functional for the \a order -th derivative of the
	 * density of a normal distribution with parameters (\a mu,\a sigma) over
	 * \f$[a,b]\f$. As for now, only 3 and 4 are allowed values of \a order, any
	 * other will throw an exception.
	 * 
	 * @param order
	 *            the order of the derivative. Must be 3 or 4.
	 * @param mu
	 *            the mean.
	 * @param sigma
	 *            the standard deviation.
	 * @return the roughness functional for the \a order -th derivative of the
	 *         density of a normal distribution with parameters (\a mu,\a sigma).
	 */
	public double setInitRoughnessFunctional(int order, double mu, double sigma) {
		double result = 0.0;
		double sqrtPi = Math.sqrt(Math.PI);
		double aTerm = (mu - a) / sigma;
		double bTerm = (b - mu) / sigma;
		double pdfA = NormalDist.density(mu, sigma, a);
		double pdfB = NormalDist.density(mu, sigma, b);

		if (order == 4) {
			result = pdfA * pdfA * aTerm * (8.0 * Math.pow(aTerm, 6.0) - 68.0 * aTerm * aTerm * aTerm * aTerm
					+ 166.0 * aTerm * aTerm - 39.0);
			result += pdfB * pdfB * bTerm * (8.0 * Math.pow(bTerm, 6.0) - 68.0 * bTerm * bTerm * bTerm * bTerm
					+ 166.0 * bTerm * bTerm - 39.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 105.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (32.0 * sqrtPi * Math.pow(sigma, 9.0));
		}

		else if (order == 3) {

			result = pdfA * pdfA * aTerm * (4.0 * aTerm * aTerm * aTerm * aTerm - 14.0 * aTerm * aTerm + 15.0);
			result += pdfB * pdfB * bTerm * (4.0 * bTerm * bTerm * bTerm * bTerm - 14.0 * bTerm * bTerm + 15.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 15.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (16.0 * sqrtPi * Math.pow(sigma, 7.0));
		}

		else {
			throw new UnsupportedOperationException(
					"setInitRoughnessFunctional is not implemented for the order " + order);
		}
	}

	/**
	 * Estimates the parameter \f$B\f$ according to the formula from the table given
	 * above. This is done by generating \f$n\f$ observations of \a model with the
	 * RQMC points \a rqmc. It computes the empirical mean \f$\hat{\mu}\f$ and
	 * standard deviation \f$\hat{\sigma}\f$ of these observations and uses them to
	 * obtain an initial value for the roughness functional of the sought density of
	 * order \a order + 2 over \f$[a,b]\f$. This initial value is computed as the
	 * roughness functional of the density of a normal distribution with parameters
	 * \f$(Ä§at{\mu},\hat{\sigma})\f$. It then iterates once over the recursive
	 * formula for the optimal bin-/bandwidth given in \ref
	 * umontreal.ssj.stat.density.DensityDerivativeEstimator with
	 * umontreal.ssj.stat.density.DEDerivativeGaussian#hAmiseR. Using this optimal
	 * bin-/bandwidth, it estimates the derivative of order \a order of the sought
	 * density by a \ref umontreal.ssj.stat.density.DEDerivativeGaussian.
	 * 
	 * This procedure is repeated \f$m\f$ times, each time with \a rqmc randomized
	 * afresh and the mean of the result is set as \f$B\f$s.
	 * 
	 * Note that, for estimating B \a order has actually to be 1 or 2. This is
	 * implicitly assumed, as #setInitRoughnessFunctional would throw an exception
	 * here for any other order.
	 * 
	 * 
	 * 
	 * @param model
	 *            the underlying model.
	 * @param rqmc
	 *            the RQMC point set used.
	 * @param m the number of independent replications.
	 * @param evalPoints the evaluation points to estimate the roughness functionals.
	 * @param order the sought order of the derivative of the density. Has to be 1 or 2 for a histogram or a kernel density estimator, respectively.
	 * @param factor the factor with which the respective roughness functional is multiplied to yield \f$B\f$. For a histogram this is 1/4 and for
	 * a KDE 1/12.
	 */
	public void estimateB(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, double[] evalPoints, int order,
			double factor) {
		double[][] data = new double[m][];
		Tally statReps = new Tally();
		RQMCExperiment.simulReplicatesRQMC(model, rqmc, m, statReps, data);
		int n = rqmc.getNumPoints();

		DEDerivativeGaussian dde = new DEDerivativeGaussian(order);
		double[] muSigma = new double[2];
		double init;
		double h;
		double mu2Derivative = DensityDerivativeEstimator.densityFunctionalGaussian(order, 1.0);
		double[] density = new double[evalPoints.length];
		double rf = 0.0;

		for (int rep = 0; rep < m; rep++) {
			muSigma = estimateMeanAndStdDeviation(data[rep]);
			init = setInitRoughnessFunctional(order + 2, muSigma[0], muSigma[1]);
			h = DEDerivativeGaussian.hAmiseR(order, 1.0, mu2Derivative, init, n);
			dde.setH(h);
			density = dde.evalDensity(evalPoints, data[rep], a, b);
			rf += DensityEstimator.roughnessFunctional(density, a, b);
		}

		rf /= (double) m;
		setB(factor * rf);
	}

	/**
	 * For parameter estimation of the ISB this method produces and returns a
	 * formatted string containing a head with basic information that can be used as
	 * a introductory head for the estimation of the ISB parameters.
	 * @param pointLabel short description of the RQMC point set.
	 * @param estimatorLabel short description of the estimator used.
	 * @param numEvalPoints the number of evaluation points to compute the roughness functionals.
	 * @param m number of independent replications.
	 * @param n the number of points considered, i.e. the size of the point set.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersISBFormatHead(String pointLabel, String estimatorLabel, int numEvalPoints, int m, int n) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the ISB over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of points: " + n + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Gives the current values of the parameters \f$\alpha\f$ and \f$B\f$ as formatted string.
	 * 
	 * @return the ISB parameters in a formatted string.
	 */
	public String parametersISBFormatCoefficients() {
		String str = "ISB-parameters:\n";
		str += "-------------------------------------\n";
		str += "alpha =\t" + getAlpha() + "\n";
		str += "B =\t" + getB() + "\n\n";
		if (displayExec)
			System.out.print(str);
		return str;
	}

	/**
	 * Carries out the estimation of the parameter \f$B\f$ in the ISB for a \ref DEKernelDensity. More precisely,
	 *  it sets the necessary parameters to compute the estimate \f$B\f$ an then calls #estimateB. The string which
	 *  is being returned is composed of the results from #parametersISBFormatHead and #parametersISBFormatCoefficients.
	 * @param model the underlying model.
	 * @param rqmc the RQMC point set used.
	 * @param m the number of independent replications.
	 * @param de the kernel density estimator.
	 * @param evalPoints the evaluation points used to estimate the roughness functionals.
	 * @return a formatted report on the experiment.
	 */
	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEKernelDensity de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");

		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Kernel density estimator", evalPoints.length, m,
				rqmc.getNumPoints()));

		int order = 2;
		double factor = 0.25;

		estimateB(model, rqmc, m, evalPoints, order, factor);

		sb.append(parametersISBFormatCoefficients());

		return sb.toString();
	}
	
	/**
	 * Same as #parametersISBEstimate(MonteCarloModelDouble, RQMCPointSet, int, DEKernelDensity, double[]) but
	 * for a histogram instead of a kernel density estimator.
	 * @param model the underlying model.
	 * @param rqmc the RQMC point set used.
	 * @param m the number of independent replications.
	 * @param de the kernel density estimator.
	 * @param evalPoints the evaluation points used to estimate the roughness functionals.
	 * @return a formatted report on the experiment.
	 */
	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEHistogram de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");

		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Histogram", evalPoints.length, m, rqmc.getNumPoints()));

		int order = 1;
		double factor = 1.0 / 12.0;

		estimateB(model, rqmc, m, evalPoints, order, factor);

		sb.append(parametersISBFormatCoefficients());

		return sb.toString();
	}

	/**
	 * Fallback method for all density estimators \a de for which this method is not
	 * specifically implemented. Throws an \ref UnsupportedOperationException.
	 * @param model the underlying model.
	 * @param rqmc the RQMC point set used.
	 * @param m the number of independent replications.
	 * @param de the kernel density estimator.
	 * @param evalPoints the evaluation points used to estimate the roughness functionals.
	 * @return a formatted report on the experiment.
	 */
	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DensityEstimator de,
			double[] evalPoints) {
		throw new UnsupportedOperationException(
				"parametersISBEstimate is not implemented for the DensityEstimator " + de.toString());
	}

	/**
	 * Produces a formatted string containing the model parameters \f$\gamma,\kappa, K,\f$ and \f$\nu\f$.
	 * @return a formatted string showing \f$\gamma,\kappa, K,\f$ and \f$\nu\f$.
	 */
	public String parametersMISEFormatCoefficients() {
		StringBuffer sb = new StringBuffer("");
		sb.append("MISE-parameters: \n");
		sb.append("-------------------------------------\n");
		sb.append("gamma =\t" + getGamma() + "\n");
		sb.append("kappa =\t" + getKappa() + "\n");
		sb.append("K =\t" + getK() + "\n");
		sb.append("nu =\t" + getNu() + "\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * For running the experiment with the optimal \f$h_*\f$ this method produces a formatted string
	 * carrying basic information that can be used as a introductory head.
	 *
	 * @param pointLabel
	 *            a description of the point set employed.
	 * @param estimatorLabel
	 *            a description of the density estimator.
	 * @param numEvalPoints
	 *            the number of evaluation points to estimate the empirical IV
	 * @param m
	 *            the number of independent replications of the observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints, int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Estimation of MISE rate with optimal h over [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel, int m) {
		return estimateMISEOptHFormatHead(pointLabel, estimatorLabel, "variable", m);
	}

	public void estimateMISEOptHPreprocess(RQMCPointSet[] rqmcPts) {
		logN = new double[rqmcPts.length];
		logHOpt = new double[logN.length];
		for (int i = 0; i < rqmcPts.length; i++) {
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / logOfBase;
			logHOpt[i] = Math.log(getKappa()) / logOfBase - getGamma() * logN[i];
		}
		logEstIV = new double[logN.length];
		logEstISB = new double[logN.length];
		logEstMISE = new double[logN.length];
		for (int i = 0; i < logN.length; i++) {
			logEstIV[i] = estimateLogIV(logHOpt[i], logN[i]);
			logEstISB[i] = estimateLogISB(logHOpt[i]);
			logEstMISE[i] = estimateLogMISE(logN[i]);
		}

		logIV = new double[logN.length];
		logMISE = new double[logN.length];
	}

	public String estimateMISEOptHComputeTable(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DEHistogram de) {

		StringBuffer sb = new StringBuffer("");
		String str;

		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;

		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i

			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			de.setH(Math.pow(baseOfLog, logHOpt[i]));
			density = new double[m][de.getNumBins()];
			density = de.evalDensity(data, a, b);

			variance = new double[de.getNumBins()];

			logIV[i] = DensityEstimator.computeIV(density, a, b, variance);
			logMISE[i] = logIV[i] + logEstISB[i];

			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logHOpt[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n ";

			sb.append(str);
			if (displayExec)
				System.out.print(str);

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	public String estimateMISEOptHComputeTable(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DensityEstimator de, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");
		String str;

		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;

		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i

			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			setH(de, Math.pow(baseOfLog, logHOpt[i]));
			density = new double[m][evalPoints.length];
			density = de.evalDensity(evalPoints, data, a, b);

			variance = new double[evalPoints.length];

			logIV[i] = DensityEstimator.computeIV(density, a, b, variance);
			logMISE[i] = logIV[i] + logEstISB[i];

			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logHOpt[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n ";

			sb.append(str);
			if (displayExec)
				System.out.print(str);

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	public String estimateMISEOptHRsqIV() {
		String str = "Coefficient of determination:\n";
		str += "********************************************\n\n";
		str += "R^2 for IV: " + DensityEstimator.coefficientOfDetermination(logIV, logEstIV) + "\n\n";
		if (displayExec)
			System.out.print(str);
		return str;
	}

	public String estimateMISEOptHSlopes() {
		double[] regCoeffs = new double[2];

		String str = "Regression data:\n";
		str += "********************************************\n\n";
		str += "IV:\n";

		regCoeffs = LeastSquares.calcCoefficients(logN, logIV);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";
		str += "MISE:\n";
		regCoeffs = LeastSquares.calcCoefficients(logN, logMISE);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";

		if (displayExec)
			System.out.print(str);
		return str;
	}

	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de) {
		StringBuffer sb = new StringBuffer("");
		sb.append(estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), "Histogram", m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append(estimateMISEOptHComputeTable(model, rqmcPts, m, de));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] evalPoints) {
		return estimateMISEOptH(model, rqmcPts, m, de);
	}

	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		sb.append(estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length),
				m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append(estimateMISEOptHComputeTable(model, rqmcPts, m, de, evalPoints));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	public String testMISERateFormatHead(MonteCarloModelDouble model) {
		StringBuffer sb = new StringBuffer("");
		sb.append("DENSITY ESTIMATION\n");
		sb.append("************************************************\n");
		sb.append("Density estimation with the bandwidth-based parametric model for\n");
		sb.append(model.toString());
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	public String testMISERate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] hArray, double[] evalPoints, boolean genSinglePlots2D) throws IOException {
		StringBuffer sb = new StringBuffer("");
		sb.append(testMISERateFormatHead(model));

		sb.append(parametersIVEstimate(model, rqmcPts, m, de, hArray, evalPoints));
		sb.append(parametersISBEstimate(model, rqmcPts[rqmcPts.length - 1], m, de, evalPoints));
		sb.append(parametersMISEFormatCoefficients());
		sb.append(estimateMISEOptH(model, rqmcPts, m, de, evalPoints));

		if (producePlots) {
			genPlots3D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
			if (genSinglePlots2D)
				genPlots2D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
		}

		return sb.toString();
	}

	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			DensityEstimator de, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		ArrayList<PgfDataTable> pgfTblList = new ArrayList<PgfDataTable>();
		for (RQMCPointSet[] rqmcPts : rqmcPtsList) {
			sb.append(testMISERate(model, rqmcPts, m, de, hArray, evalPoints, false));
			if (producePlots)
				pgfTblList.add(genPgfDataTable(rqmcPts[0].getLabel(), rqmcPts[0].getLabel()));
		}

		return sb.toString();
	}

	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			ArrayList<DensityEstimator> deList, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		for (DensityEstimator de : deList)
			sb.append(testMISERate(model, rqmcPtsList, m, de, hArray, evalPoints));
		return sb.toString();
	}

	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			ArrayList<DensityEstimator> deList, ArrayList<double[]> hArrayList, double[] evalPoints)
			throws IOException {
		StringBuffer sb = new StringBuffer("");
		int len = deList.size();
		for (int l = 0; l < len; l++)
			sb.append(testMISERate(model, rqmcPtsList, m, deList.get(l), hArrayList.get(l), evalPoints));
		return sb.toString();
	}

	public PgfDataTable genPgfDataTable3D(String tableName, String tableLabel) {
		int len = logN.length * logH.length;
		double[][] pgfData = new double[len][4];
		for (int i = 0; i < len; i++) {
			pgfData[i][0] = logN[i];
			pgfData[i][1] = logH[i];
			pgfData[i][2] = logIV3D[i];
			pgfData[i][3] = estimateLogIV(logH[i], logN[i]);
		}
		return new PgfDataTable(tableName, tableLabel, tableFields3D, pgfData);

	}

	public PgfDataTable genPgfDataTable(String tableName, String tableLabel) {
		int len = logN.length;
		double[][] pgfData = new double[len][tableFields.length];
		for (int i = 0; i < len; i++) {
			pgfData[i][0] = logN[i];
			pgfData[i][1] = logIV[i];
			pgfData[i][2] = logMISE[i];
			pgfData[i][3] = logEstIV[i];
			pgfData[i][4] = logEstISB[i];
			pgfData[i][5] = logEstMISE[i];
		}
		return new PgfDataTable(tableName, tableLabel, tableFields, pgfData);
	}

	public void genPlots2D(String modelDescr, String deDescr, String pointSetDescr) throws IOException {
		FileWriter fw;
		String plotBody;

		PgfDataTable pgfTbl = genPgfDataTable3D(modelDescr + "-" + deDescr + "-" + pointSetDescr, "2D-traits");

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_IVoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(IV) with opt. h", "axis", 0, 1, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_MISEoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(MISE) with opt. h", "axis", 0, 2, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estIVoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(IV) with opt. h", "axis", 0, 3, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estISBoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(ISB) with opt. h", "axis", 0, 4, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estMISEoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(MISE) with opt. h", "axis", 0, 5, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();
	}

	public void genPlots2D(String modelDescr, String deDescr, ArrayList<PgfDataTable> pgfTblList) throws IOException {
		FileWriter fw;
		String plotBody;

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Empirical log(IV) with opt. h", "axis", 0, 1, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_IVoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Empirical log(MISE) with opt. h", "axis", 0, 2, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_MISEoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(IV) with opt. h", "axis", 0, 3, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estIVoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(ISB) with opt. h", "axis", 0, 4, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estISBoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(MISE) with opt. h", "axis", 0, 5, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estMISEoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();
	}

	public void genPlots3D(String modelDescr, String deDescr, String pointSetDescr) {
		PgfDataTable pgfTbl = genPgfDataTable3D(modelDescr + "-" + deDescr + "-" + pointSetDescr, "3D-traits");
		String plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(IV) over test-grid with " + pointSetDescr,
				"axis", 0, 1, 2, (int) baseOfLog, "", " surf, faceted color=red");
		try {
			FileWriter fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_IV3D.tex");
			fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
			fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

		plotBody = pgfTbl.drawPgfPlotSingleCurve("Estimated log(IV) over test-grid with " + pointSetDescr, "axis", 0, 1,
				3, (int) baseOfLog, "", " surf, faceted color=red");

		try {
			FileWriter fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estIV3D.tex");
			fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
			fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Computes the mean and the standard deviation of the observations given in \a
	 * data.
	 * 
	 * 
	 * @param data
	 *            the observations.
	 * @return the mean and standard deviation.
	 */

	private static double[] estimateMeanAndStdDeviation(double[] data) {
		double[] result = new double[2];
		int n = data.length;
		double x, y;

		double mean = 0.0;
		double var = 0.0;
		for (int i = 0; i < n; i++) {
			x = data[i];
			y = x - mean;
			mean += y / ((double) (i + 1.0));
			var += y * (x - mean);
		}

		result[0] = mean;
		result[1] = Math.sqrt(var / ((double) n - 1.0));
		return result;
	}
}
