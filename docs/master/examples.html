<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSJ: SSJ introduction and tutorial by examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ["script","noscript","style","textarea","pre"]
  }
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SSJ
   &#160;<span id="projectnumber">3.3.0</span>
   </div>
   <div id="projectbrief">Stochastic Simulation in Java</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SSJ introduction and tutorial by examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="REF_examples_sec_01"></a>
Introduction</h1>
<p>This document provides an introduction to SSJ via a series of examples. We first give a brief overview of some basic facilities to generate random numbers, handle probability distributions, collect statistics, and manage event lists, for example. An overview of how SSJ is organized in various inter-related packages can be found on the main page, in the <a class="el" href="index.html#REF_0_sec_01">Introduction and overview</a> Section. Our series of examples start with elementary Monte Carlo experiments in which we show how to generate random variates to simulate a model, collect statistics, and make some plots from the results. We show how to generate vectors from multivariate distributions and stochastic processes, and how the random numbers can be replaced by randomized quasi-Monte Carlo points. Later, we provide more elaborate examples of discrete-event simulations. The Java code of all the examples is available with the SSJ source code in the src/main/java/tutorial/ directory.</p>
<p>While studying the examples, one can refer to the functional definitions (the APIs) of the SSJ classes. Before that, we recommand looking at the short overview of the different packages in the <a class="el" href="index.html#REF_0_sec_01">Introduction and overview</a> on the main page, then the overview given below, and perhaps the overview of each package given at the beginning of its documentation, to have a general idea of what is available and where.</p>
<hr/>
<h1><a class="anchor" id="REF_examples_sec_overview"></a>
Quick Overview of Some Key Packages</h1>
<h2><a class="anchor" id="REF_examples_sec_random"></a>
Random number and variate generation</h2>
<p>Random numbers feed simulation models and Monte Carlo experiments. To simulate random variables from a given probability distribution, one typically starts from independent uniform random numbers, uniformly distributed over the interval \([0,1)\), and transform these numbers appropriately to obtain the desired distribution. The so-called <em>uniform random numbers</em> produced by SSJ and other simulation software are of course <em>not</em> truly random and independent. They are only imitations produced by deterministic mathematical algorithms, and are sometimes called <em>pseudorandom</em>. Nevertheless, they are very good imitations from a statistical viewpoint, and we follow the common usage in the simulation community of just calling them random numbers <a class="el" href="citelist.html#CITEREF_sLAW14a">[117]</a>, <a class="el" href="citelist.html#CITEREF_rLEC90a">[140]</a>, <a class="el" href="citelist.html#CITEREF_rLEC17h">[152]</a>. An important consequence of the deterministic nature of these algorithmic random number generators (RNGs) is that if you run the same simulation program several times, unless you reset the seed of the RNG, you will get exactly the same results each time. This is really not like throwing a dice or flipping a coin, but this behavior is actually desirable. The ability to reproduce Monte Carlo experiments with exactly the same random numbers is a key advantage (and requirement) in modern simulation software <a class="el" href="citelist.html#CITEREF_sLAW14a">[117]</a>, <a class="el" href="citelist.html#CITEREF_rLEC12a">[150]</a>, <a class="el" href="citelist.html#CITEREF_rLEC15a">[151]</a>, <a class="el" href="citelist.html#CITEREF_rLEC17h">[152]</a>, <a class="el" href="citelist.html#CITEREF_rLEC17p">[139]</a>.</p>
<p>The selection of an RNG is based on several criteria such as uniformity, performance, and portability <a class="el" href="citelist.html#CITEREF_rLEC94a">[141]</a>, <a class="el" href="citelist.html#CITEREF_rLEC12a">[150]</a>&thinsp;. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal.ssj.rng</a> provides basic tools to generate uniform random numbers. It defines an interface called <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> implemented by any RNG supported by SSJ. This interface requires that each RNG provides multiple streams and substreams of random numbers. Such facilities are very useful when performing multiple simulation runs and comparing similar systems by simulation, for example <a class="el" href="citelist.html#CITEREF_rLEC15a">[151]</a>, <a class="el" href="citelist.html#CITEREF_rLEC15c">[137]</a>, <a class="el" href="citelist.html#CITEREF_rLEC17p">[139]</a>. The interface permits one to easily interchange RNGs without changing the code of the simulator, because they are accessed through the same set of methods specified by the interface. The selected type of RNG is specified when creating the <code>RandomStream</code> object.</p>
<p>One can also easily replace the 'independent' random numbers with (possibly randomized) highly-uniform (quasi-Monte Carlo) point sets implemented in the package <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal.ssj.hups</a>&thinsp;, again without changing the simulation code. The point set objects all inherit from <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> which provides a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> that implements the same <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> interface as the RNGs. The replacement of random numbers by quasi-random ones can be easily done without modifying the model implementation, except for the setup code that creates the point sets.</p>
<p>The package <a class="el" href="namespaceumontreal_1_1ssj_1_1latnetbuilder.html">umontreal.ssj.latnetbuilder</a> provides an interface to the <em>LatNet Builder</em> software, implemented in C++, which provides tools to construct hups of various types such as lattices, polynomial lattices, digital nets, etc., in arbitrary dimension, for an arbitrary number of points, a rich variety of uniformity criteria, etc. Note that LatNet Builder uses the NTL library and for this reason it does not run under Windows, but only under Linux-type systems.</p>
<p>To generate non-uniform random numbers, one can select a probability distribution from the <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal.ssj.probdist</a> package and a <code>RandomStream</code> object as a source of randomness. The probability distribution may have been estimated in a modeling phase based on data from the system of interest, or selected in any other way. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal.ssj.probdist</a> contains several commonly-used discrete and continuous distributions, implemented as subclasses of the abstract classes <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">umontreal.ssj.probdist.ContinuousDistribution</a> and <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1DiscreteDistribution.html">umontreal.ssj.probdist.DiscreteDistribution</a>. The methods to access the density or mass, cdf, complementary cdf, inverse cdf, mean, variance, etc., are common to all distributions, so much of the code may be written independently of the selected distribution. Static methods are also available for the case where one does not want to create a distribution object with fixed parameters, which often involves significant overhead because it precomputes constants and tables. This precomputation setup is often worthwhile if the same distribution (with same parameters) is used many times, but not if the parameters change all the time, in which case the setup has to be redone each time.</p>
<p>The default (most general) way of defining a non-uniform generator is to match a distribution with a <code>RandomStream</code>. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal.ssj.randvar</a> provides facilities to do that. By default, the random variates are obtained by applying the inverse cdf (computed via the <code>inverseF</code> method) to the uniform random numbers obtained from the stream. However, inversion is sometimes too slow or inapplicable (the inverse cdf or even a good approximation of it may be too hard to compute). The package <a class="el" href="namespaceumontreal_1_1ssj_1_1randvar.html">umontreal.ssj.randvar</a> permits one to generate non-uniform randm variates in many other ways than by inversion. In particular, it offers classes to generate random variates from specific discrete and continuous distributions by specialized methods, without relying on the <code>probdist</code> package. These specific generators inherit from the common classes <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGen.html">umontreal.ssj.randvar.RandomVariateGen</a> and <a class="el" href="classumontreal_1_1ssj_1_1randvar_1_1RandomVariateGenInt.html">umontreal.ssj.randvar.RandomVariateGenInt</a>&thinsp;. Each specialized class provides a static method which can be preferable to use when it is not worthwhile to create a generator object and make the associated precomputations. One drawback of these static methods, however, is that their signatures that are specific to the distribution, because they must transmit the distribution parameters, and therefore one may have to change the simulation code when changing a distribution. They may also have to perform setup operations on each variate generation.</p>
<p>The packages <a class="el" href="namespaceumontreal_1_1ssj_1_1probdistmulti.html">umontreal.ssj.probdistmulti</a> and <a class="el" href="namespaceumontreal_1_1ssj_1_1randvarmulti.html">umontreal.ssj.randvarmulti</a> are the counterparts of <code>probdist</code> and <code>randvar</code> for multivariate distributions. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1stochprocess.html">umontreal.ssj.stochprocess</a> offers tools to generate discretely observed sample paths (skeletons) of various types of stochastic processes.</p>
<h2><a class="anchor" id="REF_examples_sec_stat"></a>
Collecting statistics</h2>
<p>Output from simulations is collected in <em>statistical probes</em> that implement the abstract class <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1StatProbe.html">umontreal.ssj.stat.StatProbe</a> from the <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal.ssj.stat</a> package. There are two main types of probes: <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">umontreal.ssj.stat.Tally</a> probes collect series of observations of the form \(X_1,…,X_n\) whereas <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Accumulate.html">umontreal.ssj.simevents.Accumulate</a> probes collect statistics for a process that evolves in continuous (simulated) time, with a piecewise-constant trajectory. During the simulation, one can add observations to such probes. After the simulation (or at any time), measures such as the sample average, the sample variance or standard deviation, confidence intervals, etc., can be observed. Statistical reports can also be obtained for the different probes, in the form of a character <code>String</code> that can be displayed or printed. The <code>stat</code> package also provides a way to detach statistical collection from the model implementation by using bound properties.</p>
<p>The observations given to a statistical probe can be arrays of real numbers, whose dimension is the number of fields on which data is collected. After n observations are collected, the probe will contain (virtually) a table whose rows are the observations and whose columns are the fields. In addition to the empirical means, variances, etc., for the individual fields, one can also obtain empirical covariances and correlations between the fields, and other measures of dependence.</p>
<p>Subpackages of <code>stat</code> provide facilities to manage lists or arrays of statistical probes. The package <a class="el" href="namespaceumontreal_1_1ssj_1_1gof.html">umontreal.ssj.gof</a> implements goodness-of-fit tests such as Kolmogorov-Smirnov and Anderson-Darling tests.</p>
<p><a class="el" href="namespaceumontreal_1_1ssj_1_1simexp.html">umontreal.ssj.simexp</a> and <a class="el" href="namespaceumontreal_1_1ssj_1_1mcqmctools.html">umontreal.ssj.mcqmctools</a> provide additional facilities for performing simulation experiments using independent replications, batch means, and (randomized) quasi-Monte Carlo methods.</p>
<h2><a class="anchor" id="REF_examples_sec_discrete-event"></a>
Running discrete-event simulations</h2>
<p>SSJ supports discrete-event, continuous, and mixed simulation, via the package <a class="el" href="namespaceumontreal_1_1ssj_1_1simevents.html">umontreal.ssj.simevents</a>. This package manages the simulation clock and the event list, two essential components of discrete-event simulations. The simulation clock tracks the simulation time whereas the event list stores the scheduled events to execute them in the right order. Events are user-defined subclasses of <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html">umontreal.ssj.simevents.Event</a>. When an event occurs, any type of actions can then be taken. The package provides a class called <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1ListWithStat.html">umontreal.ssj.simevents.ListWithStat</a> which implements a linked list with integrated statistical probes to collect data on sojourn times in the list and the time-dependent size of the list. Continuous simulation can be performed using the class <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html">umontreal.ssj.simevents.Continuous</a>. It uses the event framework to (approximately) simulate differential equations numerically with time discretization.</p>
<hr/>
<h1><a class="anchor" id="REF_examples_sec_simple"></a>
Some Elementary Examples</h1>
<p>We start with elementary examples that illustrate how to generate uniform and nonuniform random numbers, construct probability distributions, collect elementary statistics, compute confidence intervals, compare similar systems, and use randomized quasi-Monte Carlo point sets, with SSJ. The models considered here are quite simple and some of the performance measures may be computed by numerical methods rather than by simulation. The purpose of these simple models is just to give a first idea of how to use SSJ.</p>
<h2><a class="anchor" id="REF_examples_sec_collision"></a>
Collisions in a hashing system</h2>
<p>We want to estimate the distribution of the number of collisions in a hashing system. There are \(k\) locations (or addresses) and \(m\) distinct items. Each item is assigned a random location, independently of the other items. A <em>collision</em> occurs each time an item is assigned a location already occupied. Let \(C\) be the number of collisions. We want to estimate the probability distribution of the random variable \(C\), as well as its expectation \(\mathbb E[C]\) and variance Var \([C]\), by simulation. A theorem states that when \(k\to\infty\) while \(\lambda= m^2/(2k)\) remains fixed, \(C\) converges in distribution to a Poisson random variable with mean \(\lambda\) <a class="el" href="citelist.html#CITEREF_rLEC02c">[133]</a>&#160;. Thus, this Poisson approximation should be good when \(k\) is very large and \(\lambda\) is not too large. We may want to use Monte Carlo simulation to assess the error made by the Poisson approximation for finite values of \(k\) and \(m\). To do this, we can generate \(n\) independent realizations of \(C\), say \(C_1,…,C_n\), compute their empirical distribution and empirical mean, and compare with the Poisson distribution with mean \(\lambda\).</p>
<p>The Java program in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Collision">Collision</a> simulates \(C_1,…,C_n\), and computes the empirical distribution of $C$, its mean and variance, and a 95% confidence interval on \(\mathbb E[C]\). The results for \(k = 10000\), \(m = 500\), and \(n = 100000\), are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Collision">Collision results</a>. Here we have \(\lambda=12.5\), whereas the reported confidence interval is \((12.268, 12.272)\). This indicates that the asymptotic result underestimates \(\mathbb E[C]\) by about 2.6%.</p>
<p>The Java program imports the SSJ packages <code>rng</code>, <code>probdist</code>, and <code>stat</code>. It uses only three types of objects from SSJ: (1) a <code>RandomStream</code> object from the package <a class="el" href="namespaceumontreal_1_1ssj_1_1rng.html">umontreal.ssj.rng</a>, that generates a stream of independent random numbers from the uniform distribution; (2) a <code>PoissonDist</code> object from the package <a class="el" href="namespaceumontreal_1_1ssj_1_1probdist.html">umontreal.ssj.probdist</a>, which implements a Poisson distribution with mean \(\lambda\); and (3) a <code>Tally</code> object, from the package <a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">umontreal.ssj.stat</a>, used to collect the \(n\) realizations of \(C\) and produce a statistiscal report. In SSJ, <code>RandomStream</code> is actually just an interface that specifies all the methods that must be provided by its different implementations, which correspond to different brands of random streams (i.e., different types of uniform random number generators). The class <code>MRG32k3a</code>, whose constructor is invoked in the main program, is one such implementation of <code>RandomStream</code>. This is the one we use here. The class <code>Tally</code> provides the simplest type of statistical collector. It receives observations one by one, and after each new observation, it updates the number, average, variance, minimum, and maximum of the observations. At any time, it can return these statistics or compute a confidence interval for the theoretical mean of these observations, assuming that they are independent and identically distributed with the normal distribution. Other types of collectors that memorize the observations are also available in <code>stat</code>.</p>
<p><b>Simulating the number of collisions in a hashing system</b> &emsp;[Collision] <a class="anchor" id="REF_examples_lst_Collision"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1PoissonDist.html">PoissonDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Collision {</div><div class="line">   <span class="keywordtype">int</span> k;            <span class="comment">// Number of locations.</span></div><div class="line">   <span class="keywordtype">int</span> m;            <span class="comment">// Number of items.</span></div><div class="line">   <span class="keywordtype">double</span> lambda;    <span class="comment">// Theoretical expectation of C (asymptotic).</span></div><div class="line">   <span class="keywordtype">boolean</span>[] used;   <span class="comment">// Locations already used.</span></div><div class="line">   <span class="keywordtype">int</span> maxCounts; <span class="comment">// Values of C &gt;= maxCounts are aggregated.</span></div><div class="line">   <span class="keywordtype">int</span>[] counts; <span class="comment">// Counts the number of occurrences of each value of C.</span></div><div class="line">   PoissonDist poisson; <span class="comment">// Will be a Poisson distribution with mean lambda.</span></div><div class="line">    </div><div class="line">   <span class="keyword">public</span> Collision (<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> maxCounts) {</div><div class="line">      this.k = k;</div><div class="line">      this.m = m;</div><div class="line">      lambda = (double) m * m / (2.0 * k);</div><div class="line">      used = <span class="keyword">new</span> <span class="keywordtype">boolean</span>[k];</div><div class="line">      this.maxCounts = maxCounts;</div><div class="line">      counts = <span class="keyword">new</span> <span class="keywordtype">int</span>[maxCounts + 1];</div><div class="line">      poisson = <span class="keyword">new</span> PoissonDist(lambda);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates and returns the number of collisions.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">int</span> simulate (RandomStream stream) {</div><div class="line">      <span class="keywordtype">int</span> C = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k; i++) used[i] = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++) {</div><div class="line">         <span class="keywordtype">int</span> loc = stream.nextInt (0, k-1);</div><div class="line">         <span class="keywordflow">if</span> (used[loc]) C++;</div><div class="line">         <span class="keywordflow">else</span> used[loc] = <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> C;</div><div class="line">   }</div><div class="line"></div><div class="line">    <span class="comment">// Performs n indep. runs using stream and collects statistics in statC.</span></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns(<span class="keywordtype">int</span> n, RandomStream stream, Tally statC) {</div><div class="line">        statC.init();</div><div class="line">        <span class="keywordtype">int</span> C;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; maxCounts; c++)</div><div class="line">            counts[c] = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div><div class="line">            C = simulate(stream);</div><div class="line">            statC.add(C);</div><div class="line">            <span class="keywordflow">if</span> (C &gt; maxCounts)</div><div class="line">                C = maxCounts;</div><div class="line">            counts[C]++;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">        <span class="keywordtype">int</span> k = 10000;  <span class="keywordtype">int</span> m = 500;</div><div class="line">        <span class="keywordtype">int</span> maxCounts = 30;</div><div class="line">        <span class="keywordtype">int</span> n = 10000000;</div><div class="line">        Collision col = <span class="keyword">new</span> Collision(k, m, maxCounts);</div><div class="line">        Tally statC = <span class="keyword">new</span> Tally(<span class="stringliteral">&quot;Statistics on collisions&quot;</span>);</div><div class="line">        <span class="comment">// System.out.println(col.toString());</span></div><div class="line">        Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">        col.simulateRuns(n, <span class="keyword">new</span> MRG32k3a(), statC);</div><div class="line">        System.out.println(<span class="stringliteral">&quot;Total CPU time:      &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">        statC.setConfidenceIntervalStudent();</div><div class="line">        System.out.println(statC.report(0.95, 3));</div><div class="line">        System.out.println (<span class="stringliteral">&quot;Theoretical mean: lambda = &quot;</span> + col.lambda + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="stringliteral">&quot;Counters:\n&quot;</span></div><div class="line">                + <span class="stringliteral">&quot;  c       count    Poisson expect.\n&quot;</span>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt;= col.maxCounts; c++) {</div><div class="line">            System.out.printf(<span class="stringliteral">&quot; %2d  %10d   %12.1f%n&quot;</span>, c, col.counts[c],</div><div class="line">                    n * col.poisson.prob(c));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The class <code>Collision</code> offers the facilities to simulate copies of \(C\). Its constructor specifies \(k\) and \(m\), computes \(\lambda\), and constructs a boolean array of size \(k\) to memorize the locations used so far, in order to detect the collisions. The method <code>simulate</code> initializes the boolean array to <code>false</code>, generates the \(m\) locations, and computes \(C\). The method <code>simulateRuns</code> first resets the statistical collector <code>statC</code>, then generates \(n\) independent copies of \(C\) and pass these \(n\) observations to the collector via the method <code>add</code>. The method <code>statC.report</code> computes a confidence interval from these \(n\) observations and returns a statistical report in the form of a character string. This report is printed, together with the value of \(\lambda\). See Listing&#160; <a class="el" href="examples.html#REF_examples_res_Collision">Collision results</a>.</p>
<p>In addition to the <code>statC</code> collector, the program maintains an array of counters to count how many times each value of \(C\) has been observed. The values larger or equal to <code>maxCounts</code> are aggregated in the same counter. These counts for \(C=\) 0 to <code>maxCounts</code> are printed in the output, together with their expected values according to the Poisson (approximation) model, for comparison. The <code>poisson</code> object is used to calculate these values.</p>
<p><b>Results of the program <code> Collision</code></b> &emsp;[Collision results] <a class="anchor" id="REF_examples_res_Collision"></a></p><div class="fragment"><div class="line">Total CPU time:      0:2:10.30</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; Statistics on collisions</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">  10000000        0.000       35.000       12.270       11.486        3.389</div><div class="line">  95.0% confidence interval for mean (student): (    12.268,    12.272 )</div><div class="line"></div><div class="line">Theoretical mean: lambda = 12.5</div><div class="line"></div><div class="line">Counters:</div><div class="line">  c       count    Poisson expect.</div><div class="line"></div><div class="line">  0          38           37.3</div><div class="line">  1         434          465.8</div><div class="line">  2        2723         2911.4</div><div class="line">  3       11484        12131.0</div><div class="line">  4       37026        37909.5</div><div class="line">  5       94979        94773.7</div><div class="line">  6      203417       197445.2</div><div class="line">  7      367006       352580.7</div><div class="line">  8      580943       550907.3</div><div class="line">  9      810835       765149.1</div><div class="line"> 10     1011875       956436.4</div><div class="line"> 11     1142790      1086859.5</div><div class="line"> 12     1177523      1132145.3</div><div class="line"> 13     1112732      1088601.3</div><div class="line"> 14      973037       971965.4</div><div class="line"> 15      786828       809971.2</div><div class="line"> 16      593843       632790.0</div><div class="line"> 17      420342       465286.7</div><div class="line"> 18      278264       323115.8</div><div class="line"> 19      173779       212576.2</div><div class="line"> 20      102864       132860.1</div><div class="line"> 21       57597        79083.4</div><div class="line"> 22       30800        44933.8</div><div class="line"> 23       15519        24420.5</div><div class="line"> 24        7390        12719.0</div><div class="line"> 25        3384         6359.5</div><div class="line"> 26        1526         3057.5</div><div class="line"> 27         620         1415.5</div><div class="line"> 28         251          631.9</div><div class="line"> 29         104          272.4</div><div class="line"> 30          47          113.5</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_nonuniform"></a>
Nonuniform variate generation and simple quantile estimates</h2>
<p>The program in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Nonuniform">Nonuniform</a> simulates the following artificial model. Define the random variable </p><p class="formulaDsp">
\[ X = Y_1 + \cdots+ Y_N + W_1 + …+ W_M, \]
</p>
<p> where \(N\) is Poisson with mean \(\lambda\), \(M\) is geometric with parameter \(p\), the \(Y_j\)’s are gamma with parameters \((\alpha, \beta)\), the \(W_j\)’s are lognormal with parameters \((\mu,\sigma)\), and all these random variables are independent. We want to generate \(n\) copies of \(X\), say \(X_1,…,X_n\), estimate the distribution of \(X\) by a histogram, and get the 0.10, 0.50, 0.90, and 0.99 quantiles of its empirical distribution.</p>
<p>The method <code>simulateRuns</code> generates \(n\) copies of \(X\) and pass them to a statistical collector of class <code>TallyStore</code>, that stores the individual observations. These observations are sorted in increasing order by invoking <code>quickSort</code>, and the appropriate empirical quantiles are printed, together with a short report.</p>
<p><b>Simulating nonuniform variates and observing quantiles</b> &emsp;[Nonuniform] <a class="anchor" id="REF_examples_lst_Nonuniform"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1charts.html">charts</a>.<a class="code" href="classumontreal_1_1ssj_1_1charts_1_1HistogramChart.html">HistogramChart</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Nonuniform {</div><div class="line">   <span class="comment">// The parameter values are hardcoded here to simplify the program.</span></div><div class="line">   <span class="keywordtype">double</span> lambda = 5.0;   <span class="keywordtype">double</span> p = 0.2;</div><div class="line">   <span class="keywordtype">double</span> alpha = 2.0;    <span class="keywordtype">double</span> beta = 1.0;</div><div class="line">   <span class="keywordtype">double</span> mu = 5.0;       <span class="keywordtype">double</span> sigma = 0.5;</div><div class="line"></div><div class="line">   RandomStream stream = <span class="keyword">new</span> LFSR113();</div><div class="line">   RandomVariateGenInt genN = <span class="keyword">new</span> RandomVariateGenInt</div><div class="line">          (stream, <span class="keyword">new</span> PoissonDist (lambda));       <span class="comment">// For N</span></div><div class="line">   RandomVariateGen genY = <span class="keyword">new</span> GammaAcceptanceRejectionGen</div><div class="line">          (stream, <span class="keyword">new</span> GammaDist (alpha, beta));    <span class="comment">// For Y_j</span></div><div class="line">   RandomVariateGen genW = <span class="keyword">new</span> RandomVariateGen</div><div class="line">          (stream, <span class="keyword">new</span> LognormalDist (mu, sigma));  <span class="comment">// For W_j</span></div><div class="line"></div><div class="line">   <span class="comment">// Generates and returns X.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulate () {</div><div class="line">      <span class="keywordtype">int</span> N;  <span class="keywordtype">int</span> M;  <span class="keywordtype">int</span> j;  <span class="keywordtype">double</span> X = 0.0;</div><div class="line">      N = genN.nextInt();</div><div class="line">      M = GeometricDist.inverseF (p, stream.nextDouble());  <span class="comment">// Uses static method</span></div><div class="line">      <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) X += genY.nextDouble();</div><div class="line">      <span class="keywordflow">for</span> (j = 0; j &lt; M; j++) X += genW.nextDouble();</div><div class="line">      <span class="keywordflow">return</span> X;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n indep. runs and collects statistics in statX.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, TallyStore statX) {</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) statX.add (simulate ());</div><div class="line">    }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) <span class="keywordflow">throws</span> IOException {</div><div class="line">      <span class="keywordtype">int</span> n = 100000;</div><div class="line">      TallyStore statX = <span class="keyword">new</span> TallyStore (n); <span class="comment">// To store the n observations of X.</span></div><div class="line">      (<span class="keyword">new</span> Nonuniform ()).simulateRuns (n, statX);  <span class="comment">// Simulate X n times.</span></div><div class="line">      System.out.println (statX.report (0.95, 1));</div><div class="line"></div><div class="line">      <span class="comment">// Compute and print the empirical quantiles.</span></div><div class="line">      statX.quickSort();</div><div class="line">      <span class="keywordtype">double</span>[] data = statX.getArray();  <span class="comment">// The sorted observations.</span></div><div class="line">      System.out.printf (<span class="stringliteral">&quot; 0.10 quantile: %9.1f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.10 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot; 0.50 quantile: %9.1f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.50 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot; 0.90 quantile: %9.1f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.90 * n)]);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot; 0.99 quantile: %9.1f%n&quot;</span>, data[(<span class="keywordtype">int</span>)(0.99 * n)]);</div><div class="line">      </div><div class="line">      <span class="comment">// Make a histogram of the empirical distribution of X.</span></div><div class="line">      HistogramChart hist = <span class="keyword">new</span> HistogramChart(<span class="stringliteral">&quot;Histogram of distribution of $X$&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;Values of $X$&quot;</span>, <span class="stringliteral">&quot;Frequency&quot;</span>, statX.getArray(), n);</div><div class="line">      <span class="keywordtype">double</span>[] bounds = { 0, 4000, 0, 25000 }; <span class="comment">// Range of x and y to be displayed.</span></div><div class="line">      hist.setManualRange(bounds);</div><div class="line">      (hist.getSeriesCollection()).setBins(0, 40, 0, 4000); <span class="comment">// 40 bins over [0, 4000].</span></div><div class="line">      hist.view(800, 500);  <span class="comment">// View on screen.</span></div><div class="line">      </div><div class="line">      <span class="comment">// Make a Latex file that contains the histogram.</span></div><div class="line">      String histLatex = hist.toLatex(12.0, 8.0);  <span class="comment">// Width and height of plot in cm.</span></div><div class="line">      Writer file = <span class="keyword">new</span> FileWriter(<span class="stringliteral">&quot;src/main/docs/examples/tutorial/NonuniformHist.tex&quot;</span>); </div><div class="line">      file.write(histLatex);</div><div class="line">      file.close();</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p><b>Results of the program <code> Nonuniform </code></b> &emsp;[Nonuniform results] <a class="anchor" id="REF_examples_res_Nonuniform"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; null</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">  100000        0.0     9890.2      685.6   606102.1      778.5</div><div class="line"></div><div class="line"> 0.10 quantile:       9.4</div><div class="line"> 0.50 quantile:     439.1</div><div class="line"> 0.90 quantile:    1693.5</div><div class="line"> 0.99 quantile:    3501.5</div><div class="line"> </div></div><!-- fragment --><p>To simplify the program, all the parameters are fixed as constants at the beginning of the class. This is much simpler, but not recommended in general because it does not permit one to perform experiments with different parameter sets with the same program. Passing the parameters to the constructor as in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Collision">Collision</a> would require more lines of code, but would provide more flexibility.</p>
<p>The class initialization constructs a <code>RandomStream</code> of type <code>LFSR113</code> (this is a faster uniform generator that <code>MRG32k3a</code>) used to generate all the random numbers. For the generation of \(N\), we construct a Poisson distribution with mean \(\lambda\) (without giving it a name), and pass it together with the random stream to the constructor of class <code>PoissonGen</code>. The returned object <code>genN</code> is random number generator that generate Poisson random variables with mean \(\lambda\), via inversion. As similar procedure is used to construct <code>genY</code> and <code>genW</code>, which generate gamma and lognormal random variates, respectively. Note that a <code>RandomVariateGenInt</code> produces integer-valued random variates, while a <code>RandomVariateGen</code> produces real-valued random variates. For the gamma distribution, we use a special type of random number generator based on a rejection method, which is faster than inversion. These constructors precompute some (hidden) constants once for all, to speedup the random variate generation. For the Poisson distribution with mean \(\lambda\), the constructor of <code>PoissonDist</code> actually precomputes the distribution function in a table, and uses this table to compute the inverse distribution function each time a Poisson random variate needs to be generated with this particular distribution. This is possible because all Poisson random variates have the same parameter \(\lambda\). If a different \(\lambda\) was used for each variate, then we would use the static method of <code>PoissonDist</code> instead of constructing a Poisson distribution, otherwise we would have to reconstruct the distribution each time. The static method reconstructs part of the table each time, with the given \(\lambda\), so it is slower if we want to generate several Poisson variates with the same \(\lambda\). As an illustration, we use the static method to generate the geometric random variates (in <code>simulate</code>), instead of constructing a geometric distribution and variate generator. For this particular distribution, the static method is almost as fast. To generate \(M\), we invoke the static method <code>inverseF</code> of the class <code>GeometricDist</code>, which evaluates the inverse geometric distribution function for a given parameter \(p\) and a given uniform random variate. One important drawback of using the static method inside the <code>simulate</code> method is that changing the geometric distribution for another one would require changing the code inside <code>simulate</code>. Also here the three other distributions are hardcoded at the beginning of the class. To make the program general, one could pass them as parameters in the constructor, or read them in a file inside the constructor.</p>
<p>The results of this program, with \(n = 100000\), are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Nonuniform">Nonuniform</a>. We see that \(X\) has a coefficient of variation larger than 1, and the quantiles indicate that the distribution is skewed, with a long tail to the right. We have \(X &lt; 439\) about half the time, whereas the average is 685.6 and values over several thousands are not uncommon. This probably happens when \(N\) or \(M\) takes a large value. There are also many cases where \(N=M=0\), in which case \(X=0\). Looking at the histogram confirms this evaluation and provides a clearer idea of the distribution.</p>
<h2><a class="anchor" id="REF_examples_sec_inventory"></a>
A discrete-time inventory system</h2>
<p>Consider a simple inventory system where the demands for a given product on successive days are independent Poisson random variables with mean \(\lambda\). If \(X_j\) is the stock level at the beginning of day \(j\) and \(D_j\) is the demand on that day, then there are \(\min(D_j, X_j)\) sales, \(\max(0, D_j - X_j)\) lost sales, and the stock at the end of the day is \(Y_j = \max(0, X_j - D_j)\). There is a revenue \(c\) for each sale and a cost \(h\) for each unsold item at the end of the day. The inventory is controlled using a \((s,S)\) policy: If \(Y_j &lt; s\), order \(S - Y_j\) items, otherwise do not order. When an order is made in the evening, with probability \(p\) it arrives during the night and can be used for the next day, and with probability \(1-p\) it never arrives (in which case a new order will have to be made the next evening). When the order arrives, there is a fixed cost \(K\) plus a marginal cost of \(k\) per item. The stock at the beginning of the first day is \(X_0 = S\).</p>
<p>We want to simulate this system for \(m\) days, for a given set of parameters and a given control policy \((s,S)\), and replicate this simulation \(n\) times independently to estimate the expected profit per day over a time horizon of \(m\) days. Eventually, we might want to <em>optimize</em> the values of the decision parameters \((s,S)\) via simulation. (In practice, this is usually done for more complicated models.)</p>
<p><b>A simulation program for the simple inventory system</b> &emsp;[Inventory] <a class="anchor" id="REF_examples_lst_Inventory"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1PoissonDist.html">PoissonDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Inventory {</div><div class="line"></div><div class="line">   <span class="keywordtype">double</span> lambda;  <span class="comment">// Mean demand size for a day.</span></div><div class="line">   <span class="keywordtype">double</span> c;       <span class="comment">// Sale price per item.</span></div><div class="line">   <span class="keywordtype">double</span> h;       <span class="comment">// Inventory cost per item per day.</span></div><div class="line">   <span class="keywordtype">double</span> K;       <span class="comment">// Fixed ordering cost per order.</span></div><div class="line">   <span class="keywordtype">double</span> k;       <span class="comment">// Marginal ordering cost per item.</span></div><div class="line">   <span class="keywordtype">double</span> p;       <span class="comment">// Probability that an order arrives.</span></div><div class="line"></div><div class="line">   RandomVariateGenInt genDemand;</div><div class="line">   RandomStream streamDemand = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   RandomStream streamOrder  = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   Tally statProfit          = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stats on profit&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> Inventory (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> c, <span class="keywordtype">double</span> h,</div><div class="line">                     <span class="keywordtype">double</span> K, <span class="keywordtype">double</span> k, <span class="keywordtype">double</span> p) {</div><div class="line">      this.lambda = lambda;</div><div class="line">      this.c = c;  this.h = h;  this.K = K;  this.k = k;  this.p = p;</div><div class="line">      genDemand = <span class="keyword">new</span> PoissonGen (streamDemand, <span class="keyword">new</span> PoissonDist (lambda));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Simulates the system for m days, with the (s,S) policy,</span></div><div class="line">   <span class="comment">// and returns the average profit per day.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulate (<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> S) {</div><div class="line">      <span class="keywordtype">int</span> Xj = S;         <span class="comment">// Stock in the morning.</span></div><div class="line">      <span class="keywordtype">int</span> Yj;             <span class="comment">// Stock in the evening.</span></div><div class="line">      <span class="keywordtype">double</span> profit = 0.0;    <span class="comment">// Cumulated profit.</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++) {</div><div class="line">         Yj = Xj - genDemand.nextInt(); <span class="comment">// Subtract demand for the day.</span></div><div class="line">         <span class="keywordflow">if</span> (Yj &lt; 0) Yj = 0;            <span class="comment">// Lost demand.</span></div><div class="line">         profit += c * (Xj - Yj) - h * Yj;</div><div class="line">         <span class="keywordflow">if</span> ((Yj &lt; s) &amp;&amp; (streamOrder.nextDouble() &lt; p)) {</div><div class="line">            <span class="comment">// We have a successful order.</span></div><div class="line">            profit -= K + k * (S - Yj);</div><div class="line">            Xj = S;</div><div class="line">         } <span class="keywordflow">else</span></div><div class="line">            Xj = Yj;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> profit / m;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n independent simulation runs of the system for m days,</span></div><div class="line">   <span class="comment">// with the (s,S) policy, and returns a report with a 90% confidence</span></div><div class="line">   <span class="comment">// interval on the expected average profit per day.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> S) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line">         statProfit.add (simulate (m, s, S));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      Inventory system = <span class="keyword">new</span> Inventory (100.0, 2.0, 0.1, 10.0, 1.0, 0.95);</div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      system.simulateRuns (500, 2000, 80, 200);</div><div class="line">      system.statProfit.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (system.statProfit.report (0.9, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_Inventory">Inventory</a> gives a Java program that performs a simulation experiment for \(n=500\), \(m=2000\), \(s=80\), \(S=200\), \(\lambda=100\), \(c=2\), \(h=0.1\), \(K=10\), \(k=1\), and \(p=0.95\).</p>
<p>The <code>import</code> statements at the beginning of the program retrieve the SSJ packages/classes that are needed. The <code>Inventory</code> class has a constructor that initializes the model parameters (saving their values in class variables) and constructs the required random number generators and the statistical collector. To generate the demands \(D_j\) on successive days, we create (in the last line of the constructor) a random number stream and a Poisson distribution with mean \(\lambda\), and then a Poisson random variate generator <code>genDemand</code> that uses this stream and this distribution. This mechanism will (automatically) precompute tables to ensure that the Poisson variate generation is efficient. This can be done because the value of \(\lambda\) does not change during the simulation. The random number stream <code>streamOrder</code>, used to decide which orders are received, and the statistical collector <code>statProfit</code>, are also created when the <code>Inventory</code> constructor is invoked. The code that invokes their constructors is outside the <code>Inventory</code> constructor, but it could have been inside as well. On the other hand, <code>genDemand</code> must be constructed inside the <code>Inventory</code> constructor, because the value of \(\lambda\) is not yet defined outside. The <em>random number streams</em> can be viewed as virtual random number generators that generate random numbers in the interval \([0,1)\) according to the uniform probability distribution.</p>
<p>The method <code>simulate</code> simulates the system for \(m\) days, with a given policy, and returns the average profit per day. For each day, we generate the demand \(D_j\), compute the stock \(Y_j\) at the end of the day, and add the sales revenues minus the leftover inventory costs to the profit. If \(Y_j &lt; s\), we generate a uniform random variable \(U\) over the interval \((0,1)\) and an order of size \(S - Y_j\) is received the next morning if \(U &lt; p\) (that is, with probability \(p\)). In case of a successful order, we pay for it and the stock level is reset to \(S\).</p>
<p>The method <code>simulateRuns</code> performs \(n\) independent simulation runs of this system and returns a report that contains a 90% confidence interval for the expected profit. The main program constructs an <code>Inventory</code> object with the desired parameters, asks for \(n\) simulation runs, and prints the report. It also creates a timer that computes the total CPU time to execute the program, and prints it. The results are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Inventory">Inventory</a>. The average profit per day is approximately 85. It took 0.17 seconds (on a 2.4 GHz (???) computer running Windows 10 and Eclipse) to simulate the system 500 times for 2000 days each, compute the statistics, and print the results.</p>
<p><b>Results of the program <code>Inventory</code></b> &emsp;[Inventory results] <a class="anchor" id="REF_examples_res_Inventory"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; stats on profit</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">       500       83.969       85.753       84.961        0.105        0.324</div><div class="line">  90.0% conf. interval for the mean (Student approx.): (    84.938,    84.985 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.17</div></div><!-- fragment --><p><b>Comparing two inventory policies with common random numbers</b> &emsp;[InventoryCRN] <a class="anchor" id="REF_examples_lst_InventoryCRN"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="comment">// Class to simulate and compare two different (S,s) policies with CRNs.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>InventoryCRN <span class="keyword">extends</span> Inventory {</div><div class="line"></div><div class="line">   Tally statDiff = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stats on difference&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> InventoryCRN (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> c, <span class="keywordtype">double</span> h,</div><div class="line">                        <span class="keywordtype">double</span> K, <span class="keywordtype">double</span> k, <span class="keywordtype">double</span> p) {</div><div class="line">      super (lambda, c, h, K, k, p);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDiff (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s1, <span class="keywordtype">int</span> S1, <span class="keywordtype">int</span> s2, <span class="keywordtype">int</span> S2) {</div><div class="line">      statDiff.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div><div class="line">         <span class="keywordtype">double</span> value1 = simulate (m, s1, S1);</div><div class="line">         <span class="keywordtype">double</span> value2 = simulate (m, s2, S2);</div><div class="line">         statDiff.add (value2 - value1);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDiffCRN (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> s1, <span class="keywordtype">int</span> S1, <span class="keywordtype">int</span> s2, <span class="keywordtype">int</span> S2) {</div><div class="line">      statDiff.init();</div><div class="line">      streamDemand.resetStartStream();</div><div class="line">      streamOrder.resetStartStream();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div><div class="line">         <span class="keywordtype">double</span> value1 = simulate (m, s1, S1);</div><div class="line">         streamDemand.resetStartSubstream();</div><div class="line">         streamOrder.resetStartSubstream();</div><div class="line">         <span class="keywordtype">double</span> value2 = simulate (m, s2, S2);</div><div class="line">         statDiff.add (value2 - value1);</div><div class="line">         streamDemand.resetNextSubstream();</div><div class="line">         streamOrder.resetNextSubstream();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      InventoryCRN system = <span class="keyword">new</span> InventoryCRN (100.0, 2.0, 0.1, 10.0, 1.0, 0.95);</div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line"></div><div class="line">      system.simulateDiff (500, 2000, 80, 198, 80, 200);</div><div class="line">      system.statDiff.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (system.statDiff.report (0.9, 3));</div><div class="line">      <span class="keywordtype">double</span> varianceIndep = system.statDiff.variance();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      </div><div class="line">      timer.init();</div><div class="line">      system.simulateDiffCRN (500, 2000, 80, 198, 80, 200);</div><div class="line">      System.out.println (system.statDiff.report (0.9, 3));</div><div class="line">      <span class="keywordtype">double</span> varianceCRN = system.statDiff.variance();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Variance ratio:  %8.4g%n&quot;</span>, varianceIndep/varianceCRN);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>In Listing&#160; <a class="el" href="examples.html#REF_examples_lst_InventoryCRN">InventoryCRN</a>, we extend the <code>Inventory</code> class to a class <code>InventoryCRN</code> that compares two sets of parameters \((s,S)\) for the inventory control policy. The method <code>simulateDiff</code> simulates the system with policies \((s_1, S_1)\) and \((s_2, S_2)\) independently, computes the difference in profits, and repeats this \(n\) times. These \(n\) differences are tallied in statistical collector <code>statDiff</code>, to estimate the expected difference in average daily profits between the two policies.</p>
<p>The method <code>simulateDiffCRN</code> does the same, but using <em>common random numbers</em> across pairs of simulation runs. After running the simulation with policy \((s_1, S_1)\), the two random number streams are reset to the start of their current substream, so that they produce exactly the same sequence of random numbers when the simulation is run with policy \((s_2, S_2)\). Then the difference in profits is given to the statistical collector <code>statDiff</code> as before and the two streams are reset to a new substream for the next pair of simulations.</p>
<p>Why not use the same stream for both the demands and orders? In this example, we need one random number to generate the demand each day, and also one random number to know if the order arrives, but only on the days where we make an order. These days where we make an order are not necessarily the same for the two policies. So if we use a single stream for both the demands and orders, the random numbers will not necessarily be used for the same purpose across the two policies: a random number used to decide if the order arrives in one case may end up being used to generate a demand in the other case. This can greatly diminish the power of the common random numbers technology. Using two different streams as in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_InventoryCRN">InventoryCRN</a> ensures at least that the random numbers are used for the same purpose for the two policies. For more explanations and examples about common random numbers, see <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>, <a class="el" href="citelist.html#CITEREF_vLEC94b">[127]</a>, <a class="el" href="citelist.html#CITEREF_sLEC09a">[125]</a>&thinsp;.</p>
<p>The main program estimates the expected difference in average daily profits for policies \((s_1, S_1) = (80, 198)\) and \((s_2, S_2) = (80, 200)\), first with independent random numbers, then with common random numbers. The other parameters are the same as before. The results are in Listing&#160; <a class="el" href="examples.html#REF_examples_res_InventoryCRN">InventoryCRN results</a>. We see that use of common random numbers reduces the variance by a factor of about 20 in this case. This means that with CRNs, one needs about 20 times less simulation than with independent random numbers to estimate the difference with the same accuracy.</p>
<p><b>Results of the program <code>InventoryCRN</code></b> &emsp;[InventoryCRN results] <a class="anchor" id="REF_examples_res_InventoryCRN"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; stats on difference</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">       500       -1.032        1.822        0.320        0.233        0.483</div><div class="line">  90.0% conf. interval for the mean (Student approx.): (     0.285,     0.356 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.22</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; stats on difference</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">       500       -0.017        0.649        0.308        0.012        0.108</div><div class="line">  90.0% conf. interval for the mean (Student approx.): (     0.300,     0.316 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.19</div><div class="line">Variance ratio:     19.95</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_queue_lindley"></a>
A single-server queue with Lindley’s recurrence</h2>
<p>We consider here a <em>single-server queue</em>, where customers arrive randomly and are served one by one in their order of arrival, i.e., <em>first in, first out</em> (FIFO). We suppose that the times between successive arrivals are exponential random variables with mean \(1/\lambda\), that the service times are exponential random variables with mean \(1/\mu\), and that all these random variables are mutually independent. The customers arriving while the server is busy must join the queue. The system initially starts empty. We want to simulate the first \(m\) customers in the system and compute the mean waiting time per customer.</p>
<p>This simple model is well-known in queuing theory and is called an \(M/M/1\) queue. Simple formulas are available for this model to compute the average waiting time per customer, average queue length, probability that a customers waits more than \(x\) seconds, etc., over an <em>infinite</em> time horizon <a class="el" href="citelist.html#CITEREF_pKLE75a">[107]</a>&thinsp;. For a finite number of customers or a finite time horizon, these expectations can also be computed by numerical methods, but here we just want to show how it can be simulated.</p>
<p>In a single-server queue, if \(W_i\) and \(S_i\) are the waiting time and service time of the \(i\)th customer, and \(A_i\) is the time between the arrivals of the \(i\)th and \((i+1)\)th customers, we have \(W_1=0\) and the \(W_i\)’s follow the recurrence <a class="anchor" id="REF_examples_examples_eq_lindley"></a> </p><p class="formulaDsp">
\[ W_{i+1} = \max(0,\; W_i + S_i - A_i), \tag{lindley} \]
</p>
<p> known as <em>Lindley’s equation</em> <a class="el" href="citelist.html#CITEREF_pKLE75a">[107]</a>&thinsp;.</p>
<p><b>A simulation based on Lindley’s recurrence</b> &emsp;[QueueLindley] <a class="anchor" id="REF_examples_lst_QueueLindley"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1ExponentialDist.html">ExponentialDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueLindley {</div><div class="line"></div><div class="line">   RandomStream streamArr  = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   RandomStream streamServ = <span class="keyword">new</span> MRG32k3a();</div><div class="line">   Tally averageWaits = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average waits&quot;</span>);</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulate (<span class="keywordtype">int</span> numCust, <span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      <span class="keywordtype">double</span> Wi = 0.0;</div><div class="line">      <span class="keywordtype">double</span> sumWi = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt;= numCust; i++) {</div><div class="line">         Wi += ExponentialDist.inverseF (mu, streamServ.nextDouble()) -</div><div class="line">               ExponentialDist.inverseF (lambda, streamArr.nextDouble());</div><div class="line">         <span class="keywordflow">if</span> (Wi &lt; 0.0) Wi = 0.0;</div><div class="line">         sumWi += Wi;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> sumWi / numCust;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> numCust, <span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      averageWaits.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)</div><div class="line">      averageWaits.add (simulate (numCust, lambda, mu));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { </div><div class="line">      <span class="comment">// Chrono timer = new Chrono();</span></div><div class="line">      QueueLindley queue = <span class="keyword">new</span> QueueLindley();</div><div class="line">      queue.simulateRuns (100, 10000, 1.0, 2.0);</div><div class="line">      System.out.println (queue.averageWaits.report());</div><div class="line">      <span class="comment">// System.out.println (&quot;Total CPU time: &quot; + timer.format());</span></div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueLindley">QueueLindley</a> exploits ( <a class="el" href="">lindley</a> ) to compute the average waiting time of the first \(m\) customers in the queue, repeats it \(n\) times independently, and prints a summary of the results. Here, for a change, we pass the model parameters to the methods instead of to the constructor, and the random variates are generated by static methods instead of via a <code>RandomVariateGen</code> object as in the <em>Inventory</em> class (previous example). This illustrates various ways of doing the same thing. The instruction “<code>Wi += …</code>” could also be replaced by</p>
<div class="fragment"><div class="line">Wi += - Math.log (1.0 - streamServ.nextDouble()) / mu</div><div class="line">      + Math.log (1.0 - streamArr.nextDouble()) / lambda;</div></div><!-- fragment --><p>which directly implements inversion of the exponential distribution. Hardcoding the exponential distributions in the <code>simulate</code> method as we do here makes the program simpler, but it has the drawback that one cannot reuse the same class for other distributions than the exponential. To make it more general, the distributions could be created outside the class and passed to the constructor.</p>
<h2><a class="anchor" id="REF_examples_sec_observer"></a>
Using the observer design pattern</h2>
<p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueObs">QueueObs</a> adds a few ingredients to the program <code>QueueLindley</code>, in order to illustrate the <em>observer</em> design pattern implemented in package <code>stat</code>. This mechanism permits one to separate data generation from data processing. It can be very helpful in large simulation programs or libraries, where different objects may need to process the same data in different ways. These objects may have the task of storing observations or displaying statistics in different formats, or putting them in files for treatment by other software such as R, for example, and they are not necessarily fixed in advance.</p>
<p>The <em>observer</em> pattern, supported by the <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> interface in SSJ, offers the appropriate flexibility for that kind of situation. A statistical probe maintains a list of registered <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> objects, and broadcasts information to all its registered observers whenever appropriate. Any object that implements the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> can register as an observer.</p>
<p>A <code>StatProbe</code> object from package <code>stat</code>, or an instance of its subclasses <code>Tally</code> and <code>Accumulate</code>, contains a list of <code>ObservationListener</code>’s. Whenever it receives a new statistical observation, e.g., via <code>Tally.add</code> or <code>Accumulate.update</code>, they send the new value to all registered observers. To register as an observer, an object must implement the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1stat_1_1ObservationListener.html">umontreal.ssj.stat.ObservationListener</a> This implies that it must provide an implementation of the method <code>newObservation</code>, whose purpose is to recover the information that the object has registered for, usually to do somethinmg with it.</p>
<p>In the example, the statistical collector <code>waitingTimes</code> transmits to all its registered listeners each new statistical observation that it receives via its <code>add</code> method. More specifically, each call to <code>waitingTimes.add(x)</code> generates in the background a call to <code>o.newObservation(waitingTimes, x)</code> for all registered observers <code>o</code>.</p>
<p>The method <code>notifyObs</code> is used to turn the tally into such a notifying agency. In fact, the collector is both a tally and a distribution agency, but its tally functionality can be disabled using the <code>stopCollectStat</code> method. This can be useful when the registered observers already perform statistical collection.</p>
<p>In our example, two observers register to receive observations from <code>waitingTimes</code>. They are anonymous objects of classes <code>ObservationTrace</code> and <code>LargeWaitsCollector</code>, respectively. Each one is informed of any new observation \(W_i\) via its <code>newObservation</code> method. The task of the <code>ObservationTrace</code> observer is to print the waiting times \(W_5\), \(W_{10}\), \(W_{15}\), …, whereas the <code>LargeWaitsCollector</code> observer stores in an array all waiting times that exceed 2. The statistical collector <code>waitingTimes</code> itself also stores appropriate information to be able to provide a statistical report when required.</p>
<p>The <code>ObservationListener</code> interface specifies that <code>newObservation</code> must have two formal parameters, of classes <code>StatProbe</code> and <code>double</code>, respectively. The second parameter is the value of the observation. In the case where the observer registers to several <code>ObservationListener</code> objects, the first parameter of <code>newObservation</code> tells it which one is sending the information, so it can adopt the correct behavior for this sender.</p>
<p><b>A simulation of Lindley’s recurrence using observers</b> &emsp;[QueueObs] <a class="anchor" id="REF_examples_lst_QueueObs"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueObs {</div><div class="line"></div><div class="line">   Tally waitingTimes = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times&quot;</span>);</div><div class="line">   Tally averageWaits = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average wait&quot;</span>);</div><div class="line">   RandomVariateGen genArr;  <span class="comment">// For interarrival times.</span></div><div class="line">   RandomVariateGen genServ; <span class="comment">// For service times.</span></div><div class="line">   <span class="keywordtype">int</span> cust;    <span class="comment">// Number of the current customer.</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> QueueObs (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu, <span class="keywordtype">int</span> step) {</div><div class="line">      genArr = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), lambda);</div><div class="line">      genServ = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), mu);</div><div class="line">      waitingTimes.setBroadcasting (<span class="keyword">true</span>);</div><div class="line">      waitingTimes.addObservationListener (<span class="keyword">new</span> ObservationTrace (step));</div><div class="line">      waitingTimes.addObservationListener (<span class="keyword">new</span> LargeWaitsCollector (2.0));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> simulate (<span class="keywordtype">int</span> numCust) {</div><div class="line">      waitingTimes.init();</div><div class="line">      <span class="keywordtype">double</span> Wi = 0.0;</div><div class="line">      waitingTimes.add (Wi);</div><div class="line">      <span class="keywordflow">for</span> (cust = 2; cust &lt;= numCust; cust++) {</div><div class="line">         Wi += genServ.nextDouble() - genArr.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (Wi &lt; 0.0) Wi = 0.0;</div><div class="line">         waitingTimes.add (Wi);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> waitingTimes.average();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> numCust) {</div><div class="line">      averageWaits.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)</div><div class="line">         averageWaits.add (simulate (numCust));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// A listener that observes each waiting time and prints every `step`th one.</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>ObservationTrace <span class="keyword">implements</span> ObservationListener {</div><div class="line">      <span class="keyword">private</span> <span class="keywordtype">int</span> step;</div><div class="line"></div><div class="line">      <span class="keyword">public</span> ObservationTrace (<span class="keywordtype">int</span> step) { this.step = step; }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="classtutorial_1_1QueueObs_1_1ObservationTrace.html#a08e03181ba7d3c28fdd37b757e792f21">newObservation</a> (StatProbe probe, <span class="keywordtype">double</span> x) {</div><div class="line">         <span class="keywordflow">if</span> (cust % step == 0)</div><div class="line">            System.out.println (<span class="stringliteral">&quot;Customer &quot;</span> + cust + <span class="stringliteral">&quot; waited &quot;</span> </div><div class="line">                   + x + <span class="stringliteral">&quot; time units.&quot;</span>);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// A listener that observes waiting times and collects those larger than threshold.</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>LargeWaitsCollector <span class="keyword">implements</span> ObservationListener {</div><div class="line">      <span class="keywordtype">double</span> threshold;</div><div class="line">      ArrayList&lt;Double&gt; largeWaits = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line"></div><div class="line">      <span class="keyword">public</span> LargeWaitsCollector (<span class="keywordtype">double</span> threshold) {</div><div class="line">         this.threshold = threshold;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="classtutorial_1_1QueueObs_1_1ObservationTrace.html#a08e03181ba7d3c28fdd37b757e792f21">newObservation</a> (StatProbe probe, <span class="keywordtype">double</span> x) {</div><div class="line">         <span class="keywordflow">if</span> (x &gt; threshold) largeWaits.add (x);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Maybe print the list largeWaits. </span></div><div class="line">      <span class="keyword">public</span> String formatLargeWaits () {</div><div class="line">         <span class="keywordflow">return</span> <span class="stringliteral">&quot;not yet implemented...&quot;</span>;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { </div><div class="line">      QueueObs queue = <span class="keyword">new</span> QueueObs (1.0, 2.0, 5);</div><div class="line">      queue.simulateRuns (2, 100);</div><div class="line">      System.out.println (<span class="stringliteral">&quot;\n\n&quot;</span> + queue.averageWaits.report());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_asian"></a>
Pricing an Asian option</h2>
<p>A <em>geometric Brownian motion</em> (GBM) \(\{S(\zeta), \zeta\ge0\}\) satisfies </p><p class="formulaDsp">
\[ S(\zeta) = S(0) \exp\left[(r - \sigma^2/2)\zeta+ \sigma B(\zeta)\right] \]
</p>
<p> where \(r\) is the <em>risk-free appreciation rate</em>, \(\sigma\) is the <em>volatility parameter</em>, and \(B\) is a standard Brownian motion, i.e., a stochastic process whose increments over disjoint intervals are independent normal random variables, with mean 0 and variance \(\delta\) over an interval of length \(\delta\) (see, e.g., <a class="el" href="citelist.html#CITEREF_fGLA04a">[67]</a>&thinsp;). The GBM process is a popular model for the evolution in time of the market price of financial assets. A discretely-monitored <em><a class="el" href="classAsian.html">Asian</a> option</em> on the arithmetic average of a given asset has discounted payoff <a class="anchor" id="REF_examples_examples_eq_payasian"></a> </p><p class="formulaDsp">
\[ \tag{payasian} X = e^{-rT} \max[\bar{S} - K,  0] \]
</p>
<p> where \(K\) is a constant called the <em>strike price</em> and <a class="anchor" id="REF_examples_examples_eq_arithmetic_average"></a> </p><p class="formulaDsp">
\[ \tag{arithmetic-average} \bar{S} = \frac{1}{t} \sum_{j=1}^t S(\zeta_j), \]
</p>
<p> for some fixed observation times \(0 &lt; \zeta_1 &lt; \cdots&lt; \zeta_t = T\). The value (or fair price) of the <a class="el" href="classAsian.html">Asian</a> option is \(v = E[X]\) where the expectation is taken under the so-called risk-neutral measure (which means that the parameters \(r\) and \(\sigma\) have to be selected in a particular way; see <a class="el" href="citelist.html#CITEREF_fGLA04a">[67]</a>&thinsp;).</p>
<p>This value \(v\) can be estimated by simulation as follows. Generate \(t\) independent and identically distributed (i.i.d.) \(N(0,1)\) random variables \(Z_1,…,Z_t\) and put \(B(\zeta_j) = B(\zeta_{j-1}) + \sqrt{\zeta_j - \zeta_{j-1}} Z_j\), for \(j=1,…,t\), where \(B(\zeta_0) = \zeta_0 = 0\). Then, <a class="anchor" id="REF_examples_examples_eq_Szetaj"></a> </p><p class="formulaDsp">
\[ S(\zeta_j) = S(0) e^{(r-\sigma^2/2)\zeta_j + \sigma B(\zeta_j)} \]
</p>
<p> for \(j = 1,…,t\) and the payoff can be computed via (<a class="el" href="">payasian</a>). This can be replicated \(n\) times, independently, and the option value is estimated by the average discounted payoff. The Java program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_AsianGBM">AsianGBM</a> implement this procedure.</p>
<p>Note that generating the sample path and computing the payoff is done in two different methods. This way, other methods could eventually be added to compute payoffs that are defined differently (e.g., based on the geometric average, or with barriers, etc.) over the same generated sample path.</p>
<p><b>Pricing an <a class="el" href="classAsian.html">Asian</a> option on a GMB process</b> &emsp;[AsianGBM] <a class="anchor" id="REF_examples_lst_AsianGBM"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.<a class="code" href="classumontreal_1_1ssj_1_1probdist_1_1NormalDist.html">NormalDist</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>AsianGBM {</div><div class="line">   <span class="keywordtype">double</span> strike;    <span class="comment">// Strike price.</span></div><div class="line">   <span class="keywordtype">int</span> d;            <span class="comment">// Number of observation times.</span></div><div class="line">   <span class="keywordtype">double</span> discount;  <span class="comment">// Discount factor, exp(-r * zeta[d]).</span></div><div class="line">   <span class="keywordtype">double</span>[] muDelta; <span class="comment">// muDelta[j] = (zeta[j+1] - zeta[j]) * (r - sigma^2/2).</span></div><div class="line">   <span class="keywordtype">double</span>[] sigmaSqrtDelta; <span class="comment">// sqrt(zeta[j+1] - zeta[j]) * sigma.</span></div><div class="line">   <span class="keywordtype">double</span>[] logS;    <span class="comment">// Log of the GBM process: logS[t] = log (S[t]).</span></div><div class="line"></div><div class="line">   <span class="comment">// Array zeta[0..s] must contain zeta[0]=0.0, plus the d observation times.</span></div><div class="line">   <span class="comment">// This constructor precomputes several quantities to speedup the simulation.</span></div><div class="line">   <span class="keyword">public</span> AsianGBM (<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> strike,</div><div class="line">                    <span class="keywordtype">double</span> s0, <span class="keywordtype">int</span> d, <span class="keywordtype">double</span>[] zeta) {</div><div class="line">      this.strike = strike;</div><div class="line">      this.d = d;</div><div class="line">      discount = Math.exp (-r * zeta[d]);</div><div class="line">      <span class="keywordtype">double</span> mu = r - 0.5 * sigma * sigma;</div><div class="line">      muDelta = <span class="keyword">new</span> <span class="keywordtype">double</span>[d];</div><div class="line">      sigmaSqrtDelta = <span class="keyword">new</span> <span class="keywordtype">double</span>[d];</div><div class="line">      logS = <span class="keyword">new</span> <span class="keywordtype">double</span>[d+1];</div><div class="line">      <span class="keywordtype">double</span> delta;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; d; j++) {</div><div class="line">         delta = zeta[j+1] - zeta[j];</div><div class="line">         muDelta[j] = mu * delta;</div><div class="line">         sigmaSqrtDelta[j] = sigma * Math.sqrt (delta);</div><div class="line">      }</div><div class="line">      logS[0] = Math.log (s0);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates the log of the process S.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> generatePath (RandomStream stream) {</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; d; j++)</div><div class="line">          logS[j+1] = logS[j] + muDelta[j] + sigmaSqrtDelta[j]</div><div class="line">                   * NormalDist.inverseF01 (stream.nextDouble());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Computes and returns the discounted option payoff.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> getPayoff () {</div><div class="line">       <span class="keywordtype">double</span> average = 0.0;  <span class="comment">// Average of the GBM process.</span></div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= d; j++) average += Math.exp (logS[j]);</div><div class="line">       average /= d;</div><div class="line">       <span class="keywordflow">if</span> (average &gt; strike) <span class="keywordflow">return</span> discount * (average - strike);</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Performs n simulation runs using stream and collects statistics in statValue.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRuns (<span class="keywordtype">int</span> n, RandomStream stream, Tally statValue) {</div><div class="line">      statValue.init();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {</div><div class="line">         generatePath (stream);</div><div class="line">         statValue.add (getPayoff ());</div><div class="line">         stream.resetNextSubstream();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args)  <span class="keywordflow">throws</span> IOException {</div><div class="line">      <span class="keywordtype">int</span> d = 12;</div><div class="line">      <span class="keywordtype">double</span>[] zeta = <span class="keyword">new</span> <span class="keywordtype">double</span>[d+1];   zeta[0] = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1; j&lt;=d; j++)</div><div class="line">         zeta[j] = (<span class="keywordtype">double</span>)j / (double)d;</div><div class="line">      AsianGBM process = <span class="keyword">new</span> AsianGBM (0.05, 0.5, 100.0, 100.0, d, zeta);</div><div class="line">      Tally statValue = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Stats on value of Asian option&quot;</span>);</div><div class="line"></div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line">      <span class="keywordtype">int</span> n = 1000000;</div><div class="line">      process.simulateRuns (n, <span class="keyword">new</span> MRG32k3a(), statValue);</div><div class="line">      statValue.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statValue.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time:      &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The method <code>simulateRuns</code> performs \(n\) independent simulation runs using the given random number stream and put the \(n\) observations of the net payoff in the statistical collector <code>statValue</code>. In the <code>main</code> program, we first specify the \(d=12\) observation times \(\zeta_j = j/12\) for \(j=1,…,12\), and put them in the array <code>zeta</code> (of size 13) together with \(\zeta_0=0\). We then construct an <code>AsianGBM</code> object with parameters \(r=0.05\), \(\sigma=0.5\), \(K = 100\), \(S(0)=100\), \(d=12\), and the observation times contained in array <code>zeta</code>. We then create the statistical collector <code>statValue</code>, perform \(10^6\) simulation runs, and print the results. The discount factor \(e^{-rT}\) and the constants \(\sigma\sqrt{\zeta_j - \zeta_{j-1}}\) and \((r-\sigma^2/2)(\zeta_j - \zeta_{j-1})\) are precomputed in the constructor <code>AsianGBM</code>, to speed up the simulation.</p>
<p>The program in Listing&#160; <a class="el" href="examples.html#REF_examples_lst_AsianGBMQMC">AsianGBMQMC</a> extends the class <code>AsianGBM</code> to <code>AsianGBMQMC</code>, whose method <code>simulateRunsRQMC</code> estimates the option value via randomized quasi-Monte Carlo (RQMC). This method takes as input an RQMC point set, and makes \(m\) independent randomizations of it. For each randomization, it computes the average payoff over the \(n\) points of the point set. The \(m\) independent averages are given to the collector <code>statRQMC</code>, which is returned by the method.</p>
<p>The method <code>simulateRunsRQMC</code> creates an iterator <code>stream</code> which will be used to enumerate the points. These point set iterators, available for each type of point set in package <code>hups</code>, implement the <code>RandomStream</code> interface and permit one to easily replace the uniform random numbers by QMC or RQMC points or sequences, without changing the code of the model itself. The method <code>resetStartStream</code>, invoked immediately after each randomization of <code>prqmc</code>, resets the iterator to the first coordinate of the first point. The number \(n\) of simulation runs is equal to the number of points. The points correspond to substreams in the <code>RandomStream</code> interface. The method <code>resetNextSubstream</code>, invoked after each simulation run in <code>simulateRuns</code>, resets the iterator to the first coordinate of the next point. Each generation of a uniform random number (directly or indirectly) with this stream during the simulation moves the iterator to the next coordinate of the current point.</p>
<p><b>Pricing an <a class="el" href="classAsian.html">Asian</a> option on a GMB process with randomized quasi-Monte Carlo</b> &emsp;[AsianGBMQMC] <a class="anchor" id="REF_examples_lst_AsianGBMQMC"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1hups.html">hups</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.<a class="code" href="classumontreal_1_1ssj_1_1stat_1_1Tally.html">Tally</a>;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1util.html">util</a>.<a class="code" href="classumontreal_1_1ssj_1_1util_1_1Chrono.html">Chrono</a>;</div><div class="line"></div><div class="line"><span class="comment">// An extension of AsianGBM that uses RQMC point sets.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>AsianGBMQMC <span class="keyword">extends</span> AsianGBM {</div><div class="line"></div><div class="line">   <span class="keyword">public</span> AsianGBMQMC (<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> strike,</div><div class="line">                    <span class="keywordtype">double</span> s0, <span class="keywordtype">int</span> s, <span class="keywordtype">double</span>[] zeta) {</div><div class="line">       super (r, sigma, strike, s0, s, zeta);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Makes m independent randomizations of the RQMC point set prqmc.</span></div><div class="line">   <span class="comment">// For each of them, performs one simulation run for each point</span></div><div class="line">   <span class="comment">// of prqmc, and adds the average over these points to the collector statRQMC.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateRunsRQMC (<span class="keywordtype">int</span> m, RQMCPointSet prqmc, Tally statRQMC) {</div><div class="line">      Tally statValue  = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;stat on value of Asian option&quot;</span>);</div><div class="line">      <span class="keywordtype">int</span> n = prqmc.getNumPoints();</div><div class="line">      PointSetIterator stream = prqmc.iterator ();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;m; j++) {</div><div class="line">          prqmc.randomize();</div><div class="line">          stream.resetStartStream();</div><div class="line">          simulateRuns (n, stream, statValue);</div><div class="line">          statRQMC.add (statValue.average());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args)  <span class="keywordflow">throws</span> IOException {</div><div class="line">      <span class="keywordtype">int</span> d = 12;</div><div class="line">      <span class="keywordtype">double</span>[] zeta = <span class="keyword">new</span> <span class="keywordtype">double</span>[d+1];</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;=d; j++)</div><div class="line">         zeta[j] = (<span class="keywordtype">double</span>)j / (double)d;</div><div class="line">      AsianGBMQMC process = <span class="keyword">new</span> AsianGBMQMC (0.05, 0.5, 100.0, 100.0, d, zeta);</div><div class="line">      Tally statMC  = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;value of Asian option&quot;</span>);</div><div class="line">      Tally statRQMC = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;RQMC averages for Asian option under GBM&quot;</span>);</div><div class="line">      Chrono timer = <span class="keyword">new</span> Chrono();</div><div class="line"></div><div class="line">      <span class="comment">// We first perform a Monte Carlo experiment, to compare with RQMC.</span></div><div class="line">      <span class="keywordtype">int</span> n = 100000;</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Ordinary MC:\n&quot;</span>);</div><div class="line">      process.simulateRuns (n, <span class="keyword">new</span> MRG32k3a(), statMC);</div><div class="line">      statMC.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statMC.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format());</div><div class="line">      <span class="keywordtype">double</span> varMC = statMC.variance();</div><div class="line">      <span class="keywordtype">double</span> cpuMC = timer.getSeconds() / n;  <span class="comment">// CPU seconds per run.</span></div><div class="line">      System.out.println (<span class="stringliteral">&quot;------------------------\n&quot;</span>);</div><div class="line"></div><div class="line">      <span class="comment">// Then we make a RQMC experiment, and compare the work-normalized variances.</span></div><div class="line">      timer.init();</div><div class="line">      DigitalNet p = <span class="keyword">new</span> SobolSequence (16, 31, d); <span class="comment">// n = 2^{16} points in d dim.</span></div><div class="line">      PointSetRandomization rand = <span class="keyword">new</span> LMScrambleShift (<span class="keyword">new</span> MRG32k3a());</div><div class="line">      RQMCPointSet prqmc = <span class="keyword">new</span> RQMCPointSet (p, rand);</div><div class="line">      n = p.getNumPoints();           <span class="comment">// Number of RQMC points.</span></div><div class="line">      <span class="keywordtype">int</span> m = 20;                     <span class="comment">// Number of RQMC randomizations.</span></div><div class="line">      process.simulateRunsRQMC (m, prqmc, statRQMC);</div><div class="line">      System.out.println (<span class="stringliteral">&quot;QMC with Sobol point set with &quot;</span> + n +</div><div class="line">          <span class="stringliteral">&quot; points and affine matrix scramble:\n&quot;</span>);</div><div class="line">      statRQMC.setConfidenceIntervalStudent();</div><div class="line">      System.out.println (statRQMC.report (0.95, 3));</div><div class="line">      System.out.println (<span class="stringliteral">&quot;Total CPU time: &quot;</span> + timer.format() + <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordtype">double</span> varQMC = p.getNumPoints() * statRQMC.variance();</div><div class="line">      <span class="keywordtype">double</span> cpuQMC = timer.getSeconds() / (m * n);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Variance ratio:   %9.4g%n&quot;</span>, varMC/varQMC);</div><div class="line">      System.out.printf (<span class="stringliteral">&quot;Efficiency ratio: %9.4g%n&quot;</span>,</div><div class="line">           (varMC * cpuMC) / (varQMC * cpuQMC));</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The <code>main</code> program constructs an <code>AsianGBMQMC</code> object and first makes a Monte Carlo (MC) experiment. Then it constructs the point set and its randomization for the RQMC experiment. The point set <code>p</code> used in this example is a <em>Sobol’ net</em> with \(n = 2^{16}\) points in \(t\) dimensions. The randomization <code>rand</code> is a left matrix scramble followed by a random digital shift. See <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">umontreal.ssj.hups</a> for more details on what these classes are doing. By putting together <code>p</code> and <code>rand</code>, we obtain the <code>RQMCPointSet</code> <code>prqmc</code>.</p>
<p>The program invokes <code>simulateRunsRQMC</code> to make the RQMC experiment. It then computes the empirical variance and CPU time <em>per simulation run</em> for both MC and RQMC. It prints the ratio of variances, which can be interpreted as the estimated <em>variance reduction factor</em> obtained when using RQMC instead of MC in this example, and the ratio of efficiencies, which can be interpreted as the estimated <em>efficiency improvement factor</em>. (The efficiency of an estimator is defined as 1/(variance \(\times\) CPU time per run.) The results are in Listing&#160; <a class="el" href="">AsianGBMRQMC results</a>: RQMC reduces the variance by a factor of around 250 and improves the efficiency by a factor of about 646. RQMC not only reduces the variance, it also runs faster than MC. The main reason for this is the call to <code>resetNextSubstream</code> in <code>simulateRuns</code>, which is a bit costly for a random number stream of class <code>MRG32k3a</code> (with the current implementation) and takes negligible time for an iterator over a digital net in base 2. In fact, in the the case of MC, the call to <code>resetNextSubstream</code> is not really needed. Removing it for that case would reduce the CPU time.</p>
<p><b>Results of the program <code>AsianGBMQMC</code> </b> &emsp;[AsianGBMQMC results] <a class="anchor" id="REF_examples_res_AsianGBMQMC"></a></p><div class="fragment"><div class="line">Ordinary MC:</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; value of Asian option</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">    100000        0.000      386.378       13.119      515.128       22.696</div><div class="line">  95.0% conf. interval for the mean (Student approx.): (    12.978,    13.260 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:0.20</div><div class="line">------------------------</div><div class="line"></div><div class="line">QMC with Sobol point set with 65536 points and affine matrix scramble:</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; RQMC averages for Asian option under GBM</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">        20       13.108       13.133       13.120       3.1E-5       5.6E-3</div><div class="line">  95.0% conf. interval for the mean (Student approx.): (    13.118,    13.123 )</div><div class="line"></div><div class="line">Total CPU time: 0:0:1.3</div><div class="line"></div><div class="line">Variance ratio:       250.2</div><div class="line">Efficiency ratio:     645.9</div></div><!-- fragment --><hr/>
<p>\(\ \ \)</p>
<h1><a class="anchor" id="REF_examples_sec_event"></a>
Discrete-Event Simulation</h1>
<p>Examples of discrete-event simulation programs, based on the event view supported by the package <code>simevents</code>, are given in this section.</p>
<h2><a class="anchor" id="REF_examples_sec_queue_event"></a>
The single-server queue with an event view</h2>
<p>We return to the single-server queue considered in Section&#160; <a class="el" href="examples.html#REF_examples_sec_queue_lindley">A single-server queue with Lindley’s recurrence</a>. This time, instead of simulating a fixed number of customers, we simulate the system for a fixed time horizon of 1000.</p>
<p><b>Event-oriented simulation of an \(M/M/1\) queue</b> &emsp;[QueueEv] <a class="anchor" id="REF_examples_lst_QueueEv"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>QueueEv {</div><div class="line"></div><div class="line">   RandomVariateGen genArr;</div><div class="line">   RandomVariateGen genServ;</div><div class="line">   LinkedList&lt;Customer&gt; waitList = <span class="keyword">new</span> LinkedList&lt;Customer&gt; ();</div><div class="line">   LinkedList&lt;Customer&gt; servList = <span class="keyword">new</span> LinkedList&lt;Customer&gt; ();</div><div class="line">   Tally custWaits     = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times&quot;</span>);</div><div class="line">   Accumulate totWait  = <span class="keyword">new</span> Accumulate (<span class="stringliteral">&quot;Size of queue&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Customer { <span class="keywordtype">double</span> arrivTime, servTime; }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> QueueEv (<span class="keywordtype">double</span> lambda, <span class="keywordtype">double</span> mu) {</div><div class="line">      genArr = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), lambda);</div><div class="line">      genServ = <span class="keyword">new</span> ExponentialGen (<span class="keyword">new</span> MRG32k3a(), mu);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulate (<span class="keywordtype">double</span> timeHorizon) {</div><div class="line">      Sim.init();</div><div class="line">      <span class="keyword">new</span> EndOfSim().schedule (timeHorizon);</div><div class="line">      <span class="keyword">new</span> Arrival().schedule (genArr.nextDouble());</div><div class="line">      Sim.start();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keyword">new</span> Arrival().schedule (genArr.nextDouble()); <span class="comment">// Next arrival.</span></div><div class="line">         Customer cust = <span class="keyword">new</span> Customer();  <span class="comment">// Cust just arrived.</span></div><div class="line">         cust.arrivTime = Sim.time();</div><div class="line">         cust.servTime = genServ.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (servList.size() &gt; 0) {       <span class="comment">// Must join the queue.</span></div><div class="line">            waitList.addLast (cust);</div><div class="line">            totWait.update (waitList.size());</div><div class="line">         } <span class="keywordflow">else</span> {                         <span class="comment">// Starts service.</span></div><div class="line">            custWaits.add (0.0);</div><div class="line">            servList.addLast (cust);</div><div class="line">            <span class="keyword">new</span> Departure().schedule (cust.servTime);</div><div class="line">         }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Departure <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         servList.removeFirst();</div><div class="line">         <span class="keywordflow">if</span> (waitList.size() &gt; 0) {</div><div class="line">            <span class="comment">// Starts service for next one in queue.</span></div><div class="line">            Customer cust = waitList.removeFirst();</div><div class="line">            totWait.update (waitList.size());</div><div class="line">            custWaits.add (Sim.time() - cust.arrivTime);</div><div class="line">            servList.addLast (cust);</div><div class="line">            <span class="keyword">new</span> Departure().schedule (cust.servTime);</div><div class="line">         }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>EndOfSim <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         Sim.stop();</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">      QueueEv queue = <span class="keyword">new</span> QueueEv (1.0, 2.0);</div><div class="line">      queue.simulate (1000.0);</div><div class="line">      System.out.println (queue.custWaits.report());</div><div class="line">      System.out.println (queue.totWait.report());</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_QueueEv">QueueEv</a> gives an event-oriented simulation program, where a subclass of the class <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html">umontreal.ssj.simevents.Event</a> is defined for each type of event that can occur in the simulation: arrival of a customer (<code>Arrival</code>), departure of a customer (<code>Departure</code>), and end of the simulation (<code>EndOfSim</code>). Each event <em>instance</em> is inserted into the <em>event list</em> upon its creation, with a scheduled time of occurrence, and is <em>executed</em> when the simulation clock reaches this time. Executing an event means invoking its <code>actions</code> method. Each event subclass must implement this method. The simulation clock and the event list (i.e., the list of events scheduled to occur in the future) are maintained behind the scenes by the class <code>Sim</code> of package <code>simevents</code>.</p>
<p>When <code>QueueEv</code> is instantiated by the <code>main</code> method, the program creates two streams of random numbers, two random variate generators, two lists, and two statistical probes (or collectors). The random number streams are attached to random variate generators <code>genArr</code> and <code>genServ</code> which are used to generate the times between successive arrivals and the service times, respectively. We can use such an attached generator because the means (parameters) do not change during simulation. The lists <code>waitList</code> and <code>servList</code> contain the customers waiting in the queue and the customer in service (if any), respectively. Maintaining a list for the customer in service may seem exaggerated, because this list never contains more than one object, but the current design has the advantage of working with very little change if the queuing model has more than one server, and in other more general situations. Note that we could have used the class <code>LinkedListStat</code> from package <code>simevents</code> instead of <code>java.util.LinkedList</code>. However, with our current implementation, the automatic statistical collection in that <code>LinkedListStat</code> class would not count the customers whose waiting time is zero, because they are never placed in the list.</p>
<p>The statistical probe <code>custWaits</code> collects statistics on the customer’s waiting times. It is of the class <code>Tally</code>, which is appropriate when the statistical data of interest is a sequence of observations \(X_1, X_2, …\) of which we might want to compute the sample mean, variance, and so on. A new observation is given to this probe by the <code>add</code> method each time a customer starts its service. Every <code>add</code> to a <code>Tally</code> probe brings a new observation \(X_i\), which corresponds here to a customer’s waiting time in the queue. The other statistical probe, <code>totWait</code>, is of the class <code>Accumulate</code>, which means that it computes the integral (and, eventually, the time-average) of a continuous-time stochastic process with piecewise-constant trajectory. Here, the stochastic process of interest is the length of the queue as a function of time. One must call <code>totWait.update</code> whenever there is a change in the queue size, to update the (hidden) <em>accumulator</em> that keeps the current value of the integral of the queue length. This integral is equal, after each update, to the total waiting time in the queue, for all the customers, since the beginning of the simulation.</p>
<p>Each customer is an object with two fields: <code>arrivTime</code> memorizes this customer’s arrival time to the system, and <code>servTime</code> memorizes its service time. This object is created, and its fields are initialized, when the customer arrives.</p>
<p>The method <code>simulateOneRun</code> simulates this system for a fixed time horizon. It first invokes <code>Sim.init</code>, which initializes the clock and the event list. The method <code>Sim.start</code> actually starts the simulation by advancing the clock to the time of the first event in the event list, removing this event from the list, and executing it. This is repeated until either <code>Sim.stop</code> is called or the event list becomes empty. <code>Sim.time</code> returns the current time on the simulation clock. Here, two events are scheduled before starting the simulation: the end of the simulation at time horizon, and the arrival of the first customer at a random time that has the exponential distribution with <em>rate</em> \(\lambda\) (i.e., <em>mean</em> \(1/\lambda\)), generated by <code>genArr</code> using inversion and its attached random stream. The method <code>genArr.nextDouble</code> returns this exponential random variate.</p>
<p>The method <code>actions</code> of the class <code>Arrival</code> describes what happens when an arrival occurs. Arrivals are scheduled by a domino effect: the first action of each arrival event schedules the next event in a random number of time units, generated from the exponential distribution with rate \(\lambda\). Then, the newly arrived customer is created, its arrival time is set to the current simulation time, and its service time is generated from the exponential distribution with mean \(1/\mu\), using the random variate generator <code>genServ</code>. If the server is busy, this customer is inserted at the end of the queue (the list <code>waitList</code>) and the statistical probe <code>totWait</code>, that keeps track of the size of the queue, is updated. Otherwise, the customer is inserted in the server’s list <code>servList</code>, its departure is scheduled to happen in a number of time units equal to its service time, and a new observation of 0.0 is given to the statistical probe <code>custWaits</code> that collects the waiting times.</p>
<p>When a <code>Departure</code> event occurs, the customer in service is removed from the list (and disappears). If the queue is not empty, the first customer is removed from the queue (<code>waitList</code>) and inserted in the server’s list, and its departure is scheduled. The waiting time of that customer (the current time minus its arrival time) is given as a new observation to the probe <code>custWaits</code>, and the probe <code>totWait</code> is also updated with the new (reduced) size of the queue.</p>
<p>The event <code>EndOfSim</code> stops the simulation. Then the <code>main</code> routine regains control and prints statistical reports for the two probes. The results are shown in Listing&#160; <a class="el" href="examples.html#REF_examples_res_QueueEv">QueueEv</a>. When calling <code>report</code> on an <code>Accumulate</code> object, an implicit update is done using the current simulation time and the last value given to <code>update</code>. In this example, this ensures that the <code>totWait</code> accumulator will integrate the total wait until the time horizon, because the simulation clock is still at that time when the report is printed. Without such an automatic update, the accumulator would integrate only up to the last update time before the time horizon.</p>
<p><b>Results of the program <code>QueueEv</code> </b> &emsp;[QueueEv results] <a class="anchor" id="REF_examples_res_QueueEv"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; Waiting times</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">      1037        0.000        6.262        0.495        0.697        0.835</div><div class="line"></div><div class="line">REPORT on Accumulate stat. collector ==&gt; Size of queue</div><div class="line">      from time   to time       min         max         average</div><div class="line">        0.00      1000.00      0.000      10.000         0.513</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_preypred"></a>
Continuous simulation: A prey-predator system</h2>
<p>We consider a classical prey-predator system, where the preys are food for the predators (see, e.g., <a class="el" href="citelist.html#CITEREF_sLAW00a">[116]</a>&thinsp;, page 87). Let \(x(t)\) and \(z(t)\) be the numbers of preys and predators at time \(t\), respectively. These numbers are integers, but as an approximation, we shall assume that they are real-valued variables evolving according to the differential equations </p><p class="formulaDsp">
\begin{align*} x’(t) &amp; = r x(t) - c x(t) z(t) \\ z’(t) &amp; = -s z(t) + d x(t) z(t) \end{align*}
</p>
<p> with initial values \(x(0)=x_0&gt;0\) and \(z(0)=z_0&gt;0\). This is a <em>Lotka-Volterra</em> system of differential equations, which has a known analytical solution. Here, in the program of Listing&#160; <a class="el" href="examples.html#REF_examples_lst_PreyPred">PreyPred</a>, we just show how to simulate its evolution, to illustrate the continuous simulation facilities of SSJ. Instead of using the default simulator as in the other examples of this section, this program explicitly creates a discrete-event <a class="el" href="classumontreal_1_1ssj_1_1simevents_1_1Simulator.html">umontreal.ssj.simevents.Simulator</a> object <code>sim</code> to manage the execution of the simulation. This is only to illustrate how this can be done. One could actually create several such <code>Simulator</code> objects that could run in parallel, each one having its own event list.</p>
<p><b>Simulation of the prey-predator system</b> &emsp;[PreyPred] <a class="anchor" id="REF_examples_lst_PreyPred"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>PreyPred {</div><div class="line">   <span class="keywordtype">double</span> r  = 0.005,      c  = 0.00001,</div><div class="line">          s  = 0.01,       d  = 0.000005,     h = 5.0;</div><div class="line">   <span class="keywordtype">double</span> x0 = 2000.0,     z0 = 150.0;</div><div class="line">   <span class="keywordtype">double</span> horizon = 501.0;</div><div class="line">   Simulator sim = <span class="keyword">new</span> Simulator();</div><div class="line">   Continuous x;</div><div class="line">   Continuous z;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) { <span class="keyword">new</span> PreyPred(); }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> PreyPred() {</div><div class="line">      x = <span class="keyword">new</span> Preys(sim);</div><div class="line">      z = <span class="keyword">new</span> Preds(sim);</div><div class="line">      sim.init();</div><div class="line">      <span class="keyword">new</span> EndOfSim(sim).schedule (horizon);</div><div class="line">      <span class="keyword">new</span> PrintPoint(sim).schedule (h);</div><div class="line">      (sim.continuousState()).selectRungeKutta4 (h);</div><div class="line">      x.startInteg (x0);</div><div class="line">      z.startInteg (z0);</div><div class="line">      sim.start();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>Preys <span class="keyword">extends</span> Continuous {</div><div class="line">      <span class="keyword">public</span> Preys(Simulator sim) { super(sim); }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">double</span> derivative (<span class="keywordtype">double</span> t) {</div><div class="line">         <span class="keywordflow">return</span> (r * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() - c * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() * z.value());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">class </span>Preds <span class="keyword">extends</span> <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#a774bfff9677b042003ce9d6afcedfb15">Continuous</a> {</div><div class="line">      <span class="keyword">public</span> Preds(Simulator sim) { super(sim); }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">double</span> derivative (<span class="keywordtype">double</span> t) {</div><div class="line">         <span class="keywordflow">return</span> (-s * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>() + d * x.value() * <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Continuous.html#ac25a1dff53df1bd7dc9f0844ee04ec82">value</a>());</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>PrintPoint <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> PrintPoint(Simulator sim) { super(sim); }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         System.out.println (sim.time() + <span class="stringliteral">&quot;  &quot;</span> + x.value() + <span class="stringliteral">&quot;  &quot;</span> + z.value());</div><div class="line">         this.schedule (h);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>EndOfSim <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> EndOfSim(Simulator sim) { super(sim); }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { sim.stop(); }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The program prints the triples \((t, x(t), z(t))\) at values of \(t\) that are multiples of <code>h</code>, one triple per line. This is done by an event of class <code>PrintPoint</code>, which is rescheduled at every <code>h</code> units of time. This output can be redirected to a file for later use, for example to plot a graph of the trajectory. The continuous variables <code>x</code> and <code>z</code> are instances of the classes <code>Preys</code> and <code>Preds</code>, whose method <code>derivative</code> give their derivative \(x’(t)\) and \(z’(t)\), respectively. The differential equations are integrated by a Runge-Kutta method of order 4.</p>
<h2><a class="anchor" id="REF_examples_sec_bank"></a>
A simplified bank</h2>
<p>This is the old Example&#160;1.4.1 of <a class="el" href="citelist.html#CITEREF_sBRA87a">[25]</a>&thinsp;, page&#160;14. A bank has a random number of tellers every morning. On any given day, the bank has \(t\) tellers with probability \(q_t\), where \(q_3 = 0.80\), \(q_2 = 0.15\), and \(q_1 = 0.05\). All the tellers are assumed to be identical from the modeling viewpoint.</p>
<p><b>Event-oriented simulation of the bank model</b> &emsp;[BankEv] <a class="anchor" id="REF_examples_lst_BankEv"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>BankEv {</div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">double</span> minute = 1.0 / 60.0;</div><div class="line">   <span class="keywordtype">int</span>      nbTellers;         <span class="comment">// Number of tellers.</span></div><div class="line">   <span class="keywordtype">int</span>      nbBusy;            <span class="comment">// Number of tellers busy.</span></div><div class="line">   <span class="keywordtype">int</span>      nbWait;            <span class="comment">// Queue length.</span></div><div class="line">   <span class="keywordtype">int</span>      nbServed;          <span class="comment">// Number of customers served so far</span></div><div class="line">   <span class="keywordtype">double</span>   meanDelay;         <span class="comment">// Mean time between arrivals.</span></div><div class="line">   Event    nextArriv       = <span class="keyword">new</span> Arrival();   <span class="comment">// The next arrival.</span></div><div class="line">   RandomStream  streamArr  = <span class="keyword">new</span> MRG32k3a();   <span class="comment">// Customer&#39;s arrivals</span></div><div class="line">   ErlangGen genServ = <span class="keyword">new</span> ErlangConvolutionGen (<span class="keyword">new</span> MRG32k3a(), 2, 1.0/minute);</div><div class="line">   RandomStream  streamTeller = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// Number of tellers</span></div><div class="line">   RandomStream  streamBalk   = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// Balking decisions</span></div><div class="line">   Tally statServed = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Nb. served per day&quot;</span>);</div><div class="line">   Tally avWait     = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average wait per day (hours)&quot;</span>);</div><div class="line">   Accumulate wait  = <span class="keyword">new</span> Accumulate (<span class="stringliteral">&quot;cumulated wait for this day&quot;</span>);</div><div class="line"></div><div class="line">   Event e9h45 = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         meanDelay = 2.0*minute;</div><div class="line">         nextArriv.schedule</div><div class="line">            (ExponentialGen.nextDouble (streamArr, 1.0/meanDelay));</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e10h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keywordtype">double</span> u = streamTeller.nextDouble();</div><div class="line">         <span class="keywordflow">if</span> (u &gt;= 0.2) nbTellers = 3;</div><div class="line">         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt; 0.05) nbTellers = 1;</div><div class="line">         <span class="keywordflow">else</span> nbTellers = 2;</div><div class="line">         <span class="keywordflow">while</span> (nbWait &gt; 0 &amp;&amp; nbBusy &lt; nbTellers) {</div><div class="line">            nbBusy++;  nbWait--;</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">         }</div><div class="line">         wait.update (nbWait);</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e11h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.reschedule ((nextArriv.time() - Sim.time())/2.0);</div><div class="line">         meanDelay = minute;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e14h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.reschedule ((nextArriv.time() - Sim.time())*2.0);</div><div class="line">         meanDelay = 2.0*minute;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   Event e15h = <span class="keyword">new</span> Event() {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { nextArriv.cancel(); }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keywordtype">boolean</span> balk() {</div><div class="line">      <span class="keywordflow">return</span> (nbWait &gt; 9) ||</div><div class="line">             (nbWait &gt; 5 &amp;&amp; (5.0*streamBalk.nextDouble() &lt; nbWait-5));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArriv.schedule</div><div class="line">            (ExponentialGen.nextDouble (streamArr, 1.0/meanDelay));</div><div class="line">         <span class="keywordflow">if</span> (nbBusy &lt; nbTellers) {</div><div class="line">            nbBusy++;</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!balk())</div><div class="line">            { nbWait++;  wait.update (nbWait); }</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">class </span>Departure <span class="keyword">extends</span>  <a class="code" href="classumontreal_1_1ssj_1_1simevents_1_1Event.html#a85b9e8172cffad1f169d55688e49a72f">Event</a> {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nbServed++;</div><div class="line">         <span class="keywordflow">if</span> (nbWait &gt; 0) {</div><div class="line">            <span class="keyword">new</span> Departure().schedule (genServ.nextDouble());</div><div class="line">            nbWait--;   wait.update (nbWait);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">else</span> nbBusy--;</div><div class="line">      }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulOneDay() {</div><div class="line">      Sim.init();       wait.init();</div><div class="line">      nbTellers = 0;    nbBusy    = 0;</div><div class="line">      nbWait    = 0;    nbServed  = 0;</div><div class="line">      e9h45.schedule (9.75);</div><div class="line">      e10h.schedule (10.0);</div><div class="line">      e11h.schedule (11.0);</div><div class="line">      e14h.schedule (14.0);</div><div class="line">      e15h.schedule (15.0);</div><div class="line">      Sim.start();</div><div class="line">      statServed.add (nbServed);</div><div class="line">      wait.update();</div><div class="line">      avWait.add (wait.sum());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateDays (<span class="keywordtype">int</span> numDays) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=numDays; i++)  simulOneDay();</div><div class="line">      System.out.println (statServed.report());</div><div class="line">      System.out.println (avWait.report());</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main (String[] args) {</div><div class="line">       <span class="keyword">new</span> BankEv().simulateDays (100);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The bank opens at 10:00 and closes at 15:00 (i.e., 3 p.m.). The customers arrive randomly according to a Poisson process with piecewise constant rate \(\lambda(t)\), \(t\ge0\). The arrival rate \(\lambda(t)\)</p>
<p>is 0.5 customer per minute from 9:45 until 11:00 and from 14:00 until 15:00, and one customer per minute from 11:00 until 14:00. The customers who arrive between 9:45 and 10:00 join a FIFO queue and wait for the bank to open. At 15:00, the door is closed, but all the customers already in will be served. Service starts at 10:00.</p>
<p>Customers form a FIFO queue for the tellers, with balking. An arriving customer will balk (walk out) with probability \(p_k\) if there are \(k\) customers ahead of him in the queue (not counting the people receiving service), where </p><p class="formulaDsp">
\[ p_k = \begin{cases} 0 &amp; \text{if $k\le5$;} \\ (n-5)/5 &amp; \text{if $5 &lt; k &lt; 10$;} \\ 1 &amp; \text{if $k\ge10$.} \end{cases} \]
</p>
<p> The customer service times are independent Erlang random variables: Each service time is the sum of two independent exponential random variables with mean one.</p>
<p>We want to estimate the expected number of customers served in a day, and the expected average wait for the customers served on a day.</p>
<p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_BankEv">BankEv</a> gives and event-oriented simulation program for this bank model. There are events at the fixed times 9:45, 10:00, 11:00, 14:00, and 15:00. At 9:45, the counters are initialized and the arrival process is started. The time until the first arrival, or the time between one arrival and the next one, is (tentatively) an exponential with a mean of 2 minutes. However, as soon as an arrival turns out to be past 11:00, its time must be readjusted to take into account the increase of the arrival rate at 11:00. The event 11:00 takes care of this readjustment, and the event at 14:00 makes a similar readjustment when the arrival rate decreases. We give the specific name <code>nextArriv</code> to the next planned arrival event in order to be able to reschedule that particular event to a different time. Note that a <em>single</em> arrival event is created at the beginning and this same event is scheduled over and over again. This can be done because there is never more than one arrival event in the event list. (We could have done that as well for the \(M/M/1\) queue in Listing <a class="el" href="examples.html#REF_examples_lst_QueueEv">QueueEv</a>.)</p>
<p>At the bank opening at 10:00, an event generates the number of tellers and starts the service for the corresponding customers. The event at 15:00 cancels the next arrival.</p>
<p>Upon arrival, a customer checks if a teller is free. If so, one teller becomes busy and the customer generates its service time and schedules his departure, otherwise the customer either balks or joins the queue. The balking decision is computed by the method <code>balk</code>, using the random number stream <code>streamBalk</code>. The arrival event also generates the next scheduled arrival. Upon departure, the customer frees the teller, and the first customer in the queue, if any, can start its service. The generator <code>genServ</code> is an <code>ErlangConvolutionGen</code> generator, so that the Erlang variates are generated by adding two exponentials instead of using inversion.</p>
<p>The method <code>simulateDays</code> simulates the bank for <code>numDays</code> days and prints a statistical report. If \(X_i\) is the number of customers served on day \(i\) and \(Q_i\) the total waiting time on day \(i\), the program estimates \(E[X_i]\) and \(E[Q_i]\) by their sample averages \(\bar{X}_n\) and \(\bar{Q}_n\) with \(n = \)<code>numDays</code>. For each simulation run (each day), <code>simulOneDay</code> initializes the clock, event list, and statistical probe for the waiting times, schedules the deterministic events, and runs the simulation. After 15:00, no more arrival occurs and the event list becomes empty when the last customer departs. At that point, the program returns to right after the <code>Sim.start()</code> statement and updates the statistical counters for the number of customers served during the day and their total waiting time.</p>
<p>The results are given in Listing&#160; <a class="el" href="examples.html#REF_examples_res_Bank">Bank results</a>.</p>
<p><b>Results of the <code>BankEv</code> program </b> &emsp;[Bank results] <a class="anchor" id="REF_examples_res_Bank"></a></p><div class="fragment"><div class="line">REPORT on Tally stat. collector ==&gt; Nb. served per day</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">       100      152.000      285.000      240.590      369.012       19.210</div><div class="line"></div><div class="line">REPORT on Tally stat. collector ==&gt; Average wait per day (hours)</div><div class="line">    num. obs.      min          max        average     variance    standard dev.</div><div class="line">       100        0.816       35.613        4.793       26.890        5.186</div></div><!-- fragment --><h2><a class="anchor" id="REF_examples_sec_call_center"></a>
A call center</h2>
<p>We consider here a simplified model of a telephone contact center (or <em>call center</em>) where agents answer incoming calls. Each day, the center operates for \(m\) hours. The number of agents answering calls and the arrival rate of calls vary during the day; we shall assume that they are constant within each hour of operation but depend on the hour. Let \(n_j\) be the number of agents in the center during hour \(j\), for \(j=0,…,m-1\). For example, if the center operates from 8 am to 9 pm, then \(m=13\) and hour \(j\) starts at ( \(j+8\)) o’clock. All agents are assumed to be identical. When the number of occupied agents at the end of hour \(j\) is larger than \(n_{j+1}\), ongoing calls are all completed but new calls are answered only when there are less than \(n_{j+1}\) agents busy. After the center closes, ongoing calls are completed and calls already in the queue are answered, but no additional incoming call is taken.</p>
<p>The calls arrive according to a Poisson process with piecewise constant rate, equal to \(R_j = B \lambda_j\) during hour \(j\), where the \(\lambda_j\) are constants and \(B\) is a random variable having the gamma distribution with parameters \((\alpha_0,\alpha_0)\). Thus, \(B\) has mean 1 and variance \(1/\alpha_0\), and it represents the <em>busyness</em> of the day; it is more busy than usual when \(B &gt; 1\) and less busy when \(B &lt; 1\). The Poisson process assumption means that conditional on \(B\), the number of incoming calls during any subinterval \((t_1, t_2]\) of hour \(j\) is a Poisson random variable with mean \((t_2 - t_1) B \lambda_j\) and that the arrival counts in any disjoint time intervals are independent random variables. This arrival process model is motivated and studied in <a class="el" href="citelist.html#CITEREF_ccWHI99c">[229]</a>&thinsp; and <a class="el" href="citelist.html#CITEREF_ccAVR04a">[12]</a>&thinsp;. More refined and realistic arrival process models can be found in <a class="el" href="citelist.html#CITEREF_ccIBR12b">[91]</a>, <a class="el" href="citelist.html#CITEREF_ccIBR16b">[92]</a>, <a class="el" href="citelist.html#CITEREF_ccORE16a">[179]</a>,</p>
<p>Incoming calls form a FIFO queue for the agents. A call is <em>lost</em> (abandons the queue) when its waiting time exceed its <em>patience time</em>. The patience times of calls are assumed to be i.i.d. random variables with the following distribution: with probability \(p\) the patience time is 0 (so the person hangs up unless there is an agent available immediately), and with probability \(1-p\) it is exponential with mean \(1/\nu\). The service times are i.i.d. gamma random variables with parameters \((\alpha,\beta)\).</p>
<p>We want to estimate the following quantities <em>in the long run</em> (i.e., over an infinite number of days): (a) \(w\), the average waiting time per call, (b) \(g(s)\), the fraction of calls whose waiting time is less than \(s\) seconds for a given threshold \(s\), and (c) \(\ell\), the fraction of calls lost due to abandonment.</p>
<p>Suppose we simulate the model for \(n\) days. For each day \(i\), let \(A_i\) be the number of arrivals, \(W_i\) the total waiting time of all calls, \(G_i(s)\) the number of calls who waited less than \(s\) seconds, and \(L_i\) the number of abandonments. For this model, the expected number of incoming calls in a day is \(a = E[A_i] = \sum_{j=0}^{m-1} \lambda_j\). Then, \(W_i/a\), \(G_i(s)/a\), and \(L_i/a\), \(i=1,…,n\), are i.i.d. unbiased estimators of \(w\), \(g(s)\), and \(\ell\), respectively, and can be used to compute confidence intervals for these quantities in a standard way if \(n\) is large.</p>
<p><b>Simulation of a simplified call center</b> &emsp;[CallCenter] <a class="anchor" id="REF_examples_lst_CallCenter"></a></p><div class="fragment"><div class="line"><span class="keyword">package </span>tutorial;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1simevents.html">simevents</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1rng.html">rng</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1randvar.html">randvar</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1probdist.html">probdist</a>.*;</div><div class="line"><span class="keyword">import</span> <a class="code" href="namespaceumontreal.html">umontreal</a>.<a class="code" href="namespaceumontreal_1_1ssj.html">ssj</a>.<a class="code" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a>.*;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>CallCenter {</div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">double</span> HOUR = 3600.0;  <span class="comment">// Time is in seconds.</span></div><div class="line"></div><div class="line">   <span class="comment">// Data</span></div><div class="line">   <span class="comment">// Arrival rates are per hour, service and patience times are in seconds.</span></div><div class="line">   <span class="keywordtype">double</span> openingTime;    <span class="comment">// Opening time of the center (in hours).</span></div><div class="line">   <span class="keywordtype">int</span> numPeriods;        <span class="comment">// Number of working periods (hours) in the day.</span></div><div class="line">   <span class="keywordtype">int</span>[] numAgents;       <span class="comment">// Number of agents for each period.</span></div><div class="line">   <span class="keywordtype">double</span>[] lambda;       <span class="comment">// Base arrival rate lambda_j for each j.</span></div><div class="line">   <span class="keywordtype">double</span> alpha0;         <span class="comment">// Parameter of gamma distribution for B.</span></div><div class="line">   <span class="keywordtype">double</span> p;              <span class="comment">// Probability that patience time is 0.</span></div><div class="line">   <span class="keywordtype">double</span> nu;             <span class="comment">// Parameter of exponential for patience time.</span></div><div class="line">   <span class="keywordtype">double</span> alpha, beta;    <span class="comment">// Parameters of gamma service time distribution.</span></div><div class="line">   <span class="keywordtype">double</span> s;              <span class="comment">// Want stats on waiting times smaller than s.</span></div><div class="line"></div><div class="line">   <span class="comment">// Variables</span></div><div class="line">   <span class="keywordtype">double</span> busyness;       <span class="comment">// Current value of B.</span></div><div class="line">   <span class="keywordtype">double</span> arrRate = 0.0;  <span class="comment">// Current arrival rate.</span></div><div class="line">   <span class="keywordtype">int</span> nAgents;           <span class="comment">// Number of agents in current period.</span></div><div class="line">   <span class="keywordtype">int</span> nBusy;             <span class="comment">// Number of agents occupied;</span></div><div class="line">   <span class="keywordtype">int</span> nArrivals;         <span class="comment">// Number of arrivals today;</span></div><div class="line">   <span class="keywordtype">int</span> nAbandon;          <span class="comment">// Number of abandonments during the day.</span></div><div class="line">   <span class="keywordtype">int</span> nGoodQoS;          <span class="comment">// Number of waiting times less than s today.</span></div><div class="line">   <span class="keywordtype">double</span> nCallsExpected; <span class="comment">// Expected number of calls per day.</span></div><div class="line"></div><div class="line">   Event nextArrival = <span class="keyword">new</span> Arrival();           <span class="comment">// The next Arrival event.</span></div><div class="line">   LinkedList&lt;Call&gt; waitList = <span class="keyword">new</span> LinkedList&lt;Call&gt;();</div><div class="line"></div><div class="line">   RandomStream streamB        = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For B.</span></div><div class="line">   RandomStream streamArr      = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For arrivals.</span></div><div class="line">   RandomStream streamPatience = <span class="keyword">new</span> MRG32k3a(); <span class="comment">// For patience times.</span></div><div class="line">   GammaGen genServ;      <span class="comment">// For service times; created in readData().</span></div><div class="line"></div><div class="line">   Tally[] allTal = <span class="keyword">new</span> Tally [4];</div><div class="line">   Tally statArrivals = allTal[0] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Number of arrivals per day&quot;</span>);</div><div class="line">   Tally statWaits = allTal[1] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Average waiting time per customer&quot;</span>);</div><div class="line">   Tally statGoodQoS = allTal[2] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Proportion of waiting times &lt; s&quot;</span>);</div><div class="line">   Tally statAbandon = allTal[3] = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Proportion of calls lost&quot;</span>);</div><div class="line">   Tally statWaitsDay = <span class="keyword">new</span> Tally (<span class="stringliteral">&quot;Waiting times within a day&quot;</span>);</div><div class="line"></div><div class="line">   <span class="keyword">public</span> CallCenter (String fileName) <span class="keywordflow">throws</span> IOException {</div><div class="line">      readData (fileName);</div><div class="line">      <span class="comment">// genServ can be created only after its parameters are read.</span></div><div class="line">      <span class="comment">// The acceptance/rejection method is much faster than inversion.</span></div><div class="line">      genServ = <span class="keyword">new</span> GammaAcceptanceRejectionGen (<span class="keyword">new</span> MRG32k3a(), alpha, beta);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Reads data and construct arrays.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> readData (String dataFile) <span class="keywordflow">throws</span> IOException {</div><div class="line">      Locale loc = Locale.getDefault();</div><div class="line">      Locale.setDefault(Locale.US); <span class="comment">// to read reals as 8.3 instead of 8,3</span></div><div class="line">      BufferedReader input = <span class="keyword">new</span> BufferedReader (<span class="keyword">new</span> FileReader (dataFile));</div><div class="line">      Scanner scan = <span class="keyword">new</span> Scanner(input);</div><div class="line">      openingTime = scan.nextDouble();      scan.nextLine();</div><div class="line">      numPeriods = scan.nextInt();          scan.nextLine();</div><div class="line">      numAgents = <span class="keyword">new</span> <span class="keywordtype">int</span>[numPeriods];</div><div class="line">      lambda = <span class="keyword">new</span> <span class="keywordtype">double</span>[numPeriods];</div><div class="line">      nCallsExpected = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numPeriods; j++) {</div><div class="line">         numAgents[j] = scan.nextInt();</div><div class="line">         lambda[j] = scan.nextDouble();</div><div class="line">         nCallsExpected += lambda[j];       scan.nextLine();</div><div class="line">      }</div><div class="line">      alpha0 = scan.nextDouble();      scan.nextLine();</div><div class="line">      p = scan.nextDouble();           scan.nextLine();</div><div class="line">      nu = scan.nextDouble();          scan.nextLine();</div><div class="line">      alpha = scan.nextDouble();       scan.nextLine();</div><div class="line">      beta = scan.nextDouble();        scan.nextLine();</div><div class="line">      s = scan.nextDouble();</div><div class="line">      scan.close();</div><div class="line">      Locale.setDefault(loc);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// A phone call object.</span></div><div class="line">   <span class="keyword">class </span>Call {</div><div class="line">      <span class="keywordtype">double</span> arrivalTime, serviceTime, patienceTime;</div><div class="line"></div><div class="line">      <span class="keyword">public</span> Call() {</div><div class="line">         serviceTime = genServ.nextDouble(); <span class="comment">// Generate service time.</span></div><div class="line">         <span class="keywordflow">if</span> (nBusy &lt; nAgents) {           <span class="comment">// Start service immediately.</span></div><div class="line">            nBusy++;</div><div class="line">            nGoodQoS++;</div><div class="line">            statWaitsDay.add (0.0);</div><div class="line">            <span class="keyword">new</span> CallCompletion().schedule (serviceTime);</div><div class="line">         } <span class="keywordflow">else</span> {                         <span class="comment">// Join the queue.</span></div><div class="line">            patienceTime = generPatience();</div><div class="line">            arrivalTime = Sim.time();</div><div class="line">            waitList.addLast (<span class="keyword">this</span>);</div><div class="line">         }</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> endWait() {</div><div class="line">         <span class="keywordtype">double</span> wait = Sim.time() - arrivalTime;</div><div class="line">         <span class="keywordflow">if</span> (patienceTime &lt; wait) { <span class="comment">// Caller has abandoned.</span></div><div class="line">            nAbandon++;</div><div class="line">            wait = patienceTime;    <span class="comment">// Effective waiting time.</span></div><div class="line">         } <span class="keywordflow">else</span> {</div><div class="line">            nBusy++;</div><div class="line">            <span class="keyword">new</span> CallCompletion().schedule (serviceTime);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">if</span> (wait &lt; s) nGoodQoS++;</div><div class="line">         statWaitsDay.add (wait);</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A new period begins.</span></div><div class="line">   <span class="keyword">class </span>NextPeriod <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keywordtype">int</span> j;     <span class="comment">// Number of the new period.</span></div><div class="line">      <span class="keyword">public</span> NextPeriod (<span class="keywordtype">int</span> period) { j = period; }</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         <span class="keywordflow">if</span> (j &lt; numPeriods) {</div><div class="line">            nAgents = numAgents[j];</div><div class="line">            arrRate = busyness * lambda[j] / HOUR;</div><div class="line">            <span class="keywordflow">if</span> (j == 0) {</div><div class="line">               nextArrival.schedule</div><div class="line">                  (ExponentialDist.inverseF (arrRate, streamArr.nextDouble()));</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">               checkQueue();</div><div class="line">               nextArrival.reschedule ((nextArrival.time() - Sim.time())</div><div class="line">                                       * lambda[j-1] / lambda[j]);</div><div class="line">            }</div><div class="line">            <span class="keyword">new</span> NextPeriod(j+1).schedule (1.0 * HOUR);</div><div class="line">         } <span class="keywordflow">else</span></div><div class="line">            nextArrival.cancel();  <span class="comment">// End of the day.</span></div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A call arrives.</span></div><div class="line">   <span class="keyword">class </span>Arrival <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() {</div><div class="line">         nextArrival.schedule</div><div class="line">            (ExponentialDist.inverseF (arrRate, streamArr.nextDouble()));</div><div class="line">         nArrivals++;</div><div class="line">         <span class="keyword">new</span> Call();               <span class="comment">// Call just arrived.</span></div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Event: A call is completed.</span></div><div class="line">   <span class="keyword">class </span>CallCompletion <span class="keyword">extends</span> Event {</div><div class="line">      <span class="keyword">public</span> <span class="keywordtype">void</span> actions() { nBusy--;   checkQueue(); }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Start answering new calls if agents are free and queue not empty.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> checkQueue() {</div><div class="line">      <span class="keywordflow">while</span> ((waitList.size() &gt; 0) &amp;&amp; (nBusy &lt; nAgents))</div><div class="line">         (waitList.removeFirst()).endWait();</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Generates the patience time for a call.</span></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">double</span> generPatience() {</div><div class="line">      <span class="keywordtype">double</span> u = streamPatience.nextDouble();</div><div class="line">      <span class="keywordflow">if</span> (u &lt;= p)</div><div class="line">         <span class="keywordflow">return</span> 0.0;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">         <span class="keywordflow">return</span> ExponentialDist.inverseF (nu, (1.0-u) / (1.0-p));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateOneDay (<span class="keywordtype">double</span> busyness) {</div><div class="line">      Sim.init();        statWaitsDay.init();</div><div class="line">      nArrivals = 0;     nAbandon = 0;</div><div class="line">      nGoodQoS = 0;      nBusy = 0;</div><div class="line">      this.busyness = busyness;</div><div class="line"></div><div class="line">      <span class="keyword">new</span> NextPeriod(0).schedule (openingTime * HOUR);</div><div class="line">      Sim.start();</div><div class="line">      <span class="comment">// Here the simulation is running...</span></div><div class="line"></div><div class="line">      statArrivals.add ((<span class="keywordtype">double</span>)nArrivals);</div><div class="line">      statAbandon.add ((<span class="keywordtype">double</span>)nAbandon / nCallsExpected);</div><div class="line">      statGoodQoS.add ((<span class="keywordtype">double</span>)nGoodQoS / nCallsExpected);</div><div class="line">      statWaits.add (statWaitsDay.sum() / nCallsExpected);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keywordtype">void</span> simulateOneDay () {</div><div class="line">      simulateOneDay (GammaDist.inverseF (alpha0, alpha0, 8,</div><div class="line">                                          streamB.nextDouble()));</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="keywordtype">void</span> main (String[] args) <span class="keywordflow">throws</span> IOException {</div><div class="line">      CallCenter cc = <span class="keyword">new</span> CallCenter (args.length == 1 ? args[0] : <span class="stringliteral">&quot;src/main/docs/examples/tutorial/CallCenter.dat&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10000; i++)  cc.simulateOneDay();</div><div class="line">      System.out.println (<span class="stringliteral">&quot;\nNumber of calls expected per day = &quot;</span> + cc.nCallsExpected +<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cc.allTal.length; i++) {</div><div class="line">         cc.allTal[i].setConfidenceIntervalStudent();</div><div class="line">         cc.allTal[i].setConfidenceLevel (0.90);</div><div class="line">      }</div><div class="line">      System.out.println (Tally.report (<span class="stringliteral">&quot;CallCenter:&quot;</span>, cc.allTal));</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Listing&#160; <a class="el" href="examples.html#REF_examples_lst_CallCenter">CallCenter</a> gives an event-oriented simulation program for this call center model. When the <code>CallCenter</code> class is instantiated by the <code>main</code> method, the random streams, list, and statistical probes are created, and the model parameters are read from a file by the method <code>readData</code>. The line <code>Locale.setDefault(Locale.US)</code> is added because real numbers in the data file are read in the anglo-saxon form 8.3 instead of the form 8,3 used by many other countries. The <code>main</code> program then simulates \(n = 100000\) operating days and prints the value of \(a\), as well as 90% confidence intervals on \(a\), \(w\), \(g(s)\), and \(\ell\), based on their estimators \(\bar{A}_n\), \(\bar{W}_n/a\), \(\bar{G}_n(s)/a\), and \(\bar{L}_n/a\), assuming that these estimators have approximately the Student distribution. This is justified by the fact that \(W_i\), and \(G_i(s)\), and \(L_i\) are themselves “averages” over several observations, so we may expect their distribution to be not far from a normal.</p>
<p>To generate the service times, we use a gamma random variate generator called <code>genServ</code>, created in the constructor after the parameters \((\alpha,\beta)\) of the service time distribution have been read from the data file. For the other random variables in the model, we simply create random streams of i.i.d. uniforms (in the preamble) and apply inversion explicitly to generate the random variates. The latter approach is more convenient, e.g., for patience times because their distribution is not standard and for the inter-arrival times because their mean changes every period. For the gamma service time distribution, on the other hand, the parameters always remain the same and inversion is rather slow, so we decided to create a generator that uses a faster special method.</p>
<p>The method <code>simulateOneDay</code> simulates one day of operation. It initializes the simulation clock, event list, and counters, schedules the center’s opening and the first arrival, and starts the simulation. When the day is over, it updates the statistical collectors. Note that there are two versions of this method; one that generates the random variate \(B\) and the other that takes its value as an input parameter. This is convenient in case one wishes to simulate the center with a fixed value of \(B\).</p>
<p>An event <code>NextPeriod(j)</code> marks the beginning of each period \(j\). The first of these events (for \(j=0\)) is scheduled by <code>simulateOneDay</code>; then the following ones schedule each other successively, until the end of the day. This type of event updates the number of agents in the center and the arrival rate for the next period. If the number of agents has just increased and the queue is not empty, some calls in the queue can now be answered. The method <code>checkQueue</code> verifies this and starts service for the appropriate number of calls. The time until the next planned arrival is readjusted to take into account the change of arrival rate, as follows. The inter-arrival times are i.i.d. exponential with mean \(1/R_{j-1}\) when the arrival rate is fixed at \(R_{j-1}\). But when the arrival rate changes from \(R_{j-1}\) to \(R_j\), the residual time until the next arrival should be modified from an exponential with mean \(1/R_{j-1}\) (already generated) to an exponential with mean \(1/R_j\). Multiplying the residual time by \(\lambda_{j-1}/\lambda_j\) is an easy way to achieve this. We give the specific name <code>nextArrival</code> to the next arrival event in order to be able to reschedule it to a different time. Note that there is a <em>single</em> arrival event which is scheduled over and over again during the entire simulation. This is more efficient than creating a new arrival event for each call, and can be done here because there is never more than one arrival event at a time in the event list. At the end of the day, simply canceling the next arrival makes sure that no more calls will arrive.</p>
<p>Each arrival event first schedules the next one. Then it increments the arrivals counter and creates the new call that just arrived. The call’s constructor generates its service time and decides where the incoming call should go. If an agent is available, the call is answered immediately (its waiting time is zero), and an event is scheduled for the completion of the call. Otherwise, the call must join the queue; its patience time is generated by <code>generPatience</code> and memorized, together with its arrival time, for future reference.</p>
<p>Upon completion of a call, the number of busy agents is decremented and one must verify if a waiting call can now be answered. The method <code>checkQueue</code> verifies that and if the answer is yes, it removes the first call from the queue and activates its <code>endWait</code> method. This method first compares the call’s waiting time with its patience time, to see if this call is still waiting or has been lost (by abandonment). If the call was lost, we consider its waiting time as being equal to its patience time (i.e., the time that the caller has really waited), for the statistics. If the call is still there, the number of busy agents is incremented and an event is scheduled for the call completion.</p>
<p>The results of this program, with the data in file <code>CallCenter.dat</code>, are shown in Listing&#160; <a class="el" href="examples.html#REF_examples_res_CallCenter">CallCenter results</a>.</p>
<p><b>Simulation of a simplified call center</b> &emsp;[CallCenter results] <a class="anchor" id="REF_examples_res_CallCenter"></a></p><div class="fragment"><div class="line"></div><div class="line">Number of calls expected per day = 1660.0</div><div class="line"></div><div class="line">Report for CallCenter:</div><div class="line">                                    num obs.     min        max        average      variance      std. dev.   conf. int.  </div><div class="line">Number of arrivals per day          10000    1317.000    2061.000     1660.366     8764.756        93.620   90.0% ( 1658.826, 1661.906)</div><div class="line">Average waiting time per customer   10000       0.619      17.822        4.713        3.987         1.997   90.0% (    4.680,    4.746)</div><div class="line">Proportion of waiting times &lt; s     10000       0.769       1.076        0.925       1.6E-3         0.040   90.0% (    0.924,    0.925)</div><div class="line">Proportion of calls lost            10000      3.0E-3       0.058        0.020       4.6E-5        6.7E-3   90.0% (    0.020,    0.020)</div></div><!-- fragment --><p>This model is certainly an oversimplification of actual call centers. It can be embellished and made more realistic by considering different types of agents, different types of calls, agents taking breaks for lunch, coffee, or going to the restroom, agents making outbound calls to reach customers when the inbound traffic is low (e.g., for marketing purpose or for returning calls), and so on. One could also model the revenue generated by calls and the operating costs for running the center, and use the simulation model to compare alternative operating strategies in terms of the expected net revenue, for example.</p>
<p>A more elaborate simulation library for call centers, built over SSJ, can be found in <a class="el" href="citelist.html#CITEREF_ccBUI05a">[29]</a>, <a class="el" href="citelist.html#CITEREF_iBUI12a">[30]</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
