<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSJ: Package umontreal.ssj.hups</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ["script","noscript","style","textarea","pre"]
  }
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SSJ
   &#160;<span id="projectnumber">3.3.0</span>
   </div>
   <div id="projectbrief">Stochastic Simulation in Java</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html">hups</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Package umontreal.ssj.hups</div>  </div>
</div><!--header-->
<div class="contents">

<p>Highly Uniform Point Sets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">AntitheticPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class provides antithetic points.  <a href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html">BakerTransformedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class embodies a point set to which a <em>Baker transformation</em> is applied (see, e.g., <a class="el" href="citelist.html#CITEREF_vHIC02a">[82]</a>&thinsp;).  <a href="classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">CachedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class caches a point set by precomputing and storing its points locally in an array.  <a href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">ContainerPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This acts as a generic base class for all <em>container classes</em> that contain a point set and apply some kind of transformation to the coordinates to define a new point set.  <a href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html">CycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LFSR generators produce numbers by generating a sequence of bits from a linear recurrence modulo 2, and forming fractional numbers by taking blocks of successive bits.  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class provides the basic structures for storing and manipulating a point set defined by a set of cycles.  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">CycleBasedPointSetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a>, except that the successive values in the cycles are stored as integers in the range \(\{0,…,2^k-1\}\), where \(1\le k \le31\).  <a href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the basic structures for storing and manipulating <em>linear digital nets in base \(b\)</em>, for an arbitrary base \(b\ge2\).  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">DigitalNetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> for the base \(b=2\).  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html">DigitalNetBase2FromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to read the parameters defining a digital net <em>in base 2</em> either from a file, or from a URL address on the World Wide Web.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html">DigitalNetFromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to read the parameters defining a digital net either from a file, or from a URL address on the World Wide Web.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">DigitalSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html">DigitalSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html">EmptyRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an empty <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">F2wCycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear feedback shift register sequence.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">F2wCycleBasedPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear congruential sequence in the finite field \(\mathbb F_{2^w}[z]/P(z)\).  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">F2wNetLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a linear feedback shift register generator.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">F2wNetPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a polynomial LCG in \(\mathbb F_{2^w}[z]/P(z)\).  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html">F2wStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements methods and fields needed by the classes <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">umontreal.ssj.hups.F2wNetLFSR</a>, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">umontreal.ssj.hups.F2wNetPolyLCG</a>, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">umontreal.ssj.hups.F2wCycleBasedLFSR</a> and <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">umontreal.ssj.hups.F2wCycleBasedPolyLCG</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html">FaureSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets or digital sequences formed by the first \(n = b^k\) points of the Faure sequence in base \(b\).  <a href="classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html">HaltonSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the sequence of Halton <a class="el" href="citelist.html#CITEREF_rHAL60a">[74]</a>&thinsp;, which is essentially a modification of Hammersley nets for producing an infinite sequence of points having low discrepancy.  <a href="classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html">HammersleyPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>Hammersley point sets</em>, which are defined as follows.  <a href="classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html">IndependentPointsCached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to IndependentPoints, but the points are all generated and stored (cached) when the point set is randomized.  <a href="classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html">KorobovLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>Korobov lattices</em>, which represents the same point sets as in class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a>, but implemented differently.  <a href="classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLatticeSequence.html">KorobovLatticeSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html">LatinHypercube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Latin Hypercube Sampling (LHS) with \(n\) points in the \(s\)-dimensional unit hypercube.  <a href="classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a recurrence-based point set defined via a linear congruential recurrence of the form \(x_i = a x_{i-1} \mod n\) and \(u_i = x_i / n\).  <a href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html">LMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a left matrix scrambling and adds a random digital shift.  <a href="classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html">NestedUniformScrambling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a> that performs Owen's nested uniform scrambling <a class="el" href="citelist.html#CITEREF_vOWE95a">[186]</a>, <a class="el" href="citelist.html#CITEREF_vOWE03a">[190]</a> .  <a href="classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html">NiedSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences constructed from the Niederreiter sequence in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html">NiedXingSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences based on the Niederreiter-Xing sequence in base 2.  <a href="classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">PaddedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class realizes <em>padded point sets</em>, constructed by taking some coordinates from a point set \(P_1\), other coordinates from a point set \(P_2\), and so on.  <a href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">PointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class represents a general point set.  <a href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">PointSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface for <em>iterators</em> that permit one to go through the points of a #PointSet and the successive coordinates of these points.  <a href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface is used to randomize a <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>.  <a href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html">RadicalInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements basic methods for working with radical inverses of integers in an arbitrary basis \(b\).  <a href="classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html">RandomShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomStart.html">RandomStart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that randomizes a sequence with a random starting point.  <a href="classumontreal_1_1ssj_1_1hups_1_1RandomStart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html">RandShiftedMod1PointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class embodies a point set to which a random shift modulo 1 is applied (i.e., a single uniform random point is added to all points, modulo 1, to randomize the inner point set).  <a href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements point sets specified by integration lattices of rank.  <a href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html">RQMCPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used for <em>randomized quasi-Monte Carlo</em> (RQMC) simulations <a class="el" href="citelist.html#CITEREF_vLEC00b">[123]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[124]</a>, <a class="el" href="citelist.html#CITEREF_vOWE97a">[187]</a>, <a class="el" href="citelist.html#CITEREF_vOWE97b">[188]</a>&thinsp;.  <a href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html">SMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a striped matrix scrambling and adds a random digital shift.  <a href="classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html">SobolSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets or digital sequences in base 2 formed by the first \(n = 2^k\) points of a Sobol’ sequence <a class="el" href="citelist.html#CITEREF_rSOB67a">[216]</a>, <a class="el" href="citelist.html#CITEREF_rSOB76b">[217]</a>&thinsp;.  <a href="classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SortedAndCutPointSet.html">SortedAndCutPointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation.  <a href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html">StratifiedUnitCubeAnti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation, similar to <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a>.  <a href="classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">SubsetOfPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class permits one to select a subset of a point set.  <a href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Highly Uniform Point Sets. </p>
<h2>Monte Carlo and quasi-Monte Carlo</h2>
<p>This package provides classes implementing <em>highly uniform point sets</em> (HUPS) over the \(s\)-dimensional unit hypercube \([0,1)^s\), and tools for their randomization. The terminology <em>low-discrepancy sequence</em> (LDS) is often used for infinite sequences of points such that the <em>discrepancy</em> between the distribution of the first \(n\) points of the sequence and the uniform distribution converges to zero at a certain rate when \(n\to\infty\) <a class="el" href="citelist.html#CITEREF_rNIE92b">[182]</a>. HUPS and LDS are used for quasi-Monte Carlo integration, as we now briefly explain. For more details, see <a class="el" href="citelist.html#CITEREF_rDIC10a">[49]</a>, <a class="el" href="citelist.html#CITEREF_fGLA04a">[67]</a>, <a class="el" href="citelist.html#CITEREF_rHEL98a">[77]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[124]</a>, <a class="el" href="citelist.html#CITEREF_vLEC03b">[149]</a>, <a class="el" href="citelist.html#CITEREF_vLEC09f">[153]</a>, <a class="el" href="citelist.html#CITEREF_vLEC18a">[157]</a>, <a class="el" href="citelist.html#CITEREF_vOWE98a">[189]</a>, <a class="el" href="citelist.html#CITEREF_rNIE92b">[182]</a>, <a class="el" href="citelist.html#CITEREF_rNUY14a">[183]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[214]</a>; for example.</p>
<p>Suppose we want to estimate the integral of a function \(f\) defined over the \(s\)-dimensional unit hypercube, <a class="anchor" id="REF_hups_overview_eq_mu"></a> </p><p class="formulaDsp">
\[ \mu= \int_{[0,1)^s} f(\mathbf{u}) d\mathbf{u}. \tag{mu} \]
</p>
<p> Practically any mathematical expectation that can be estimated by simulation can be written in this way, usually for a very complicated \(f\) and sometimes for \(s=\infty\). Indeed, the source of randomness of stochastic simulations is usually a <em>stream</em> of real numbers \(\mathbf{u}= (u_0,u_1,u_2,…)\) whose purpose is to imitate i.i.d. \(U(0,1)\) random variables. These real numbers are transformed in complicated ways to produce the estimator. Thus, the dimension \(s\) of the integral in (<a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_mu">mu</a>) represents the number of calls to the uniform random number generator if that number is deterministic. If it is random and unbounded, we take \(s = \infty\). In the latter case, we shall assume that the <em>actual</em> number of calls is finite with probability one (otherwise the simulation may never end).</p>
<p>We consider an estimator of \(\mu\) of the form <a class="anchor" id="REF_hups_overview_eq_Qn"></a> </p><p class="formulaDsp">
\[ Q_n = \frac{1}{n} \sum_{i=0}^{n-1} f(\mathbf{u}_i), \tag{Qn} \]
</p>
<p> which is the average of \(f\) over the <em>point set</em> \(P_n = \{\mathbf{u}_0,…,\mathbf{u}_{n-1}\} \subset[0,1)^s\). With the <em>Monte Carlo</em> (MC) method, the \(\mathbf{u}_i\)’s are i.i.d. random vectors uniformly distributed over \([0,1)^s\). Then, \(Q_n\) is an unbiased estimator of \(\mu\) with variance \(\sigma^2/n\), where </p><p class="formulaDsp">
\[ \sigma^2 = \int_{[0,1)^s} f^2(\mathbf{u}) d\mathbf{u}- \mu^2, \]
</p>
<p> and it obeys a central-limit theorem if \(\sigma^2 &lt; \infty\).</p>
<p><em>Quasi-Monte Carlo</em> (QMC) methods use point sets \(P_n\) that are <em>more evenly distributed</em> over the unit hypercube than typical random points. We call them <em>highly uniform point sets</em> (HUPS) or <em>QMC point sets</em>. The aim is to reduce the size of the integration error \(Q_n - \mu\). Among the most important classes of methods for constructing such point sets, we find are <em>digital nets</em>, <em>integration lattices in the real space</em>, <em>polynomial integration lattices</em>, <em>Hammersley points</em>, <em>Halton sequences</em>, etc.; see <a class="el" href="citelist.html#CITEREF_rDIC10a">[49]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[124]</a>, <b>[18a]</b>, <a class="el" href="citelist.html#CITEREF_rNIE92b">[182]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[214]</a>. All the methods named above are implemented in this package, in various flavors.</p>
<p>The deterministic QMC points can also be randomized in a way that each point has the uniform distribution in the unit cube while the point set as a whole keeps its high uniformity. This gives rise to randomized QMC (RQMC), which provides an unbiased estimator of \(\mu\) whose variance can be estimated via independent replications. This is further discussed below.</p>
<h2>Elementary constructions</h2>
<p>To give an idea of how HUPS and LDS can be constructed, we start with a simple one-dimensional example. If \(s=1\) and \(n\) is fixed, very simple highly uniform constructions are the point sets \(P_n = \{0,  1/n, …, (n-1)/n\}\) and the shifted version \(P’_n = \{1/(2n),  3/(2n),  …, (2n-1)/(2n)\}\).</p>
<p>In \(s &gt; 1\) dimensions, the simplest extensions would be as follows. Let \(n = d^s\) for some integer \(d\) and define \(P_n\) as the Cartesian product of \(s\) copies of the one-dimensional sets \(P_d\); that is, \(P_n = \{(u_0,…,u_{s-1}) : u_j \in\{0,  1/d,  …, (d-1)/d\}\) for each \(j\}\), and similarly for \(P’_n\). The point sets thus obtained are regular rectangular grids. Unfortunately, this approach breaks down rapidly when \(s\) gets large, because \(n\) must increase exponentially fast with \(s\) for fixed \(d\). Another important drawback is that when \(P_n\) is projected over lower-dimensional subspaces, several points are projected onto each other and become redundant <a class="el" href="citelist.html#CITEREF_vLEC02a">[124]</a>.</p>
<p>A better idea is to construct a point set \(P_n\) in \(s\) dimensions such that each one-dimensional projection of \(P_n\) is the set of values \(\{0,  1/n,  …, (n-1)/n\}\). Of course, these values should not be visited in the same order for all coordinates, because otherwise all the points would lie on the diagonal line going from \((0,…,0)\) to \((1,…,1)\). In other words, for each coordinate \(j\), \(0\le j &lt; s\), we must define a different <em>permutation</em> of the integers \(\{0,…,n-1\}\) and visit the values \(\{0,  1/n,  …, (n-1)/n\}\) in the order determined by that permutation. The trick is to select those permutations in a way that \(P_n\) itself is highly uniform over \([0,1)^s\) in a well-defined sense (there are many ways to define it). This is what most construction methods attempt to achieve. Before looking at concrete ways of defining such permutations, we introduce a related issue: what to do if \(n\) is not fixed.</p>
<p>For \(s=1\), a simple way of filling up the unit interval \([0,1)\) uniformly is via the low-discrepancy sequence 0, 1/2, 1/4, 3/4, 1/8, 5/8, 3/8, 7/8, 1/16, 9/16, …, called the <em>van der Corput sequence</em> in base 2. More generally, select an integer \(b \ge2\), called the <em>base</em>. The <em>radical inverse</em> function in base \(b\), \(\psi_b : \mathbb{N}\to[0,1)\), is defined as follows. If \(i\) is a \(k\)-digit integer in base \(b\) with digital \(b\)-ary expansion </p><p class="formulaDsp">
\[ i = a_0 + a_1 b + …+ a_{k-1} b^{k-1}, \]
</p>
<p> then </p><p class="formulaDsp">
\[ \psi_b(i) = a_0 b^{-1} + a_1 b^{-2} + \cdots+ a_{k-1} b^{-k}. \]
</p>
<p> For a given \(b\), \(\psi_b(0), \psi_b(1), \psi_b(2), …\) is called the <em>van der Corput sequence in base \(b\)</em>. This sequence fills up the unit interval \([0,1)\) quite uniformly. For example, for \(b=2\) we obtain the sequence mentioned above and for \(b=3\) we obtain 0, 1/3, 2/3, 1/9, 4/9, 7/9, 2/9, 5/9, 8/9, 1/27, 10/27, 19/27, …. Moreover, for two relatively prime bases \(b_1\) and \(b_2\), the two sequences have no value in common except 0.</p>
<p>For \(s &gt; 1\), one could either take different (relatively prime) bases for the different coordinates, or take the same basis \(b\) but permute the successive values using a different permutation for each coordinate. These permutations are usually selected in a way that for every integer \(k\), the first \(b^k\) values that are enumerated remain the same (they are the values of \(\psi_b(i)\) for \(i=0,…,b^k-1\)), but they are enumerated in a different order. Several digital net constructions (to be defined later) fit this framework.</p>
<p>If we decide to take different bases, the most natural choice is to take the \(j\)th smallest prime, \(b_j\), as a base for coordinate \(j-1\); that is, base 2 for coordinate 0, base 3 for coordinate 1, base 5 for coordinate 2, and so on. The infinite sequence thus defined, where point \(i\) is <a class="anchor" id="REF_hups_overview_eq_Halton_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_s}(i)) \tag{Halton-point} \]
</p>
<p> for \(i \ge0\), was proposed in <a class="el" href="citelist.html#CITEREF_rHAL60a">[74]</a>&thinsp; and is called the <em>Halton sequence</em>. One drawback of this sequence is that for large \(s\), the base \(b_s\) becomes quite large.</p>
<p>In the case where \(n\) is fixed, we can always take \(i/n\) as the first coordinate of point \(i\). In particular, the <em>Hammersley point set</em> with \(n\) points in \(s\) dimensions contains the points <a class="anchor" id="REF_hups_overview_eq_Hammersley_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (i/n,\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_{s-1}}(i)), \tag{Hammersley-point} \]
</p>
<p> for \(i=0,…,n-1\) <a class="el" href="citelist.html#CITEREF_rHAM60a">[76]</a>&thinsp;. Historically, Halton sequences were defined as extensions of Hammersley point sets. Hammersley points and Halton sequences are implemented in the classes <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html">HammersleyPointSet</a> and <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html">HaltonSequence</a>.</p>
<h2>Digital nets</h2>
<p><em>Digital nets and sequences</em> are an important class of HUPS and LDS constructions. Most concrete implementations, e.g., those proposed by Sobol’, Faure, Niederreiter, Niederreiter and Xing, Dick, etc., are <em>linear</em> digital nets and sequences, defined as follows (see also <a class="el" href="citelist.html#CITEREF_rDIC10a">[49]</a>, <a class="el" href="citelist.html#CITEREF_vLEC02a">[124]</a>, <a class="el" href="citelist.html#CITEREF_rNIE92b">[182]</a>, <a class="el" href="citelist.html#CITEREF_rTEZ95a">[225]</a>).</p>
<p>Let \(b\ge2\) be an arbitrary integer (usually a prime number), called the <em>base</em>. A net that contains \(n = b^k\) points in \(s\) dimensions is defined via \(s\) <em>generator matrices</em> \(\mathbf{C}_0,…,\mathbf{C}_{s-1}\), which are (in theory) \(\infty\times k\) matrices whose elements are in \(\mathbb{Z}_b = \{0,\dots,b-1\}\). The matrix \(\mathbf{C}_j\) is used for coordinate \(j\) of all the points, for \(j\ge0\). To define the \(i\)th point \(\mathbf{u}_i\), for \(i=0,…,b^k-1\), write the digital expansion of \(i\) in base \(b\) and multiply the vector of its digits by \(\mathbf{C}_j\) to obtain the digits of the expansion of \(u_{i,j}\), the \(j\)th coordinate of \(\mathbf{u}_i\). That is, <a class="anchor" id="REF_hups_overview_eq_digital_i"></a><a class="anchor" id="REF_hups_overview_eq_digital_Cj"></a><a class="anchor" id="REF_hups_overview_eq_digital_uij"></a><a class="anchor" id="REF_hups_overview_eq_digital_ui"></a> </p><p class="formulaDsp">
\begin{align} i &amp; = \sum_{\ell=0}^{k-1} a_{i,\ell} b^{\ell}, \tag{digital-i} \\ \begin{pmatrix} u_{i,j,1} \\ u_{i,j,2} \\ \vdots \end{pmatrix} &amp; = \mathbf{C}_j \begin{pmatrix} a_{i,0} \\ a_{i,1} \\ \vdots \\ a_{i,k-1} \end{pmatrix} , \tag{digital-Cj} \\ u_{i,j} &amp; = \sum_{\ell=1}^{\infty}u_{i,j,\ell} b^{-\ell}, \tag{digital-uij} \\ \mathbf{u}_i &amp; = (u_{i,0},…,u_{i,s-1}). \tag{digital-ui} \end{align}
</p>
<p> In practice, the expansion in ( <a class="el" href="namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_digital_uij">digital-uij</a> ) is truncated to the first \(w\) digits for some positive integer \(w\), so each matrix \(\mathbf{C}_j\) is actually truncated to a \(w\times k\) matrix. Typically \(w\) is equal to \(k\), or is slightly larger, or is selected so that \(b^r\) is near or equal to the largest representable integer, e.g., \(2^{31}\) on an 32-bit processor, and perhaps \(2^{53}\) or larger on a 64-bit processor, to take advantage of the precision of floating-point numbers in <code>double</code> for the \(u_{i,j}\)'s.</p>
<p>Usually, the first \(k\) lines of each \(\mathbf{C}_j\) form a nonsingular \(k\times k\) matrix. Then, the \(n\) output values for coordinate \(j\), \(u_{0,j},\dots, u_{n-1,j}\), when truncated to their first \(k\) fractional digits in base \(b\), are a permutation of the numbers \(0, 1/n,\dots, (n-1)/n\). Different coordinates would use different permutations, implemented via the matrices \(\mathbf{C}_j\).</p>
<p>When the first \(k\) lines of \(\mathbf{C}_j\) form the identity and the other lines are zero, the first \(n\) output values are the first \(n\) elements of the van der Corput sequence in base \(b\). If we reverse the order of the columns of that matrix \(\mathbf{C}_j\) (i.e., column \(c\) will contain a one in line \(k-c+1\) and zeros elsewhere, for \(0\le c &lt; k\)), we obtain the output values \(0, 1/n, …, (n-1)/n\) in that order. With a slight abuse of language, we shall call this first matrix (with the identity followed by lines of zeros) the <em>identity</em> and the second one (with the columns in reverse order) the <em>reflected identity</em>. It is customary to take \(\mathbf{C}_0\) as the identity for digital sequences, and often for digital nets as well. But for digital nets (where \(n\) is fixed in advance), one can take \(\mathbf{C}_0\) as the reflected identity instead, then \(\mathbf{C}_1\) as the identity, and so on. That is, the matrix \(\mathbf{C}_j\) for the digital net is taken as the matrix \(\mathbf{C}_{j-1}\) of the digital sequence. The <code>hups</code> package often gives the choice.</p>
<p>For digital sequences, the matrices \(\mathbf{C}_j\) actually have an infinite number of columns, although only the first \(k\) columns are needed to generate the first \(b^k\) points. So in practice, we never need to store more than a finite number of columns at a time. When we need more than \(b^k\) points for the current value of \(k\), we can simply increase \(k\) and add the corresponding columns to the matrices \(\mathbf{C}_j\), assuming that we can compute them.</p>
<p>The classes <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a> and <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">umontreal.ssj.hups.DigitalSequence</a> implement generic digital nets and sequences. Specific instances are constructed in subclasses of these two classes. In particular, <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">umontreal.ssj.hups.DigitalNetBase2</a> implements digital nets in base 2, which are the most popular because computations in binary arithmetic is generally much faster than in other bases. Among those, we find Sobol sequences and Sobol nets, for instance; see <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html">SobolSequence</a>. Polynomial lattice rules turn out to be special cases of digital nets and in practice, to generate the points, we implement them as digital nets.</p>
<h2>Lattice Rules</h2>
<p>An <em>integration lattice</em> is a discrete (but infinite) subset of \(\mathbb{R}^s\) of the form </p><p class="formulaDsp">
\[ L_s = \left\{\mathbf{v}= \sum_{j=1}^s h_j {\mathbf{v}_j} \mbox{ such that each } h_j\in\mathbb{Z}\right\}, \]
</p>
<p> where \(\mathbf{v}_1,…,\mathbf{v}_s \in\mathbb{R}^s\) are linearly independent over \(\mathbb{R}\) and \(\mathbb{Z}^s \subseteq L_s\). This last condition means that \(L_s\) must contain all integer vectors, and this implies that \(L_s\) is periodic with period 1 along each of the \(s\) coordinates. The approximation of \(\mu\) by \(Q_n\) with the point set \(P_n = L_s \cap[0,1)^s\) is called a <em>lattice rule</em> <a class="el" href="citelist.html#CITEREF_vHIC98c">[80]</a>, <a class="el" href="citelist.html#CITEREF_mKOR59a">[111]</a>, <a class="el" href="citelist.html#CITEREF_vLEC00b">[123]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[214]</a>. The value of \(n\) is the number of points of the lattice that are in the unit hypercube \([0,1)^s\).</p>
<p>Let \(\mathbf{V}\) be the matrix whose rows are the basis vectors \(\mathbf{v}_1,\cdots,\mathbf{v}_s\) and \(\mathbf{V}^{-1}\) its inverse. One has \(\mathbb{Z}^s\subseteq L_s\) if and only if all entries of \(\mathbf{V}^{-1}\) are integer. When this holds, \(n = \det(\mathbf{V}^{-1})\) and all entries of \(\mathbf{V}\) are multiples of \(1/n\). The <em>rank</em> of the lattice is the smallest \(r\) such that one can find a basis of the form \(\mathbf{v}_1,\dots, \mathbf{v}_r,\mathbf{e}_{r+1},\cdots,\mathbf{e}_s\), where \(\mathbf{e}_j\) is the \(j\)th unit vector in \(s\) dimensions. In particular, a lattice rule of <em>rank 1</em> has a basis of the form \(\mathbf{v}_1 = (a_1, \dots, a_s)/n\) and \(\mathbf{v}_j = \mathbf{e}_j\) for \(j&gt;1\), where \(a_j \in\mathbb{Z}_n\) for each \(j\). Lattice rules of rank 1 are implemented in <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">Rank1Lattice</a>. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html">KorobovLattice</a> implements <em>Korobov</em> lattice rules, which occur when \(\mathbf{v}_1\) has the special form \(\mathbf{v}_1 = (1,\; a,\; a^2 \mod n,\; \dots \; a^{s-1} \mod n)/n\) for some \(a\in\mathbb{Z}_n\). The point set \(P_n\) of a Korobov lattice rule can also be written as \(P_n = \{(x_1,…,x_s)/n \mbox{ such that } x_1\in\mathbb{Z}_n \mbox{ and } x_j = a x_{j-1} \mod n \mbox{ for all } j &gt; 1\}\). This is the set of all vectors of successive values produced by a linear congruential generator (LCG) with modulus \(n\) and multiplier \(a\), from all possible initial states, including 0. In this case, the points are easy to enumerate by using the recurrence, and this is what we do in <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a>.</p>
<p>Uniformity criteria for lattice rules, and methods and software to search for good parameters \(a_1,\dots, a_s\) for rank 1 lattice rules for any given \(s\) and \(n\) and various types of criteria, can be found in <a class="el" href="citelist.html#CITEREF_vLEC12a">[126]</a>, <a class="el" href="citelist.html#CITEREF_vLEC12b">[125]</a>, <a class="el" href="citelist.html#CITEREF_vLEC16a">[127]</a>, and <a class="el" href="citelist.html#CITEREF_rNUY14a">[183]</a>, for example.</p>
<h2>Cycle-based point sets</h2>
<p>Certain types of QMC point sets are defined pretty much like random number generators, in the sense that the successive coordinates of each point follow a simple linear recurrence over a finite state space \(\mathcal{S}\), with a transition function \(f : \mathcal{S}\to\mathcal{S}\), and an output function \(g : \mathcal{S}\to[0,1)\). The point set is defined as </p><p class="formulaDsp">
\[ P_n = \{\mathbf{u}= (u_0,u_1,…) : s_0\in\mathcal{S}, s_j = f(s_{j-1}), \mbox{ and } u_j = g(s_j) \mbox{ for all } j\}. \]
</p>
<p> This is the set of all vectors of successive output values produced by the recurrence defined by \(f\) and the output function \(g\), from all possible initial states. The value of \(n\) is the cardinality of \(\mathcal{S}\) and the dimension \(s\) is infinite. We could also have \(n = \infty\) (an infinite sequence) if \(\mathcal{S}\) is infinite but denumerable and ordered (so we know in which order to enumerate the points).</p>
<p>Let us assume that \(n\) is finite and that for each \(s_0\in\mathcal{S}\), the recurrence \(s_j = f(s_{j-1})\) is <em>purely periodic</em>, i.e., there is always an integer \(j\) such that \(s_j = s_0\). The smallest such \(j\), called the <em>period length</em>, depends in general on \(s_0\). Thus, the state space \(\mathcal{S}\) is partitioned into a finite number of <em>cycles</em>. The successive coordinates of any point \(\mathbf{u}\in P_n\) are periodic with period length equal to the length of the cycle that contains \(s_0\) (and the following \(s_j\)’s).</p>
<p>One way of implementing such a point set while avoiding to recompute \(f\) and \(g\) each time a coordinate is needed is to store explicitly all the cycles of the recurrence, in the form of a <em>list of cycles</em>. We can store either the successive \(u_j\)’s directly, or the successive \(s_j\)’s, over each cycle. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">umontreal.ssj.hups.CycleBasedPointSet</a> provides the framework for doing that. For example, a Korobov lattice point set is defined via the recurrence \(x_j = a x_{j-1} \bmod n\) and output function \(u_j = x_j/n\). If \(n\) is prime and \(a\) is a primitive element modulo \(n\), then there are two cycles: one of period 1 that contains only 0, and the other of period \(n-1\). For more general \(n\) and \(a\), there will be more cycles. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">umontreal.ssj.hups.LCGPointSet</a> constructs this type of point set and stores explicitly the successive values of \(u_j\) over the different cycles.</p>
<p>There are cases where \(n\) is a power of two, say \(n = 2^k\), and where the state \(s_j\) is represented as a \(k\)-bit string. Concrete instances are usually based on linear recurrences modulo 2 and they include the Korobov-type <em>polynomial lattice rules</em> in base 2 <a class="el" href="citelist.html#CITEREF_rDIC10a">[49]</a>, <a class="el" href="citelist.html#CITEREF_rLEC99a">[147]</a>, <a class="el" href="citelist.html#CITEREF_vLEC99a">[122]</a>, <a class="el" href="citelist.html#CITEREF_rLEC02b">[129]</a>, <a class="el" href="citelist.html#CITEREF_vLEM03a">[158]</a>, <a class="el" href="citelist.html#CITEREF_rNUY14a">[183]</a>, <a class="el" href="citelist.html#CITEREF_rPAN04a">[191]</a>. In that context, it is often more convenient to store the successive states \(s_j\)’s instead of the successive \(u_j\)’s, over the set of cycles (e.g., if a random digital shift in base 2 is to be applied to randomize the points, it can be performed by applying a bitwise xor directly to \(s_j\)). When generating the coordinates, the \(s_j\)’s can be interpreted as \(2^k\)-bit integers and multiplied by \(2^{-k}\) to produce the output. This is supported by the class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">umontreal.ssj.hups.CycleBasedPointSetBase2</a>.</p>
<h2>Point set implementations and enumeration tools</h2>
<p>The base class for point sets is the abstract class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>. It has several predefined subclasses. Let \(\mathbf{u}_i = (u_{i,0}, u_{i,1}, \dots, u_{i,s-1})\) be the elements of the point set \(P_n\), for \(i=0,\dots,n-1\) (the point and coordinate indexes both start at 0). The number of points \(n\) and the dimension \(s\) can be finite or infinite. Conceptually, the point set can be viewed as a two-dimensional array whose element \((i,j)\) contains \(u_{i,j}\), the coordinate \(j\) of point \(i\). In the implementations of typical point sets, the values \(u_{i,j}\) are not stored explicitly in a two-dimensional array, but relevant information is organized so that the points and their coordinates can be generated efficiently. One notable exception is <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">umontreal.ssj.hups.CachedPointSet</a>, in which all (randomized) points are stored explicitly. This is required for certain types of randomizations such as stratified sampling and Latin hypercube sampling, for example.</p>
<p>To enumerate the successive points or the successive coordinates of a given point, we use <em>point set iterators</em>, that resemble the iterators defined in Java <em>collections</em>, except that they loop over bi-dimensional sets. Their general behavior is defined in the interface <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a>. It contains methods to traverse a point set. One can return only one coordinate, \(t\) coordinates, change the current coordinate and current point index, reset the iterator, and so on. Several independent iterators can coexist at any given time for the same point set. Each one maintains a current point index and a current coordinate index, which are incremented by 1 when the iterator advances to the next point or to the next coordinate. Both are initialized to 0. Each subclass of <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> has its own implementation of <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> and has a method <code>iterator()</code> that creates and returns a new specialized point set iterator of the correct type, allowing efficient access to the coordinates.</p>
<p>An important feature of the <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> interface is that it extends the <a class="el" href="interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> interface. This means that any point set iterator can be used in place of a random stream that is supposed to generate i.i.d. \(U(0,1)\) random variables, anywhere in a simulation program. This makes it very easy to replace the (pseudo)random numbers by the coordinates \(u_{i,j}\) of a deterministic (or randomized) HUPS without changing the internal code of the simulation program.</p>
<h2>Randomized quasi-Monte Carlo</h2>
<p>In their original versions, these HUPS described so far are deterministic, and the corresponding QMC methods give a <em>deterministic</em> integration error that is difficult to estimate. In <em>randomized</em> QMC methods, \(P_n\) is randomized, preferably in a way that it retains its high uniformity over \([0,1)^s\) when taken as a set, while each of its points has the uniform distribution over \([0,1)^s\) when taken individually. Then, \(Q_n\) becomes an unbiased estimator of \(\mu\), hopefully with smaller variance than the standard MC estimator. To estimate the variance and compute a confidence interval on \(\mu\), one can apply \(m\) independent randomizations to the same \(P_n\), and compute \({\bar{X}_m}\) and \({S_{m,x}^2}\), the sample mean and sample variance of the \(m\) corresponding (independent) copies of \(Q_n\). Then, \(E[\bar{X}_m] = \mu\) and \(E[S_{m,x}^2] = \mathrm{Var}[Q_n] = m\mathrm{Var}[\bar{X}_m]\) <a class="el" href="citelist.html#CITEREF_vLEC00b">[123]</a>, <a class="el" href="citelist.html#CITEREF_vOWE97a">[187]</a>, <a class="el" href="citelist.html#CITEREF_vOWE03a">[190]</a>.</p>
<p>Two examples of such randomizations are the <em>random shift modulo 1</em>, proposed in <a class="el" href="citelist.html#CITEREF_vCRA76a">[37]</a> and implemented in class umontreal.ssj.hups.RandShiftedPointSet, and the <em>random digital shift in base \(b\)</em>, described and implemented in class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a>. In the random shift modulo 1, we generate a <em>single</em> point \(\mathbf{u}\) uniformly over \([0,1)^s\) and add it to each point of \(P_n\), coordinate-wise, modulo 1. Since all points of \(P_n\) are shifted by the same amount, the set retains most of its structure and uniformity. For the random digital shift in base \(b\), we generate again a single \(\mathbf{u}= (u_0,\dots,u_{s-1})\) uniformly over \([0,1)^s\), write the digital expansion in base \(b\) of each of its coordinates, say \(u_j = \sum_{\ell=1}^{\infty}d_{j,\ell} b^{-\ell}\), then add \(d_{j,\ell}\) modulo \(b\) to the \(\ell\)th digit of the digital expansion in base \(b\) of the \(j\)th coordinate of each point \(\mathbf{u}_i\in P_n\). For \(b=2\), the digit-wise addition modulo \(b\) becomes a bitwise exclusive-or, which is fast to perform on a computer.</p>
<p>An important property of the digital shift in base \(b\) is that if the hypercube \([0,1)^s\) is partitioned into \(b^{q_1 + \cdots+ q_s}\) rectangular boxes of the same size by partitioning the \(j\)th axis into \(b^{q_j}\) equal parts for each \(j\), for some integers \(q_j \ge0\) (such a partition is called a <em> \(\mathbf{q}\)-equidissection in base \(b\)</em> of the unit hypercube, where \(\mathbf{q}= (q_1,…,q_s)\)), then the number of boxes that contain \(m\) points, for each integer \(m\), is unchanged by the randomization. In particular, if each box contains the same number of points of \(P_n\) before the randomization, then it also does after the randomization. In this case, we say that \(P_n\) is <em> \(\mathbf{q}\)-equidistributed in base \(b\)</em>. Several other randomization methods exist and most are adapted to special types of point sets; for example they randomize the generator matrices of a digital net <a class="el" href="citelist.html#CITEREF_vOWE03a">[190]</a>.</p>
<p>In the <code>hups</code> package, viewed from the outside, randomization methods for QMC point sets are defined in classes that implement the <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> interface. Each subclass of <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> defines a type of randomization. By combining a <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html">PointSet</a> object with a <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> object, one can obtain an <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html">umontreal.ssj.hups.RQMCPointSet</a> object. However, not every type of randomization is compatible with a given type of point set. For example, a umontreal.ssj.hups.LMSScrambleShift and a <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html">umontreal.ssj.hups.NestedUniformScrambling</a> apply only to <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> point sets. The usual (and recommended) way of doing RQMC in SSJ is to construct a <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> and a compatible <code><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code>, combine them into an <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html" title="This class is used for randomized quasi-Monte Carlo (RQMC) simulations , , ,  . ">RQMCPointSet</a></code>, and use the latter to run RQMC experiments. The class umontreal.ssj.hups.RQMCExperiments offers some methods that can perform such experiments for simple Monte Carlo models. Examples are given in the tutorial.</p>
<p>Conceptually, one could think of the <code><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> objects as filters that transform all the QMC points \(\mathbf{u}_i\) after they have been computed. However, almost all randomizations are not implemented that way, but they are incorporated directly in the calculation of the points \(\mathbf{u}_i\) by the point set iterators in the <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> subclasses, mainly for reasons of efficiency. In fact, the <code>randomize</code> method of a <code><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> applied to a <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object <code>p</code> can only impact the point set <code>p</code>, which means that the randomization must be incorporated in <code>p</code> in some way. For example, a randomization that changes the generator matrices of a <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html" title="This class provides the basic structures for storing and manipulating linear digital nets in base ...">DigitalNet</a></code> is implemented by changing directly those generator matrices in the <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html" title="This class provides the basic structures for storing and manipulating linear digital nets in base ...">DigitalNet</a></code> object before generating the point. The old matrices are saved so we can revert the change. The random shifts and digital random shifts are also applied directly inside the <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object when the points are generated. Each <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> has a method <code>addRandomShift</code> that takes a <code>RandomStream</code> and generates a random shift to be applied to all the points. Depending on the type of point set, it can be either a digital shift or a shift modulo 1. This must be specified and defined inside each subclass of <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code>. By default, for all <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> point sets, this random shift is a <em>random digital shift</em>, whereas for ordinary lattice rules it is a <em>random shift modulo 1</em>. For any given type of point set, one should check the documention to make sure what the <code>addRandomShift</code> method really does. A <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html">umontreal.ssj.hups.RandomShift</a> is a type of randomization that invokes directly this internal <code>addRandomShift</code> facility.</p>
<p>One complication arises in the case of point sets having an unbounded number of coordinates; for example, a #CycleBasedPointSet, whose points have a infinite number of coordinates. In this case, the random shift must be generated for a finite number of coordinates, but it can always be extended later if we need more (randomized) coordinates for any given point. This is one of the main reasons for having a version of the <code>addRandomShift</code> method that generates the random shift only over an arbitrary range of coordinates, say from <code>d1</code> to <code>d2-1</code>. It can be used to <em>extend</em> the current random shift if needed. This extension will usually be performed automatically by the iterator, using the same <code>RandomStream</code> that was used to produce the previous random shift (this stream is saved internally for this purpose).</p>
<p>We recommend to always use a <code><a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> object (such as a <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandomShift.html" title="This class implements a umontreal.ssj.hups.PointSetRandomization. ">RandomShift</a></code>) and use its <code>randomize (<a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a> p)</code> method rather than calling <code>addRandomShift</code> directly, because this permits one to change the randomization externally without changing the <code>randomize</code> call internally in a simulation program. The tutorial and the code of some methods in umontreal.ssj.hups.RQMCExperiments provide examples of that.</p>
<p>With the current implementation, in which the randomizations are integrated in the <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object itself and not in the iterator, different iterators operating in parallel on the same point set will all eumerate the same randomized points when the points are randomized. To have independent randomizations for the different iterators, the randomizations would have to be implemented in the iterators. Currently, to use different randomizations of the same point set in parallel, one can simply construct many instances of the same point set and randomize them independently.</p>
<h2>Transformed point sets and containers</h2>
<p>Aside from the <a class="el" href="interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> subclasses, the <code>hups</code> package also offers tools to transform arbitrary point sets in various ways, either deterministically or randomly, by external filters. Some deterministic transformations can be applied to eliminate some points or coordinates (i.e., selecting subsets), or to concatenate point sets (padding), or to take an antithetic version of a point set, for example. Some types of random transformations can be used for RQMC. When a point set is transformed, we usually want to keep the original as well, and we may want to apply different types of transformations in succession to the same point set.</p>
<p>This is achieved via <em>container</em> point sets, which are defined in terms of another point set to which they keep a reference and apply certain transformations. <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">umontreal.ssj.hups.ContainerPointSet</a> is the base class for such containers. The contained point set can be a container itself and this can be done recursively, but many levels of recursivity can obviously slow down the generation of the points.</p>
<p>One example of a <code><a class="el" href="classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html" title="This acts as a generic base class for all container classes that contain a point set and apply some k...">ContainerPointSet</a></code> that performs a randomization is a <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html">umontreal.ssj.hups.RandShiftedMod1PointSet</a>, which applies a random shift modulo 1 to the point set that it contains, whatever it is. It can be used for instance if one wishes to apply a random shift modulo 1 to a <code>Digitalnet</code>.</p>
<p>The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">umontreal.ssj.hups.CachedPointSet</a> can be used to store the coordinates of a point set. It is then stored internally as a matrix and can be accessed very efficiently. The <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">umontreal.ssj.hups.SubsetOfPointSet</a> allows one to constrain a point set’s size or dimension, for example to get the dimension of a cycle-based point set finite. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">umontreal.ssj.hups.PaddedPointSet</a> gathers some coordinates of several point sets to construct a padded point set. The class <a class="el" href="classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">umontreal.ssj.hups.AntitheticPointSet</a> allows one to switch on or off the antithetic coordinates generation. Such container point sets implement their own iterators that use the iterators of the contained point sets to access the points almost as efficiently as if the contained point set iterators were used directly.</p>
<h2>Examples</h2>
<p>See the tutorial. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
